---
layout: post
title: 《Learning Python》学习笔记——27.类的设计
time: 2013-3-11
category: Python
---

#Python和OOP#
Python的00P实现可以概括为三个概念:

- 继承
  继承是基于Python中的属性查找的。
- 多态
  在X.method方法中，method的意义取决于X的类型(类)。
- 封装
  方法和运算符实现行为，数据隐藏默认是一种管理。

##通过调用标记进行重载##
在一些其他的OOP语言中，通常是通过参数的不同类型来实现重载的，比如C++和JAVA，但是在Python中是没有类型声明的，所以在Python中并不鼓励这么做。
{% highlight python3 %}
class C:
  def meth(self,x):
    ...
  def meth(self,x,y,z):
    ...
{% endhighlight %}
上述的代码最终有效的只有最后定义的那个meth，因为Python中的def语句只是把一个函数对象绑定到一个变量上去，从根本上说，def只是一个赋值语句。所以上述的代码其实就对同一个变量的对此赋值，因此只有最后的赋值时有效的。

当然在Python中确实是可以使用类型作为标记的，比如:
{% highlight python3 %}
class C:
  def meth(self,*args):
    if len(args)==1:
      ...
    elif type(arg[0])==int:
      ...
{% endhighlight %}
但是上面的代码完全是C++风格的，不具有Python的特性。

应该把程序写成预期的对象接口，而不是特定的数据类型。

{% highlight python3 %}
class C:
  def meth(self,x):
    x.operation()
{% endhighlight %}
通常来说，独特的运算使用独特的方法名，不要依赖于调用标记，这样做才是更好的选择。

#类的伪私有属性#
默认情况下，客户端是可以读取或修改任何它们想要的类或实例的属性。事实上，用C++术语来讲，属性都是"public"和"virtual"，在任意地方都可进行读取，并且在运行时进行动态查找。

然而，Python也支持变量名压缩的概念，让类内某些变量局部化。压缩后的变量名有时被误认为是"私有属性"，但这其实只是一种把类所创建的变量名**局部化**方式而已:名称压缩并不能阻止类外代码对它的读取。这种功能主要是为了避免实例内命名空间的冲突，而不是限制变量名的读取。因此，压缩的变量名最好称为"伪似有"，而不是"似有"。

##变量名压缩概览##
变量名压缩的工作方式是:class语句内开头有两个下划线，但结尾没有两个下划线的变量名，会自动扩张，从包含了所在类的名称。例如，像Spam类内\_\_X这样的变量名会自动变成\_\_Spam\_X:原始的变量名会在头部加入一个下划线，然后是所在类的名称。因为修改后的变量名包含了所在类的名称，相当于变得独特。不会和同一层次中其他类所创建的类似变量名相冲突。

#方法是对象:绑定或无绑定#
方式也是一种对象，并且可以用于其他对象大部分相同的方式来广泛地使用——可以对它们赋值、将其传递给函数、存储在数据结构中，等等。由于类方法可以从一个实例或一个类访问，它们实际上在Python中有两种形式:

- 无绑定类方法对象:无self
  通过对**类**进行点号运算从而获取函数属性，会传回无绑定(unbound)方法对象。在调用该方法时，必须明确提供实例对象作为第一个参数。在Python3.0中，一个无绑定方法和一个简单函数是相同的，可以通过类名来调用。
- 绑定实例方法对象:self+函数对
  通过对**实例**进行全运算从而获取类的函数属性，会传回绑定(bound)方法对象。Python在绑定方法对象中自动把实例和函数打包，所以，不用传递实例去调用该方法。

这两种方法都是功能齐全的对象，可四处传递，就像字符串和数字。
{% highlight python3 %}
class Spam:
  def doit(self,message):
    print(message)

object1=Spam()
object1.doit('hello world')
{% endhighlight %}
上述代码，创建了一个类对象，然后创建了一个实例，出入一个字符串，将其打印出来。不过，其实，绑定对象就在上述过程中产生，就在方法调用的括号前。事实上，我们可以获取绑定方法，而不用实际进行调用。object.name点号结合运算是一个对象表达式。在下列代码中，会传回绑定方法对象，把实例(object1)和方法(Spam.doit)打包起来。我们可以这个绑定方法赋值给另一个变量名，然后像简单函数那样进行调用。
{% highlight python3 %}
object1 = Spam()
x = object1.doit
x('hello world')
{% endhighlight %}
另一方面，如果对类进行点号运算来获得doit，就会得到**无绑定**方法对象，也就是函数对象引用值。要调用类方法时，必须传入实例作为最左侧参数。
{% highlight python3 %}
object1=Spam()
t = Spam.doit
t(object1,'howdy')
{% endhighlight %}
通常情况下，用过点号运算取出方法后，就是立即调用，所以你不会注意到这个过程中产生的方法对象。

##在Python3.0中，无绑定方法是函数##
在Python3.0中，该语言已经删除了**无绑定方法**的概念。上面所说的无绑定方法，在Python3.0中当做一个简单函数对待。

另外，在Python3.0中，不使用一个实例而调用一个方法是没有问题的，只要这个方法不期待一个实例，并且你通过类调用它而不是通过一个实例调用它。也就是说，只有对通过实例调用，Python3.0才会向方法传递一个实例。当通过一个类调用的时候，只有在方法期待一个实例的时候，才必须手动传递一个实例:
{% highlight python3  %}
class Selfless:
  def __init__(self,data):
    self.data=data
  def setfless(arg1,arg2):
    return arg1+arg2
  def normal(self,arg1,arg2):
    return self.data+arg1+arg2


X = Selfless(2)
X.normal(3,4)               #return 9
Selfless.normal(X,3,4)      #return 9
Selfless.setfless(3,2)      #return 7
{% endhighlight %}
上述代码中的最后一行，在Python2.6中是失效的，因为无绑定方法默认地需要传递一个实例，它在Python3.0中有效，因为这样的方法当做一个简单函数对待，而不需要一个实例。

#多重继承:"混合"类#
搜素属性时，Python自左至右搜索首行中的超类，直到找到相符者。从技术上来讲，因为任何超类本身可能还有一些其他的超类，对于更大的类树，这个搜索可以更复杂一点。

- 在传统类(默认的类，直到Python3.0)，属性搜索处理对所有路径深度优先，直到继承树的顶端，然后从左至右进行。
- 在新式类(以及Python3.0的所有类中)，属性搜索处理沿着树层级、以更加广度优先的方式进行。

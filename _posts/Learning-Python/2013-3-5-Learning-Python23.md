---
layout: post
title: 《Learning Python》学习笔记——23.OOP:宏伟蓝图
time: 2013-3-5
category: Python
---

#为何使用类#
类是Python的程序组成单元，就像函数和模块一样:类是封装逻辑和数据的另一种方式。实际上，类也定义新的命名空间，在很大程度上就像模块。但是，和我们已见过的其他程序组成单元相比，类有三个重要的独到之处，使其在建立对象时更为有用。

- **多重实例**
  类基本上就是产生对象的工厂。每次调用一个类，就会产生一个有独立命名空间的新对象。每个由类产生的对象都能够读取类的属性，并获得自己的命名空间来存储数据，这些数据对于每个对象来说都是不同的。
- **通过继承进行定制**
  类也支持OOP的继承的概念。我们可以在类的外部重新定义其属性从而扩充这个类。更通用的是，类可以建立命名空间层次结构，而这种层次结构定义该结构中类创建的对象所使用的变量名。
- **运算符**
  通过提供特定的协议方法，类可以定义对象来响应在内置类型上的几种运算。例如，通过类创建的对象可以进行切片、级联和索引等运算。Python提供了一些可以由类使用的钩子，从而能够中断并实现任何的内置类型运算。

#概览OOP#

##属性继承搜索##
Python中大多是OOP都可以简化为如下的代码:
{% highlight python3 %}
object.attribute
{% endhighlight %}
 当我们对class语句产生的对象使用这种方式时，这个表达式会在Python中启动搜索——搜索对象连接的树，来寻找attribute首次出现的对象。当类启用时，上边的代码实际上等于下面的自然语言。

"找出attribute首次出现的地方，先搜索object，然后是该对象之上的所有类，又下至上，由左至右。"

换句话说，取出属性只是简单地搜索"树"而已。我们称这种搜索程序为继承，因为树中的位置较低的对象继承了树种位置较高的对象拥有的属性。当从下至上进行搜索时，连接至树中的对象就是树中所有上层对象所定义的所有属性的集合体，知道树的最低高端。

##编写类树##
用class语句来构造对象时，主要内容如下:

- 每个class语句会生成一个新的类对象。
- 每次类调用时，就会生成一个新的实例对象。
- 实例自动连接至创建了这些实例的类。
- 类连接至其超类的方式是，将超类列在类头部的括号内。其从左至右的顺序会决定树中次序。
{% highlight python3 %}
class C2:...         #Make class ojects(ovals)
class C3:...
class C1(C2,C3):...  #Linked to superclasses

I1=C1()              #Make instance objects(rectangles)
I2=C1()              #Linked to their classes
{% endhighlight %}
这个例子使用了所谓的 **多重继承**。也就是时候，在类树中，类有一个以上的超类。在Python中，如果class语句中的小括号内有一个以上的超类(就像C1一样)，它们由左至右的次序会决定超类搜索的顺序。
{% highlight python3 %}
class C1(C2,C3):
  def setname(self,who):
    self.name = who

I1=C1()
I2=C1()
I1.setname("bob")
I2.setname("mel")
print(I1.name)
{% endhighlight %}
在上面的代码中，def语法没什么特别之处。从操作角度来看，当def出现在这种类的内部时，通常称为方法，而且会自动接收第一个特殊参数(通常称为self)，这个参数提供了被处理的实例的参照值。这里的self就像C++或JAVA中的this，但是在Python中必须明确地写出self。

当方法对self属性进行赋值时，会创建或修改类树低端实例内的属性，因为self自动引用正在处理的实例。

对于上面的代码来说，直到setname方法被调用之前，C1类不会把name属性附加在实例之上。事实上，调用I1.setname前引用I1.name会产生未定义变量名的错误。如果类想确保像name这样的变量名一定会在其实例中设置，通常都会在构造时填好这个属性。
{% highlight python3 %}
class C1(C2,C3):
  def __init__(self,who):
    self.name=who

I1=C1('bob')
I2=C1('mel')
print(I1.name)
{% endhighlight %}
每次从类产生实例时，Python会自动调用名为\_\_init\_\_的方法。新实例会如往常那样传入\_\_init\_\_的self参数，而列在类调用小括号内的任何值会成为第二以及其后的参数。其效果就是在创建实例时初始化这个实例，而不需要额外的方法调用。

其实 \_\_init\_\_的运行机制，就是构造函数。


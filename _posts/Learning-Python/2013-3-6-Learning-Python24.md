---
layout: post
title: 《Learning Python》学习笔记——24.类代码编写基础
time: 2013-3-6
category: Python
---

#类产生多个实例对象#

- **类对象**:类对象提供默认行为，是实例对象的工厂。
- **实例对象**:是程序处理的实际对象，各自都有独立的命名空间，但是继承创建该实例的类中的变量名。

##类对象提供默认行为##

- **class语句创建类对象并将其赋值给变量名**
- **class语句内的赋值语句会创建类的属性**
- **类属性提供对象的状态和行为**

##实例对象是具体的元素##

- **像函数那样调用类对象会创建新的实例对象**
- **每个实例对象继承类的属性并获得自己的命名空间**
- **在方法内对self属性做赋值运算会产生每个实例自己的属性**

#类通过继承进行定制#

- **超类列在了类开头的括号中**
- **类从其超类中继承属性**
- **实例会继承所有可读取类的属性**
- **每个object.attribute都会开启新的堵路搜索**
- **逻辑的修改是通过创建子类，而不是修改超类**
- **类是模块内的属性**

#类可以截获Python运算符#
**运算符重载:**让用类写成的对象，可截获并响应用在内置类型上的运算。

- **以双下线命名的方法(\_\_X\_\_)是特殊的钩子**
  
  Python运算符重载的实现是提供特殊命名的方法来拦截运算。Python语言替每种运算和特殊命名的方法之间定义了固定不变的映射关系。
- **当实例出现在内置运算时，这类方法会自动调用**
- **类可覆盖多数内置类型运算**
- **运算符覆盖方法没有默认值，而且也不需要**
- **运算符可让类与Python的对象模型集成**

#世界上最简单的类#
{% highlight python3 %}
class rec: pass
rec.name='Bob'
rec.age=40
{% endhighlight %}
上面的代码时合法的，因为类本身也是对象。事实上，类只是独立完备的命名空间，只要有类的引用值，就可以在在任何时刻设定或修改其属性。
{% highlight python3 %}
x = rec()
y = rec()
x.name y.name     #('Bob','Bob')
{% endhighlight %}
但是，当建立实例的时候，实例会继承创建它们的类。其实，此时，这些实例本身是没有属性的。它们只是从类对象那里取出了name属性。
{% highlight python3 %}
x.name='Sue'
x.name y.name     #('Sue','Bob')
{% endhighlight %}
但是，当对一个实例对象赋值的时候，就会在该对象内创建(或修改)该属性，而不会因属性的引用而启动继承搜索，因为属性赋值运算只会影响到赋值所在的对象。在这里，x得到自己的name，但y依然继承附加在它的类上的name。

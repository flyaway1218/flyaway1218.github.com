---
layout: post
title: 《Learning Python》学习笔记——28.类的高级主题
time: 2013-3-12
category: Python
---

#新式类#

- 对于Python3.0来说，所有的类都是新式类，不管它们是否显示地继承自object。所有的类都继承自object，并且，所有对象都是object的实例。
- 在Python2.6及其以前的版本中，类必须显示地声明继承自object才被看做是新式类。

#新式类变化#

- 类和类型合并
  类现在就是类型，类型就是类。type(I)内置函数返回一个实例所创建自的类，而不是一个通用的实例类型，并且，通常是和I.\_\_class\_\_相同的。此外，类是type类的实例。
- 继承搜索顺序
  多继承的钻石模式有一种略微不同的搜索顺序，总体而言，它们可能先横向搜索，再总想搜索，并先宽度优先搜索，再深度优先搜索。
- 针对内置函数的属性获取
  \_\_getattr\_\_和\_\_getattribute\_\_方法不再针对内置运算的隐式属性获取而运行。这意味着，它们不再针对\_\_X\_\_运算符重载方法名而调用，这样的名称搜索从类开始，而不是从实例开始。


##类型模式变化##
在新式类中，类型和类的区别已经完全消失了。类自身就是类型:type对象产生类作为自己的实例，并且类产生它们的类型的实例。实际上，像列表和字符串这样的内置类型和编写为类的用户定义类型之间没有真正的区别，这就是为什么我们可以子类化内置类型。

##钻石继承变动##
在新式类中，搜索相对来说是宽度优先度的。Python先寻找第一个搜索的右侧的所有超类(**层次遍历继承树**)，然后才一路往上搜索至顶端共同的超类。

#新式类的扩展#
将字符串属性名称顺序赋值给特殊的 \_\_slots\_\_类属性，新式类就有可能既限制类的实例将有的合法属性集，又能够优化内存和速度性能。

这个特殊属性一般是在class语句顶层内将字符串名称顺序赋值给变量\_\_slots\_\_而设置:只有在\_\_slots\_\_列表内的这些变量名可赋值为实例属性。但是，需要强调的是，Python中的所有变量名、实例属性名必须在引用前赋值，即使是列在\_\_slots\_\_中也是这样。

**Slot和通用代码**

使用slots的时候，实例通常没有一个属性字典(\_\_dict\_\_)，只有slot列表中的名称才可以分配给实例。但是这不影响一些通用工具的使用。


##Class Property##
有一种称为 **特性(property)**的机制，提供另一种方式让新式类定义自动调用的方法，来读取或赋值实例属性。这可以作为\_\_getattr\_\_和\_\_setattr\_\_重载方法的替代做法。Property和这两个方法由类似的效果，但是只在读取所需要动态计算的变量名时，才会发生额外的方法调用。

可以通过三种不同的操作(set、get and delete)和文档字符串来激活一个property，如果是传递参数是None或省略的的话，则不会支持相应的操作。property需要在class语句中的最顶层进行赋值，一旦赋值好了，所有对相应属性的访问操作(get)都会被传递给property，就像\_\_getattr\_\_拦截对未定义的属性的引用一样。
{% highlight python3 %}
class newprops(object):
  def getage(self):
    return 40
  age = property(getage,None,None,None)     #get,set,del,docs

x = newprops()
x.age                                       #40
x.name                                      #AttributeError:newprops instance has no attribute 'name'
{% endhighlight %}

##\_\_getattribute\_\_和escriptors##
\_\_getattribute\_\_只适用于新式类，它允许一个类能够截获**所有**对属性的引用，而不只是未定义的属性引用。


#静态方法和类方法#
从Python2.2开始，在类中是可以定义两种能够不通过实例就能调用的方法:一种是和普通的函数很类似的不需要实例参数的**静态方法**，另外一种就是通过类名来调用的**类方法**，而不是通过实例调用。

为了使用这些方法，必须在类中调用名为 **staticmethod**和**classmethod**的特殊内置函数。在Python3.0中，无实例的方法只通过类名来调用，而不需要一个**staticmethod**的声明，但是如果通过实例来调用，那就需要声明。

##为什么使用特殊方法##
静态方法用来处理类的数据而不是实例的数据，静态方法从不需要一个自动传入的self 参数，不管是通过类调用还是通过实例调用。它们通常追踪横跨多个实例的数据，而不是为实例提供行为。

虽然比较少用，Python也支持类方法的概念——被调用的时候，自动传入一个类对象，而不是一个实例对象作为第一参数，不管它是被实例调用还是被类调用。这样的方法能够通过self参数访问类的数据，即使是通过一个实例调用的。

##Python2.6和Python3.0中的静态方法##

- 在Python2.6中，从一个类获取一个方法会产生一个**未绑定的方法**，没有手动传递一个实例，它是无法被调用的。
- 在Python3.0中，从一个类获取一个方法会产生一个**简单函数**，没有传递一个实例也能正常被调用。

换句话说，在Python2.6中，类方法总是要求传入一个实例参数，不过是通过类还是实例调用。然后，在Python3.0中，只有当一个方法期待实例额时候，我们才需要传递给它，没有self参数的方法可以通过类来调用而不需要传入一个实例。

- 在Python2.6中，我们必须总是把一个方法声明为静态的，从而不带一个实例而调用它，不管是通过一个类或一个方法。
- 在Python3.0中，如果方法只通过一个实例调用的话，我们不需要将这样的方法声明为静态的，但是，想要通过一个实例调用的时候，那就必须手动声明为静态方法。

##使用静态方法和类方法##
{% highlight python3 %}
class Methods:
  def imeth(self,x):
    print(sefl,x)

  def smeth():
    print(x)

  def cmeth(cls,x):
    print(cls,x)

  semth = staticmethod(semth)
  cmeth = classmethod(cmeth)
{% endhighlight %}

#装饰器和元类:第一部分#
**函数装饰器(function decorator)**提供了一种方式，替函明确了特定的运算模式。Python提供了一些内置函数装饰器，来做一些运算，例如，标识静态方法，但是程序员也可以编写自己的任意装饰器。

##函数装饰器基础##
静态方法可以用下面的装饰器语法来编写:

{% highlight python3 %}
class C:
  @staticmethod
  def meth():
    ...
{% endhighlight %}
上面的代码和如下的代码等同：
{% highlight python3 %}
class C:
  def meth():
    ...
  meth = staticmethod(meth)
{% endhighlight %}
记住，staticmethod仍然是一个内置函数，它可以用于装饰器语法中，只是因为它把一个函数当错参数并且返回一个可调用对象。实际上，任何这样的函数都可以以这种方式使用。


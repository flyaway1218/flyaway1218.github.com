---
title: 《Learning Python》学习笔记——9.赋值、表达式和打印
time: 2013-2-2
layout: post
category: Python
---

#赋值语句#

赋值语句的特性:

- 赋值语句建立对象的引用
- 变量名在首次赋值时会被创建
- 变量名在引用前必须先赋值

Python赋值语句形式:

|------------------------------+---------------------------------------|
|        运算                  |   解释                                |
|:-----------------------------|:--------------------------------------|
|  spam = 'Spam'               |  基本形式                             |
|  spam,ham='yum','YUM'        |  元组赋值运算(位置性)                 |
|  [spam,ham]=['yum','YUM']    |  列表赋值运算(位置性)                 |
|  a,b,c,d='spam'              |  序列赋值运算，通用性                 |
|  a,*b ='spam'                |  扩展的序列解包(Python3.0)            |
|  spam=ham='lunch'            |  多目标赋值运算                       |
|  spams += 42                 |  增强赋值运算(相当于spams=spams+42)   |
|------------------------------+---------------------------------------|

其中有几点需要说明:

- 第三行和第二行的赋值结果是一样的，spam绑定到'yum',ham绑定到'YUM',在Python中，这叫做分解赋值
- 第四行的赋值结果是:a赋值为's',b赋值为'p',c赋值为'a',d赋值为'm'
- 第五行，用右边的字符串的第一个字母来匹配a，用剩下的部分来匹配b:a赋值为's',b赋值为'pam'.这在Python称作扩展的解包。需要注意的是，带星号的变量总是返回的是一个列表，哪怕只有一个元素或没有元素
- 最后一行的用法和C/C++等其他语言中的语法和意义都是一样的，需要说明的是，在Python中，每个二元表达式运算符都有增强赋值语句
- **赋值语句执行时，Python会建立临时的元组，来存储右侧变量原始的值**

根据上面最后一点的说明，在Python中可以实现不用第三个变量就能交换两个变量的值:

{% highlight python %}
a = 1
b = 2
b,a=a,b
{% endhighlight %}

##多目标赋值语句##

**多目标赋值以及共享引用**

当使用多目标赋值时，需要注意的是，这些变量都是指向同一个对象的。这对于不可变的类型来说，没什么问题，但是对于原处可变的类型来说，需要特别注意了。

{% highlight python3 %}
a = b = []
b.append(42)
a,b
{% endhighlight %}

上面的代码执行后，a和b都是[42]

##增强赋值语句##

Python支持一下的增强语句:

|  X+=Y  |  X&=Y  |  X-=Y  |  X\|=Y  |
|  X*=Y  |  X^=Y  |  X/=Y  |  X>>=Y |
|  X%=Y  |  X<<=Y |  X**=Y |  X//=Y |

在Python中使用了优化技术，增强赋值语句会在底层实现时比较高效

**另外需要注意的是，在使用增强赋值语句时，对于可变变量来说是原处修改的，需要特别注意！**

##变量命名规则##

- 语法:(下划线或字母)+(任意数目的字母、数字或下划线)
- 区分大小写
- 禁止使用保留字

Python3.0中的保留字:

|  False  |  class     |  finally  |  is         |  return  |
|  None   |  continue  |  for      |  lamdba     |  try     |
|  True   |  def       |  from     |  nonlocal   |  while   |
|  and    |  del       |  global   |  not        |  with    |
|  as     |  elif      |  if       |  or         |  yield   |
|  assert |  else      |  import   |  pass       |          |
|  break  |  except    |  in       |  raise      |          |

**命名惯例**

- 以单一下划线开头的变量名(_X)不会被from module import *语句导入
- 前后有下划线的变量名(_X_)是系统定义的变量名，对解释器有特殊意义
- 以两下划线开头、但结尾没有两个下划线的变量名(__X)是类的本地("压缩")变量

#打印操作#

在Python中，print语句可以实现打印:只是对程序员友好的标准输出流的接口而已
标准输出流、标准输入流、错误流是脚本启动时所创建的3中数据连接中的一种。

- 在Python3.X中，打印是一个内置函数，用关键字参数来表示特定模式
- 在Python2.X中，打印是语句，拥有自己的特定语法

##Python3.0中的print函数##

print函数不会返回任何值，从技术上讲，它将返回None。

**调用格式**

从语法上讲，Python3.0中的print函数有如下的形式。

{% highlight python %}
print([object,..][,sep=' '][,end='\n'][,file=sys.stdout])
{% endhighlight %}

在上述表达式中，方括号中的项是可选的，并且可能会在一个给定的调用中省略，并且=后面的值都给出了参数的默认值。这个内置的函数吧字符串sep所分割开的一个或多个对象的文本表示，后面跟着字符串and，都打印到流file中。

这些参数是这样控制print操作的:

- sep是在每个对象的文本之间插入的一个字符串，如果没有传递的话，它默认地是一个单个空格；传递一个空字符串将会抑制分隔符
- end是添加在打印文本末尾的一个字符串，如果没有传递的话，它默认的是一个\n换行字符。传递一个空字符将会避免在打印的文本的末尾移动到下一个输入行——下一个print将会保持添加到当前输出行的末尾。
- file指定了文本将要发送到的文件、标准流或者其他类似文件的对象；如果没有传递的话，默认的是sys.stdout。带有一个类似文件的write(string)的方法的任何对象都可以传递，但真正的文件应该已经为了输出而打开。

##打印流重定向##

{% highlight python3 %}
import sys
sys.stdout=open('log.txt','a')
...
print(x,y,z)
{% endhighlight %}

上面的代码就简单的标准输出流重定向到了文本文件中，而且是以追加的模式。其实，甚至可以将sys.stdout重设为非文件对象，只要该对象有预期的协议(write方法)。


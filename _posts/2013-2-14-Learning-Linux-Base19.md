---
layout: post
title: 《鸟哥的Linux私房菜:基础篇》学习笔记——19.软件安装:源码与Tarball
time: 2013-2-14
category: LinuxBase
published: false
---


#开放源码的软件安装与升级简介#

##什么是开放源码、编译程序与可执行文件##

一个文件能不能被执行看的是有没有可执行的权限，不过，**Linux系统上真正识别的可执行文件其实是二进制文件。**
可以使用`file`命令来查看一个文件是不是二进制文件，如果是二进制文件而且是可以执行的时候，它就会显示可执行文件类(ELF 32-bit LSB executable),同时会说明是否使用共享库(shared libs),而如果是一般的script,那它就会显示出text executables 之类的字样。

- 开放源码:就是程序代码，写给人类看的程序语言，但机器并不认识，所以无法执行。
- 编译程序:将程序代码转译成机器看得懂的语言，就类似翻译者的角色。
- 可执行程序:经过编译程序变成二进制程序后机器看得懂所以可以执行的文件。

##什么是函数库##

函数库:类似子程序的角色，可以被调用来执行的一段功能函数

##什么是make与configure##

当执行make时，make会在当前的目录下搜索Makefile(or makefile)这个文本文件，而Makefile里面则记录了源码如何编译的详细信息。make会自动识别源码是否经过了变动而自动更新执行文件，是软件工程师相当好用的一个辅助工具。

make是一个程序，会去找Makefile，那Makefile怎么写呢？通常软件开发商都会写一个检测程序来检测用户的操作环境，以及该操作环境是否有软件开发商需要的其他功能，该检测程序检测完毕后，就会主动新建这个Makefile的规则文件。通常这个检测程序的文件名为configure或者是config。

通常来说，检测程序会检测的数据大约有下面这些:

- 是否是适合的编译程序可以编译本软件的程序代码
- 是否已经存在本软件所需要的函数库或其他需要的相关软件
- 操作系统平台是否适合本软件，包括Linux的内核版本
- 内核的头定义文件(header include)是否存在(驱动程序必须要的检测)

##什么是Tarball的软件##
所谓的Tarball文件，其实就是将软件的所有源码文件先以tar打包，然后再以压缩技术来压缩，通常最常见的就是以gzip来压缩了。因为利用了tar与gzip的功能，所以**tarball文件一般的扩展名就会写成*.tar.gz或者是简写为*.tgz**

所以说，Tarball是一个软件包，你将它解压缩之后，里面的文件通常会有:

- 源代码文件
- 检测程序文件(可能是configure或config等文件名)
- 本软件的简易说明与安装说明(INSTALL或README)

其中最重要的是那个INSTALL或README这两个文件，通常你只要能够参考这两个文件，Tarball软件的安装是很简单的。

##如何安装与升级软件##
 基本上更新的方法可以分为两大类，分别是:

- 直接以源码通过编译来安装与升级
- 直接以编译好的二进制程序来安装与升级

上述第二点中的这个预先编译好程序的机制存在于很多distribution，包括Red Had系统(含Fedora/CentOS系列)开发的RPM软件管理机制与yum在线更新模式;Debian使用的dpkg软件管理机制与APT在线更新模式等。

自己编译一个Tarball软件的基本流程如下所示:

1. 将Tarball由厂商的网页下载下来
2. 将Tarball解压缩，生成很多的源码问价
3. 开始以gcc进行源码的编译(会生成目标文件)
4. 然后以gcc进行函数库、主程序、子程序的链接，以形成主要的二进制文件
5. 将上述的二进制文件以及相关的配置文件安装至自己的主机上面

上面的第3、4步骤当中，可以通过make这个命令的功能来简化它。

##gcc的简易用法##

{% highlight bash %}
 #仅将源码编译成为目标文件，并不制作链接等功能
gcc -c hello.c
 #会自动生成hello.c这个文件，到那时并不会生成可执行文件

 #在编译的时候，依据操作环境给予优化执行速度
gcc -O hello.c -c
 #会自动生成hello.c这个文件，并且进行优化

 #在进行二进制文件制作时，将链接的函数库与相关的路径填入
gcc sin.c -lm -L/usr/lib -I/usr/include
 #这个命令较常执行在最终链接成binary file的时候
 #-lm指的是libm.so或libm.a这个函数库文件
 #-L后面接的路径是刚才上面那个函数库的搜索目录
 #-I后面接的是源码内的include文件所在目录

 #将编译的结果输出成某个特定的文件名
gcc -o hello hello.c
 #-o后面接的是要输出的binary file文件名

 #在编译的时候，输出较多的信息说明
gcc -o hello hello.c -Wall
 #加入-Wall之后，程序的编译会变得较为严谨一点,所以警告信息也会显示出来
{% endhighlight %}

#用make进行宏编译#

##为什么要用make##
make有很多的好处:

- 简化编译时所需要执行的命令
- 若在编译完成之后，修改了某个源码文件，则make仅会针对被修改了的文件进行编译，其他的目标文件不会被更改
- 最后可以依照相互之间的依赖性来更新(update)执行文件

##makefile的基本语法与变量##
make的语法是非常复杂的，这里只是列出一些基本的规则。

基本的makefile规则是这样的:

{% highlight bash %}
目标(target):目标文件1 目标文件2
<tab> gcc -o 欲建立的可执行文件 目标文件1 目标文件2
{% endhighlight %}

那个目标(target)就是我们想要建立的信息，而目标文件就是具有相关性的object files，那建立可执行文件的语法就是以<tab>按键开头的那一行！特别留意的是:**命令行必须要以tab按键作为开头才行**，它的基本规则是这样的:

- 在makefile中#代表批注
- <tab>必须是命令行的第一个字符
- 目标(target)与相关文件(就是目标文件)之间需以":"隔开

关于变量的规则:

1. 变量与变量内容以"="隔开，同时两边可以具有空格
2. 变量左边不可以有<tab>
3. 变量与变量内容在"="两边不能具有":"
4. 在习惯上，变量最好以"大写字母"为主
5. 运用变量时，以${变量}或$(变量)使用
6. 在该shell的环境变量是可以被套用的
7. 在命令行模式也可以定义变量

环境变量取用的规则:

1. make命令行后加上的环境变量为第一优先
2. makefile里面指定的环境变量第二优先
3. shell原本具有的环境变量第三优先

另外需要说明的是，$@代表目前的目标(target)

#Tarball的管理与建议#

##使用源码管理软件所需要的基础软件##
制作一个二进制文件需要很多的内容，这包括下面这些基础的软件:

- gcc或cc等C语言编译程序(complier)(其实不一定必须是gcc，也可以是其他的编译器，像JAVA、Python等)
- make及autoconfig等软件
- 需要Kernel提供的Library以及相关的Include文件

##Tarball安装的基本步骤##
整个安装的基础操作大多是这样的:

1. 取得源文件:将tarball文件在/usr/local/src目录下解压缩
2. 取得步骤流程:进入新建立的目录下面，去查阅INSTALL与README等相关文件内容(很重要的步骤)
3. 相关属性软件安装:根据INSTALL/README的内容查看并安装好一些相关的软件(非必要)
4. 建立makefile:以自动检测程序(configure或config)检测操作环境，并建立Makefile这个文件
5. 编译:以make这个程序并使用该目录下的Makefile这个参数配置文件，来进行make(编译或其他)的操作
6. 安装:以make这个程序，并以Makefile这个参数配置文件，依据install这个目标(target)的指定来安装到正确的路径

##一般Tarball软件安装的建议事项(如何删除、升级)##
一般来说，最好将自己安装的软件安装在/usr/local下，至于源码(Tarball)则建议放在/usr/local/src下面。在默认情况下，`man`命令会去搜索/usr/local/man里面的说明文件，因此，如果我们将软件安装在/usr/local下的话，那么自然安装完成后，该软件的说明文件就可以被找到了。

以下的四个目录是Linux distribution默认的安装软件的路径(以apache为例):

- /etc/httpd
- /usr/lib
- /usr/bin
- /usr/share/man

软件的内容大致放在etc,lib,bin,man等目录中，分别代表**配置文件**、**函数库**、**可执行文件**、**在线帮助文档**。如果是以tarball来安装的话，如果是放在/usr/local里面，由于/usr/local原本就默认这几个目录，所以你的数据就会被放在:

- usr/local/etc
- usr/local/bin
- usr/local/lib
- usr/local/man

但是如果每个软件都选择在这个默认路径下安装的话，那么所有的软件的文件都将放置在这4个目录当中，因此，如果你都安装在这个目录下的话，那么将来再想升级或删除的话，就会比较难以追查这个文件源。

所以比较好的方案是，在安装的时候选择单独的目录，还是用apache举例子,把apache安装在/usr/local/apache当中，那么你的文件目录将会变成:

- usr/local/apache/etc
- usr/local/apache/bin
- usr/local/apache/lib
- usr/local/apache/man

这样的话，单一软件的目录都在同一个目录之下，那么要移除该软件就简单得多了！


##利用patch更新源码##
假如以tarball的方式安装了某个软件之后，我们想要进行升级怎么办？

其实，我们只要更新相应的源码文件就行了，然后利用make来自动update，这样的话原来写好的makefile就不需要再重新改写或检测了。通常的软件开发商都会给出软件升级之后的patch文件，这是源码的"差异文件"，利用Linux的`patch`命令(前面章节提到过的)就能实现自动比较源码的不同支持，并进行更新。需要注意的是，patch文件只会更新源码文件，所以patch更新之后还需要将软件重新编译。


#函数库管理#
在Linux中，函数库是很重要的一个项目，因为很多的软件之间都会相互使用彼此提供的函数库进行特殊功能的运行。

##动态与静态函数库##
依据函数库被使用的类型分为两大类，分别是静态(Static)与动态(Dynamic)。

- 静态函数库的特色
  - **扩展名**:这类函数库通常扩展名为libxxx.a的类型
  - **编译行为**:这类函数库在编译的时候会直接整合到执行程序当中，利用静态函数库编译成的文件会比较大一些
  - **独立执行的状态**:这类函数库的最大优点就是编译成功的可执行文件可以独立运行，而不需要再向外部要求读取函数库的内容
  - **升级**:虽然可执行文件可以独立运行，但因为函数库是直接整合到可执行文件中，因此若函数库升级时，整个可执行文件必须要重新编译才能将新版的函数库整合到程序当中。也就是说，在升级方面，所有将此函数库纳入的程序都需要重新编译。
- 动态函数库的特色
  - **扩展名**:这类函数库通常扩展名为libxxx.so的类型
  - **编译行为**:动态函数库与静态函数库的编译行为差异很大，与静态函数库被整个捕捉到程序中不同，动态函数库在编译的时候，在程序里面只有一个"指向"(Pointer)的位置而已。当可执行文件要使用到函数库的机制时，程序才会去读取函数库来使用。由于可执行程序中仅具有指向动态函数库所在指标而已，并不包括函数库的内容，所以它的文件会比较小一点。
  - **独立执行的状态**:这类型的函数库所编译出来的程序不恩能够被独立执行，因为当我们使用函数库的机制时，程序才会去读取函数库，所以函数库必须存在才行。而且，函数库的目录也不能改变，否则会影响到很多的软件。
  - **升级**:由于具有指向功能，所以当函数库升级后，可执行文件根本不需要进行重新编译的行为，因为可执行文件会直接指向新的函数库文件(前提是函数库新旧版本的文件名是相同的)
  

目前Linux distribution比较倾向于使用动态函数库，如果使用太多静态函数库的话，那么升级某一个函数库时，会对整个系统造成很大的冲击。

另外，绝大多数的函数库都放置在/usr/lib、lib目录下，此外，Linux系统里面很多的函数库其实kernel就提供了，就在/lib/modules里面

##ldconfig与/etc/ld.so.conf##
由于很多软件都会调用系统上的动态函数库，所以自然就想到有没有办法可以增加函数库的读取性能呢？我们可以将常用的动态函数库加载到内存(缓存，cache)中，增加函数库的读取速度。这时就需要ldconfig和/etc/ld.so.conf的协助了。

1. 首先，在/etc/ld.ld.conf里面写入想要读入高速缓存中的动态函数库所在的目录，注意，是目录而不是文件
2. 利用ldconfig这个可执行文件将/etc/ld.ld.conf的数据读入到缓存当中
3. 同时也将数据记录一份到/etc/ld.so.cache这个文件中


##程序的动态函数库解析:ldd##
我们可以利用`ldd`命令来查看可执行文件含有什么动态函数库:

{% highlight bash %}
ldd /usr/bin/passwd
{% endhighlight %}

上面的命令就能显示出/etc/bin/passwd这程序含有的动态函数库有哪些。

#总结#

- 在编译过程中，可以通过其他软件提供的函数库来使用该软件的相关机制与功能。
- 为了简化编译过程中的复杂的指令输入，可以通过make与makefile规则定义来简化程序的更新、编译与链接等操作
- Tarball是使用tar与gzip/bzip2压缩功能所打包与压缩的具有源码的文件
- 函数库有动态函数库与静态函数库之分，动态函数库在升级上具有较佳的优势。动态函数库的扩展名为*.so，而静态函数库则是*.a
- patch的主要功能是更新源码，所以更新源码之后，还需要进行重新编译的操作
- 可以利用ldconfig与/etc/ld.so.conf来制作动态函数库的链接与缓存


---
layout: post
title: 《鸟哥的Linux私房菜:基础篇》学习笔记——15.程序管理与SELinux初探
time: 2013-2-14
category: LinuxBase
published: false
---


#什么是进程(process)#

在Linux中，触发任何一个事件时，系统都会将它定义成为一个进程，并且给予这个进程一个ID，成为PID,同时依据触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设置

##进程与程序(process & program)##

由当前进程衍生出来的其他进程在一般状态下，也会沿用这个进程的相关权限
**总结**
程序(program):通常二进制程序放置在存储媒介中，以物理文件的形式存在
进程(process):程序被触发之后，执行者的权限与属性、程序的程序代码与所需要数据等会被加载到内存中，操作系统并给予这个内存内的单元的一个标示符(PID),可以说，进程就是一个正在运行中的程序。

**fork and exec:过程调用的流程**
进程之间的相互调用，在Linux中通常称为fork-and-exec的流程。进程会通过父进程以复制(fork)的方式产产生一个一模一样的子进程，然后被复制出来的子进程再以exec的方式来执行实际要进行的进程，最终就成为一个子进程的存在。
系统先以fork的方式复制一个与父进程相同的暂存进程，这个进程与父进程唯一的区别就是PID不同，但是这个暂存进程还会多一个PPID的参数，PPID就是父进程的进程标示符。

**系统或网络服务:常驻在内存的进程**
常驻进程被我们成为服务(daemon),系统的服务非常多，大致分为系统本身需要的服务，还有一些负责网络联机的服务。

#工作管理(job control)#

##什么是工作管理##

在进行工作管理的行为中，其实每个工作都是目前bash的子进程，即彼此之间是有相关性的。我们无法以job control的方式由tty1的环境去管理tty2的bash

出现提示符让你的操作的环境成为前台(foreground)，至于其他工作就可以让你放入后台(background)去暂停或运行。要注意的是，放入后台的工作想要运行时，它必须不能够与用户互动。举例来说，vim绝对不可能在后台里面执行(running)，而且放入后台的工作不可以使用[ctrl]+c来终止的

要进行bash的job control必须要注意到的限制是:
- 这些工作所触发的进程必须来自于你shell的子进程
- 前台:你可以控制欲执行命令的这个环境称为前台(foreground)的工作
- 后台:可以运行的工作，无法使用[ctrl]+c终止它，可以使用bg/fg调用该工作
- 后台中的程序分为"暂停"(stop)与"运行中"(running)
- 后台中"执行"的进程不能等待terminal/shell的输入(input)

##job control管理##

**直接将命令丢到后台中"执行"的&**
在需要执行的命令后面加上一个"&"就代表说这个命令丢到后台中去执行，此时bash会给予这个命令一个"工作号码"(job number),同时每个工作都会搭配一个PID，因为每一个工作都是一个进程。将工作放到后台去最大的好处就是不怕被[ctrl]+c中断，此外，将工作丢到后台当中要特别注意数据流的重定向，如果没有重定向的话，错误信息都会直接输出到屏幕上，影响前台的工作。

**将目前工作丢到后台中"暂停":[ctrl]-z**
默认情况下，使用[ctrl]-z丢到后台当中的工作都是"暂停"的状态

**查看目前的后台工作状态:jobs**
利用`jobs`命令可以查看目前有多少工作是在后台中的，输出结果中的"+"号表示默认取用的工作
其实+代表最近被放到后台的工作号码，-代表最近最后第二个被放置到后台中的工作号码，而超过最后第三个以后的工作，就不会有+/-符号存在了

**将后台工作拿到前台来处理:fg**

{% highlight bash %}
fg %jobnumber
{% endhighlight %}
jobnumber表示工作号码

**让工作在后台下的状态变成运行中:bg**

用法与`fg`相同，只是是放在后台中运行


**管理后台当中的工作:kill**

{% highlight bash %}
kill -signal %jobnumber
{% endhighlight %}

通过`kill`命令可以给后台中执行的工作发送一个信号(signal),信号有很多种类，需要特别注意的是,-9通常是在强制删除一个不正常的工作时所使用的，-15则是以正常步骤结束一项工作(15也是默认值)，-1则是重新读一次配置文件(类似于reload)

另外需要注意的是，`kill`后面接的数字默认是PID，如果想要管理bash的工作控制，就得要加上%数字了

##脱机管理问题##

需要注意的是，我们在工作管理当中提到的"后台"指的是在终端机模式下可以避免[ctrl]-c中断的一个情境，并不是放到系统的后台去。所以，工作管理的后台依旧与终端机有关。在这样的情况下，如果是以远程连接的方式连接到你的Linux主机，并且将工作以&的方式放到后台去，在工作尚未结束时就脱机了，这个工作也会被中断掉，并不会继续执行
为了避免上述的情况，可以使用`nohup`命令:

{% highlight bash %}
nohup [命令与参数]			#在终端机前台中工作
nohup [命令与参数] &		#在终端机后台中工作
{% endhighlight %}

需要注意的是，`nohup`并不支持bash内置的命令，因此你的命令必须要是外部命令才行，即把命令写入一个脚本文件中，然后用`nohup`去调用这个脚本

#进程管理#

##进程的查看##

**ps:将某个时间点的进程运行情况选取下来**

{% highlight bash %}
ps aux					#查看系统所有进程数据
ps -lA					#也是能够查看所有系统的数据
ps axjf					#连同部分进程数状态
{% endhighlight %}

**仅查看自己的bash相关的进程:ps -l**

|-----+-----+-----+---------+---------+-----+------+-----+-----+--------+--------+----------+------------+--------|
|  F  |  S  |  UID|  PID    |  PPID   |  C  |  PRI | NI  | ADDR|  SZ    |  WCHAN |  TTY     |  TIME      |  CMD   | 
|:---:|:---:|:---:|:-------:|:-------:|:---:|:----:|:---:|:---:|:------:|:------:|:--------:|:----------:|:------:|
|  4  |  S  |  0  |  13639  |  13637  |  0  |  75  |  0  |  -  |  1287  |  wait  |  pts/1   |  00:00:00  |  bash  |
|  4  |  R  |  0  |  13700  |  13639  |  0  |  77  |  0  |  -  |  1101  |  -     |  pts/1   |  00:00:00  |  ps    |
|-----+-----+-----+---------+---------+-----+------+-----+-----+--------+--------+----------+------------+--------|
说明如下:
- F:代表这个进程标志(precess flags)，说明这个进程的权限，常见的号码有:
		- 若为4，则表示权限为root
		- 若为1，则表示此子进程仅可进行复制(fork)而无法实际执行(exec)
- S:代表这个进程的状态(STAT),主要的状态有:
		- R(Running):该进程正在运行中
		- S(Sleep):该进程目前正在睡眠状态(idle),但可以被唤醒(signal)
		- D:不可被唤醒的状态，通常这个进程可能在等待I/O的情况(ex>打印)
		- T:停滞状态(stop),可能是工作控制(后台暂停)或除错(traced)状态
		- Z(Zombie):"僵尸"状态,进程已经终止但却无法被删除至内存外
- UID/PID/PPID:代表此进程被该UID所拥有/进程的PID号码/此进程的父进程PID号码。
- C:代表CPU使用率，单位为百分比
- PRI/NI:Priority/Nice的缩写，代表此进程被CPU所执行的优先级，数值越小代表该进程越快被CPU执行。
- ADDR/SZ/WCHAN:都与内存有关，ADDR是kernel function,指出该进程在内存的哪个部分，如果是running的进程，一般就会显示"-"。SZ代表此进程用掉多少内存。WCHAN表示目前进程是否运行中，同样，若为-表示正在进行中
- TTY:登陆者的终端机位置，若为远程登录则使用动态终端接口(pts/n)
- TIME:使用掉的CPU时间，注意，是此进程实际花费CPU运行的时间，而不是系统时间。
- CMD:就是command的缩写，造成此程序的触发进程的命令为何

**查看系统所有进程:ps aux**

|--------+-------+--------+--------+-------+-------+-------+--------+---------+--------+-----------|
|  USER  |  PID  |  %CPU  |  %MEM  |  VSZ  |  RSS  |  TTY  |  STAT  |  START  |  TIME  |  COMMAND  |
|:------:|:-----:|:------:|:------:|:-----:|:-----:|:-----:|:------:|:-------:|:------:|:---------:|
|  root  |  1    |  0.0   |  0.0   |  2046 |  616  |  ?    |  Ss    |  09:48  |  0:01  |  init     |
|--------+-------+--------+--------+-------+-------+-------+--------+---------+--------+-----------|

`ps -l`和`ps aux`显示的项目并不相同，各字段意义如下:
- USER:该进程属于哪个用户账号的。
- PID:该进程的进程标示符
- %CPU:该进程使用掉的CPU资源百分比
- %MEN:该进程所占用的物理内存百分比
- VSZ:该进程使用掉的虚拟内存量(KB)
- RSS:该进程占用的固定的内存量(KB)
- TTY:该进程是在哪个终端机上面运行，若与终端机无关，则显示?另外,tty1~tty6是本机上面的登陆者程序，若为pts/0等的，则表示为由网络连接进主机的进程
- STAT:该进程目前的状态，状态显示与ps -l的S标识相同(R/S/T/Z)
- START:该进程被触发启动的时间
- TIME:该进程实际使用CPU运行的时间
- COMMAND:该进程的实际命令

**僵尸进程**
通常，造成僵尸进程的成因是因为该进程应该已经执行完毕，或者是因故应该要终止了，但是该进程的父进程却无法完整将该进程结束掉，而造成一直存在内存当中。如果你发现在某个进程的CMD后面还接上了<defunct>时，就代表该进程是僵尸进程。

**top:动态查看进程的变化**
相对于ps是选取一个时间点的进程状态，top则可以持续检测进程运行的状态,top默认是每隔5s更新一次进程资源，可以使用-d来进行修改。top主要分为两个界面，上面的界面为整个系统的资源使用状态，基本上总共有六行，显示的内容依序是:
- 第一行(top...): 
		- 目前的开机时间
		- 开机到目前为止所经过的时间
		- 已经登录的用户人数
		- 系统在1,5,15分钟的平均工作负载，越小代表系统越闲置，若高于1得要注意你的系统压力是否太过繁复了。
- 第二行(Tasks...):显示的目前进程总数与个别进程在什么状态(running,sleeping,stopped,zombie)。比较需要注意的是最后的zombie那个数值，如果不是0的，那就需要查看哪个进程变成了僵尸
- 第三行(Cpus...):显示的是CPU的整体负载，每个选项可用?查询。需要特别注意的是%wa,那个选项代表的是I/Owait，通常你的系统会变慢都是I/O产生的问题比较大！
- 第四行与第五行:表示目前物理内存与虚拟内存(Mem/Swap)的使用情况。
- 第六行:这个是当在top进程当中输入命令时显示状态的地方

至于top下半部分的界面，则是每个进程使用的资源情况，比较需要注意的是：
- PID:每个进程的ID
- USER:该进程所属的用户
- PR:Priority的简写，进程的优先执行顺序，越小越早被执行
- NI:Nice的简写，与Priority有关，也是越小越早被执行
- %CPU:CPU的使用率 - %MEM:内存的使用率
- TIME+:CPU使用时间的累加

top默认使用CPU使用率作为排序的重点，如果你想要使用内存使用率排序，则可以按下"M",若要恢复则按下"P"即可

**pstree**
通过`pstree`可以查看进程之间的相关性，所有进程都是依附在init这个进程下面的，它的进程号是1，因为它是由Linux内核主动调用的第一个进程

##进程的管理##

通过给予进程一个信号(signal)，就可以方便的管理进程。可以使用`kill -l`查看所有的信号(signal)
主要的信号与名称及内容如下表所示:

|--------+-----------+---------------------------------------------------------------------------|
|  代号  |   名称    |   内容                                                                    |
|:------:|:---------:|:--------------------------------------------------------------------------|
|  1     |  SIGHUP   |   启动被终止的进程，可让该PID重新读取自己的配置文件，类似于重新启动       |
|  2     |  SIGINT   |   相当于用键盘[ctrl]-c来中断一个进程的进行                                |
|  9     |  SIGKILL  |   代表强制中断一个进程的进行，如果该进程进行到一半，那么尚未完成的部分可能会有"半成品"产生，类似vim会有filename.swap保留下来    |
|  15    |  SIGTERM  |   以正常的结束进程来终止该进程。由于是正常的终止，所以后续的操作会将它完成。不过，如果该进程已经发生问题，就是无法用正常的方法终止时，输入这个signal也是没用的  |
|  17    |  SIGSTOP  |   相当于用键盘[ctrl]-z来暂停一个进程的执行                                |
|--------+-----------+---------------------------------------------------------------------------|

**kill -siganl PID**
kill可以帮我们将信号传送给某个工作(%jobnumber)或者是某个PID(直接输入数字)，这个需要强调的是:**kill后面直接加数字与加上%number的情况是不同的** 
使用kill命令也可以将某个莫名其妙的登陆者的连接删除，先通过`pstree -p`找到相关进程，然后再以`kill -9`将该进程删除，该连接就会被踢掉了！

**killall -signal**
`killall`可以通过"执行命令的名称"来给予信号

{% highlight bash %}
killall -9 httpd			#强制删除所有以httpd启动的进程
{% endhighlight %}

##关于进程的执行顺序##

**Priority与Nice值**
Linux给予进程一个所谓的"优先执行序"(priority,PRI),这个PRI值越低代表越优先的意思。不过这个PRI值是由内核动态调整的，用户无法直接调整PRI的值
由于PRI是内核动态调整的，用户无法干涉。如果想要调整进程的优先执行顺序时，就得要通过Nice值了，PRI与NI的相关性如下:
`PRI(new) = PRI(old) + nice`
虽然nice值是可以影响PRI，不过，最终的PRI仍是要经过系统分析后才会决定的。当nice值为负值时，那么该程序就会降低PRI值，即会变得较优先被处理。
另外需要注意的是:
- nice值可调整的范围是-20~19
- root可随意调整自己或他人进程的Nice值，且范围为-20~19
- 一般用户仅可调整自己进程的nice值，且范围仅为0~19(避免一般用户抢占系统资源：)
- 一般用户仅可将nice值越调越高
- nice值是可以在父进程与子进程之间传递

**nice:新执行的命令即给予新的nice值**

{% highlight bash %}
nice [-n 数字]  command
 #用root给一个nice值为-5,用于执行vi
nice -n -5 vi &
{% endhighlight %}

**nice:已存在进程的nice重新调整**
如果要调整的是已经存在的某个进程的话，那么就要使用renice了。

{% highlight bash %}
renice [number] PID
{% endhighlight %}

##系统资源的查看##

**free:查看内存使用情况**
通常来说，系统会很有效率的把所有内存都用光，内存被用光是正常的，相反需要注意的是swap容量，一般来说，swap最好不要被使用，尤其swap最好不要被使用超过20%以上，如果发现超过20%，那最好更换物理内存了。

**uname:查看系统与内核相关信息**
这个命令可以列出目前系统的内很版本、主要硬件平台以及CPU类型等信息

**uptime:查看系统启动时间与工作负载**
显示目前系统已经开机多久的时间，以及1,5,15分钟的平均负载。

**netstat:跟踪网络**
基本上，`ntstat`的输出分为两大部分，分别是网络与系统自己的进程相关性部分
先看网络部分:
- Proto:网络的数据包协议，主要分为TCP与UDP数据包
- Recv-Q:非由用户进程连接到此socket的复制的总字节数
- Send-Q:非由远程主机传送过来的acknowledged的总字节数
- LocalAddress:本地的IP端口情况
- ForeignAddress:远程主机的IP端口情况
- State:连接状态，主要有建立(ESTABLISED)及监听(LISTEN)

socket进程部分:
- Protr:一般就是Unix
- RefCnt:连接到此socket的进程数量
- Flags:连接的标识
- Type:socket访问类型。主要确认连接的STREAM与不需要确认的DGRAM两种
- State:若为CONNECTED表示多个进程之间已经建立连接
- Path:连接到此socket的相关程序的路径，或者是相关数据输出的路径

**dmesg:分析内核产生的信息**
系统在开机的时候，内核会去检测系统的硬件，某些硬件到底有没有被识别出来，那就与这个时候的检测有关。通过`dmesg`就能显示出这些系统检测信息

**vmstat:检测系统资源变化**
如果想要动态了解系统资源的运行，那么就可以使用`vmstat`这个命令
输出信息的各个字段的说明如下:
进程字段(procs)的选项分别为:
- r:等待运行中的进程数量
- b:不可被唤醒的进程数量，这两个选项越多，代表系统越忙碌
内存字段(memory)的选项分别为:
- swpd:虚拟内存被使用的容量
- free:未被使用的内存容量
- buff:用于缓冲存储器
- cache:用于高速缓存
内存交换空间(swap)的选项分别为:
- si:由磁盘中将程序取出的量
- so:由于内存不足而将没用到的程序写入到磁盘的swap容量。如果si/so的数值太大，表示内存的数据经常得在磁盘与内存之间传来传去，系统性能会很差
- 磁盘读写(io)的选项分别为:
- bi:由磁盘写入的块数量
- bo:写入到磁盘去的块数量。如果这部分的值越高，代表系统的I/O非常忙碌
系统(system)的项目分别为:
- in:每秒钟被中断的进程次数
- cs:每秒钟进行的事件切换次数。这两个数值越大，代表系统与接口设备的通信非常频繁。这些接口设备包括磁盘、网卡、时钟等
CPU的选项分别为:
- us:非内核层的CPU使用状态
- sy:内核层所使用的CPU状态
- id:闲置的状态
- wa:等待I/O所耗费的CPU状态
- st:被虚拟机(virtual machine)所盗用的CPU使用状态

#特殊文件与程序#

##具有SUID/SGID权限的命令执行状态##

SUID的程序被一般用户执行的过程:
- SUID权限仅对二进制程序(binary program)有效
- 执行者对于该程序需要具有x的可执行权限
- 本权限仅在执行该程序的过程中有效(run-time)
- 执行者具有该程序所有(owner)的权限

当一般用户触发一个具有SUID权限的程序时，会取得一个新的进程与PID，该PID产生时通过SUID来给予该PID特殊的权限设置。

## /proc/*代表的意义##

我们之前提到的所谓的进程都是在内存当中的，而内存当中的数据又都是写入到/proc/*这个目录下的，所以，我们可以直接查看/proc这个目录当中的文件
基本上，目前主机上面的各个进程的PID都是以目录的类型存在于/proc当中,每个进程的目录中，包含了各自的各种数据

##查询已打开文件或已执行程序打开的文件##

**fuser:通过文件(或文件系统)找出正在使用该文件的程序**
输出结果中的Access的选项代表的意义为:
- c:此进程在当前目录下(非子目录)
- e:可被触发为执行状态
- f:是一个被打开的文件
- F:该文件被打开了，不过在等待回应中
- m:可能为分享的动态函数库

**lsof:列出被进程所打开的文件名**
相对于`fuser`反过来的操作就是`lsof`，`lsof`能够查出某个进程打开或者使用的文件与设备

**pidof:找出某个正在执行的进程的PID**
这个`pidof`命令配合上`ps aux`与正则表达式，就可以很轻易地找到你所想要的程序内容了

#SELinux初探#

##什么是SELinux##

SELinux:Security Enhanced Linux,字面上意义就是**安全强化的Linux**

> 这部分内容比较多，而且暂时没有什么实际用途，所以放在以后再学习这部分内容


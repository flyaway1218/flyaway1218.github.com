---
title: Python学习——Learning Python
time: 2013-1-25
type: Note
error:P134 最后关于int函数第二个参数的解释，估计是翻译错误
---


#Python如何运行程序#

##Python解释器简介##

Python不仅是一门编程语言，也是一个名为解释器的软件包。解释器是一种让其他程序运行起来的程序。实际上，解释器是代码与机器的计算机硬件之间的软件逻辑层
在UNIX/Linux上，Python通常是安装在/usr目录下的

##程序执行##

###程序员的视角###

Python程序的源代码通常是以.py来命名的，当你将代码保存为一个文本文件之后，你必须告诉Python解释器去执行这个文件。

###Python的视角###

当Python运行脚本时，在代码开始进行处理之前，Python还会执行一些步骤。确切地说，第一步是编译成所谓的"字节码",之后将其转发到所谓的"虚拟机"中.

**字节码编译**
编译是一个简单的翻译步骤，而且字节码是源代码底层的、与平台无关的表现形式。概括地说，Python通过把每一条源语句分解为单一步骤来将这些源语句翻译成一组字节码指令，这些字节码可以提高执行速度。
编译好的字节码文件将会被Python自动保存为.pyc文件。

**Python虚拟机(PVM)**
一旦程序编译成字节码，之后的字节码发送到通常称为Python虚拟机(Python Virtual Machine,PVM)上来执行，实际上它不是一个独立的程序，不需要安装。事实上，PVM就是迭代运行字节码指令的一个大循环，一个接一个地完成操作。PVM是Python的运行引擎，它时常表现为Python系统的一部分，并且它是实际运行脚本的组件。从技术上讲，它才是所谓"Python解释器"的最后一步。

##Python实现的替代者##

- CPython
	原始的标准的Python实现方式，它运行的速度最快、最完整而且也是最健全的。它可以脚本化C和C++组件
- JPython
	JPython是一种Python语言的替代实现方式，其目的是为了与Java编程语言集成。
- IronPython
	Python的第三种实现方式是IronPython(比CPython和JPython都要新)，其设计目的是让Python程序可以与Windows平台上的.NET框架以及与之对应的Linux上开源的Mono编写的应用相集成

#介绍Python对象类型#

Python程序可以分解成模块、语句、表达式以及对象:
1. 程序又模块构成
2. 模块包含语句
3. 语句包含表达式
4. 表达式建立并处理对象

##为什么使用内置类型##

- 内置对象使程序更容易编写
- 内置对象时扩展的组件
- 内置对象往往比定制的数据结构更有效率
- 内置对象是语言标准的一部分

###Python的核心数据类型###

在Python程序中处理的每一样东西都是一种对象，内置对象如下表所示:

|--------------------+----------------------------------------|
|  对象类型          |  例子 常量/创建                        |
|:------------------:|:---------------------------------------|
|  数字  		  		   |  1234,3.1415,3+4j,Deciaml,Fraction     |
|  字符串            |  'spam',"guido's",b'a\xolc'            |
|  列表							 |  [1,[2,'three'],4]                     |
|  字典              |  {'food':'spam','taste':'yum'}         |
|  元组              |  (1,'spam',4,'U')                      |
|  文件              |  myfile = open('egg','r')              |
|  集合              |  set('abc'),{'a','b','c'}              |
|  其他类型          |  类型、None、布尔型                    |
|  编程单元类型      |  函数、模块、类                        |
|  与实现相关的类型  |  编译的代码堆栈跟踪                    |
|--------------------+----------------------------------------|

像函数、模块和类这样的编程单元在Python中也是对象，它们由def、class、import和lamdba这样的语句和表达式创建，并且可以在脚本间自由地传递，存储在其他对象中等

Python中没有类型声明，运行的表达式的语法决定了创建和使用的对象的类型。一旦创建了一个对象，它就和操作集合绑定了，例如只能对字符串进行字符串相关的操作。

Python是动态类型的(它自动跟踪你的类型而不是要求声明代码)，但是他也是强类型语言(你只能对一个对象进行适合该类型的有效操作)

##数字##

Python中的数字支持一般的数学运算，包括加法(+),乘法(*),除法(/),整除(//),取模(%),乘方(**)

##字符串##

从严格意义上说，字符串是单个字符的字符串的序列，其他类型的序列还包括列表和元组

###序列的操作###

**索引**
作为序列，字符串支持针对各个元素位置顺序的操作。在Python中，索引是从0开始的，但是我们也可以反向索引，从最后一个开始，-1代表最后一个元素，-2代表倒数第二个元素，以此类推。比较好的记忆方法是:负的索引号简单地与字符串长度相加，就得到了正向的索引号

**分片**
除了简单的从位置进行索引，序列也支持一种分片(slice)操作，这是一种一步就能够提取整个分片(slice)的方法:

{% highlight python %}
S = 'Spam'
S[1:3]
{% endhighlight %}

它们的一般形式为X[I:J],表示"取出在X中从偏移量为I，直到但不包括偏移量为J的内容"，结果就是返回一个新的对象
在一个分片中，左边界默认为0，并且右边界默认为分片序列的长度

**合并**

作为一个序列，字符串也支持使用加号进行合并(将两个字符串合并成为一个新的字符串)

###不可变性###

字符串在Python具有不可变性，**也就是说在创建后不能就地改变**，但是你总是可以通过建立一个新的字符串并以同一个变量名对其进行赋值，因为Python在运行过程中会清理旧对象

{% highlight python %}
S = 'Spam'
S = 'z' + S[1:]
print(S)
{% endhighlight %}

在Python中，每一个对象都可以分为不可变性或可变性，在核心类型中，数字、字符串和元组是不可变的，列表和字典是可变的

###类型特定的方法###

到目前为止讲到的操作都是Python中序列对象共有的，包括列表和元组。字符串也有一些自己特殊的方法。
**find**
字符串的find方法是一个基本的子字符串查找的操作(它将返回一个传入子字符串的偏移量，或者没有找到的情况下返回-1)
**replace**
replace方法将会对全局进行搜索和替换

这些字符串的方法都不会改变原来的字符串，只是会生成一个新的字符串对象作为返回对象

注意:尽管序列操作是通用的，但方法不通用(虽然某些类型共享某些方法名)。一条简明的法则是这样的:**可作用于多种类型的通用型操作都是以内置函数或表达式的形式出现的[例如,len(X),X[0]]，但是类型特定的操作是以方法调用的形式出现的[例如,aString.find('x')]**

###寻求帮助###

想要查看对象详细的方法，可以调用内置的`dir`函数，它将返回一个列表，其中包含了对象的所有属性。(对象属性包括方法)
`dir`函数简单地给出了方法的名称，要查询它们是做什么的，你可以将其传递给`help`函数

{% highlight Python %}
S = 'Spam'
dir(S)
help(S.replace)
{% endhighlight %}

###编写字符串的其他方法###

在Python中，反斜线转义序列表示特殊的字符，Python允许字符串包括在单引号或双引号中(它们代表着相同的东西)
Python也支持原始(raw)字符串常量，即去掉反斜线转义机制

###模式匹配###

Python的字符串对象能够支持基于模式的文本处理，详细的内容后面介绍

##列表##

Python的列表对象是这个语言提供的最通用的序列。列表是一个任意类型的对象的位置相关的有序集合，它没有固定的大小。

###序列操作###

由于列表是序列的一种，列表支持之前提到的所有序列操作。
包括索引、切片等操作

###类型特定的操作###

Python的列表与其他语言中的数组有些类似，但要强大得多。其中一个方面就是，列表没有固定类型的约束，一个列表中的元素可以是各种不同的类型，其次列表是没有固定大小的，它能够按照需要自己增加或减少列表大小

- append:扩充列表的大小并在列表的尾部插入一项
- pop:移除给定偏移量的一项，从而让列表减小
- insert:在任意位置插入元素
- remove:按照值移除元素

需要注意的是，大多数列表的方法都会就地改变列表对象，而不是创建一个新的列表

###边界检查###

尽管列表没有固定的大小，Python仍不允许引用不存在的元素，超出列表末尾之外的索引总是会导致错误

###嵌套###

Python核心数据类型的一个优秀的特性就是它们支持任意的嵌套，能够以任意的组合对其进行嵌套，并可以多个层次进行嵌套。

##字典##

Python中的字典是完全不同的东西:它们不是序列，而是一种映射(mapping)。映射是一个其他对象的集合，但是它们是通过键而不是相对位置来存储的。实际上，映射并没有任何可靠的从左至右的顺序。它们简单地讲键映射到值。字典是Python核心对象集合中的唯一的一种映射类型，也具有可变性——可以就地改变，并可以随需求增大或减少，就像列表那样

###映射操作###

作为常量编写时，字典编写在大括号中，并包含一系列的"键:值"对。通过键索引一个字典往往是Python中编写搜索的最快方法
字典的索引操作使用的是和序列相同的语法，但是在方括号中的元素是键，而不是相对位置

{% highlight python %}
D={}
D['name']='Bob'
D['job']='dev'
D['age']=40
{% endhighlight %}

###重访嵌套###

{% highlight python %}
rec = {'name':{'first':'Bob','last':'Smith'},
			 'job':['dev','mgr'],
			 'age':40.5 }
{% endhighlight %}

如上面代码所示，Python的核心数据类型是非常灵活的，可以轻松的建立复杂的信息结构。

###键的排序:for循环###

之前说过，字典中是没有顺序的，全部都是以键来进行索引的，但是，如果确实需要强调顺序的时候，可以这样做:

{% highlight python %}
D={'a':1,'b':2,'c':3}
for key in sorted(D):
		print(key,'=>',D[k])
{% endhighlight %}

sorted是内置函数，sorted调用返回结果并对各种对象类型进行排序

###不存在的键:if测试###

尽管我们能够通过给新的键赋值来扩展字典，但是获取一个不存在的键仍然是一个错误.可以利用in和if进行判断:

{% highlight python %}
D={'a':1,'b':2,'c':3}
if not 'f' in D:
		print('missing')
{% endhighlight %}

##元组##

元组基本上就像一个不可以改变的列表，就像列表一样，元组是序列，但是它具有不可变性，和字符串类似。从语法上讲，它们编写在圆括号中而不是方括号中，他们支持任意类型、任意嵌套以及常见的序列操作

元组还有两个专有的可调用方法:
- index:返回元素的偏移值
- count:返回元素在元组中出现的次数

###为什么要用元组###

元组在实际应用并不如列表那么常用，但是它的关键在于不可变性。如果在程序中以列表的形式传递一个对象的集合，它可能在任何地方改变，如果使用元组的话，就不能。也就是说，元组提供了一种完整性约束，这对于我们这里所编写的更大型的程序来说是方便的。

##文件##

文件对象是Python代码对计算机上外部文件的主要接口。虽然文件时核心类型，但是它有些特殊:没有特定的常量语法来创建文件。要创建一个文件对象，需要调用内置的open函数以字符串的形式传递给它一个外部的文件名以及一个处理模式的字符串。

{% highlight python %}
f = open('data.txt','w')
f.write('Hello\n')
f.write('World\n')
{% endhighlight %}

##总结##

Python中的核心对象有:数字、字符串、列表、字典、元组、文件和集合
其中，数字、字符串和元组具有不可变性
字符串、元组、列表是属于序列的，是有顺序的
字典不属于序列，它是没有顺序的
Python中的关键思想之一:**不要把代码限制在特定的类型上，使代码自动适用于多种类型**


#数字#

##Python的数字类型##

Python数字类型的完整工具包括:
- 整数和浮点数
- 复数
- 固定精度的十进制数
- 有理分数
- 集合
- 布尔类型
- 无穷的整数精度
- 各种数字内置函数和模块

###数字常量###

基本数字常量:

|-----------------------------------+-----------------------------------------------|
|  数字                             |   常量                                        |
|:----------------------------------|:----------------------------------------------|
|  1234,-24,0,99999999999           |   整数(无穷大小)															|
|  1.23,1.,3.14e-10,4E210,4.0e+210  |   浮点数                                      |
|  0177,0x9ff,0b101010              |   Python2.6中的八进制、十六进制、二进制常量   |
|  0o177,0x9ff,0b101010						  |   Python3.0中的八进制、十六进制、二进制常量   |
|  3+4j,3.0+4.0j,3j                 |   复数常量                                    |
|-----------------------------------+-----------------------------------------------|

###内置数学工具和扩展###

除了上述表格中的内置数字常量之外，Python还提供了一系列处理数字对象的工具:

**表达式操作符**
+,-,*,/,>>,**,&等

**内置数学函数**
pow,abs,round,int,hex,bin等

**公用模块**
random,math等

###Python表达式操作符###

Python表达式操作符及程序


|------------------------------+------------------------------------------------|
|  操作符                      |   描述                                         |
|:----------------------------:|:-----------------------------------------------|
|  yield x                     |  生成器函数发送协议                            |
|  lamdba args:expression      |  生成匿名函数                                  |
|  x if y else z               |  三元选择表达式                                |
|  x or y                      |  逻辑或(只有x为假，才会计算y)                  |
|  x and y                     |  逻辑与(只有x为真,才会计算y)                   |
|  not x                       |  逻辑非                                        |
|  x in y,x not in y           |  成员关系(可迭代对象、集合)                    |
|  x is y,x is not y           |  对象实体测试                                  |
|  x<y,x<=y,x>y,x>=y,x==y,x!=y |  大小比较，集合子集和超集相等性操作符          |
|  x | y                       |  位或,集合并集                                 |
|  x ^ y                       |  位异或，集合对称差                            |
|  x & y                       |  位与,集合交集                                 |
|  x << y,x >> y               |  左移或右移y位                                 |
|  x + y,x -y                  |  加法/合并,减法,集合差集                       |
|  x * y,x % y,x / y,x // y    |  乘法/重复,余数/格式化,除法:整除法或floor除法  |
|  -x,+x                       |  一元减法，识别                                |
|  ~x                          |  按位求补(取反)                                |
|  x ** y                      |  幂运算                                        |
|  x[i]                        |  索引(序列、映射及其他)                        |
|  x[i:j:k]                    |  分片                                          |
|  x(...)                      |  调用(函数、方法、类及其他可调用的)            |
|  x.attr                      |  属性引用                                      |
|  (...)                       |  元组，表达式，生成器表达式                    |
|  [...]                       |  列表，列表解析                                |
|  {...}                       |  字典、集合、集合和字典解析                    |
|------------------------------+------------------------------------------------|

**混合操作所遵循的操作优先级**
- 在上表中，表中的操作符越是靠后的优先级越高，因此在混合表达式中要更加小心
- 表中位于同一行的表达式在组合的时候通常从左到右组合

**括号分组的子表达式**
如果用括号将表达式各部分进行分组的话，就可以完全忽略优先级的事情

**混合类型的自动升级**
在混合类型的表达式中，Python首先将被操作的对象转换成其中最复杂的操作对象的类型，然后再对相同类型的的操作对象进行数学运算
Python是这样划分数字类型的复杂度的:整数比浮点数简单，浮点数比复数简单。
另外需要注意的是，这些混合类型转换仅仅在将数字类型混合到一个表达式中的时候才使用

##在实际应用中的数字##

###比较:一般的和连续的###

Python允许把多个比较连续起来执行范围测试，例如:

{% highlight python %}
X = 2
Y = 4
Z = 6
X < Y < Z      #相当于 X < Y and Y < Z
{% endhighlight %}

###除法:传统除法、Floor除法和真除法###

X / Y:
传统除法和真除法。在Python2.x中，这个操作对于整数会省去小数部分，对于浮点数会保持小数部分。在Python3.0中变成了真除法(无论任何类型都会保持小数部分)
X // Y:
Floor除法。这个操作不考虑操作对象的类型，总会省略结果的小数部分，剩下最小的能整除的整数部分.针对整数返回一个整数，如果有任何一个操作数是浮点数，则返回一个浮点数

###十六进制、八进制和二进制计数###

Python提供了很多内置函数进行进制的转换:
oct():将十进制数转换为八进制数
hex():将十进制数转换为十六进制数
bin():将十进制数转换为二进制数

int():将一个数字的字符串变换为一个整数，并且可以通过定义的第二个参数来确定按照哪个进制进行转换

{% highlight python %}
0o1,0o20,0o37             #八进制数
0x01,0x10,0xFF            #十六进制
0b1,0b10000,0b11111111		#二进制数
{% endhighlight %}

###位操作###
Python支持像C语言中那样的位操作

###其他的内置数学工具###

除了核心对象类型外，Python还支持用于数字处理的内置函数和内置模块。例如内置函数pow和abs，分别计算幂和绝对值

{% highlight python %}
import math
math.pi,math.e
math.sin(2*math.pi /180)
math.sqrt(144)
min(3,1,2,4),max(3,1,2,4)
{% endhighlight %}

在Python中有3中方法可以计算平方根:使用一个模块函数、一个表达式或一个内置函数

{% highlight python %}
import math
math.sqrt(144)   #函数模块
144 ** .5				 #表达式
pow(144,.5)      #内置函数
{% endhighlight %}

另外需要注意的是random模块，可以用来产生一个0和1之间的随机数

{% highlight python %}
import random
random.random()
random.randint()
random.choice(['Life of Brian','Holy Grail','Meaning of Life'])
{% endhighlight %}

##其他数字类型##

###小数数字###
Python2.4开始引进了一个新的核心数据对象:小数对象。它比其他数据类型要复杂一些，小数是通过一个导入的模块调用函数后创建的，而不是通过运行常量表达式创建的。从功能上来说，小数对象就像浮点数，只不过它们有固定的位数和小数点，因此小数是有固定的精度的浮点值

{% highlight python %}
0.1+0.1+0.1-0.3
print(0.1+0.1+0.1-0.3)
from decimal import Decimal
Decimal('0.1')+Decimal('0.1')+Decimal('0.1')-Decimal('0.3')
{% endhighlight %}

在上面的代码中，第一和第二行的结果都是5.5511151231257827e-17，因为与硬件相关的浮点数运算在精度方面有内在的缺陷,不过使用小数对象时，就能改正，最后一行的结果是Decimal('0.0')

**设置全局精度**
decimal模块中的其他工具可以用来设置所有小数数值的精度、设置错误处理等

{% highlight python %}
import decimal
decimal.getcontext().prec=4
decimal.Decimal(1) / decimal.Decimal(7)
{% endhighlight %}

以上代码返回的结果是Decimal('0.1429')
这对于处理货币应用程序非常有用

###分数类型###

Python3.0引入了一个新的数字类型——分数，它实现了一个有理数对象。它明确地保留一个分子和一个分母，从而避免了浮点数学的某些不精确性和局限性

{% highlight python %}
from frations import Fraction
x = Fraction(1,3)
y = Fraction(4,6)
{% endhighlight %}

###集合###

这是一些唯一的、不可变的对象的一个无序集合(collection),这些操作支持与数学集合理论相对应的操作。可以把集合看成一个没有键的字典
可以使用如下的方式创建一个集合

{% highlight python %}
x = set('abcde')
y = {'a','b','c','d','e'}
{% endhighlight %}

但是要创建一个空的字典，必须使用内置函数set,因为{}代表的是一个空的字典

**不可变限制和冻结集合**
很大程度上由于其实现，集合只能包含不可变的对象类型。因此，列表和字典不能嵌入到集合中去。但是，如果需要存储复合值的话，元组是可以嵌入的。
集合本身也是不可变的，所以不能直接嵌入到其他集合中，如果需要在另一个集合中存储一个集合，可以像调用set一样来调用frozenset，但是，它创建一个不可变的集合，该集合不可修改并且可以嵌套到其他集合中


###布尔型###
True---------1
False---------0

##数字扩展##

尽管Python的核心数字类型提供的功能对于大多数应用程序已经够用了，还是有大量的第三方开源扩展可以用来解决更加专门的需求。
比如有一个叫做NumPy(Numeric Python)的Python扩展提供了高级的数字编工具，例如矩阵数据类型、向量处理和高级的计算库。像Los Alamos和NASA这样的核心科学编程组织，使用带有NumPy的Python来实现此前用C++、FORTRAN、Matlab编写的任务。Python和NumPy的组合往往可以比作是一款免费的、更加灵活的的Matlab

#动态类型简介#

##缺少类型声明语句的情况##

###变量、对象和引用###
在Python中，变量有如下的几个相关概念:

- 变量创建
	一个变量(也就是变量名)，就像a，当代吗第一次给它赋值时就创建了它。之后的赋值将会改变已创建的变量名的值。
- 变量类型
	变量永远不会有任何的和它关联的类型信息或约束。类型的概念是存在于对象中而不是变量名中。变量原本就是通用的，它只是在一个特定的时间点，简单地引用了一个特定的对象而已
- 变量使用
	当变量出现在表达式中时，它会马上被当前引用的对象所代替，无论这个对象是什么类型。此外，所有的变量必须在其使用前明确地赋值，使用未赋值的变量会产生错误

当执行到:

{% highlight python %}
a = 3
{% endhighlight %}

这样的代码时，从概念上说，Python将会执行三个不同的步骤去完成这个请求。这些步骤反映了Python语言中所有赋值的操作:
1. 创建一个对象来代表值3
2. 创建一个变量a，如果它还没有创建的话
3. 将变量与新的对象3相连接

从上面的三个步骤可以看出，变量和对象保存在内存中的不同部分，并通过连接相关联。变量总是连接到对象，并且绝不会连接到其他变量上，但是更大的对象可能连接到其他的对象。
在Python中从变量到对象的连接称作引用，也就是说，引用是一种关系，以内存中的指针的形式实现。一旦变量被使用，Python自动跟随这个变量到对象的连接

**类型属于对象，而不是变量名**

用具体的术语来讲:
- 变量是一个系统表的元素，拥有指向对象的连接的空间
- 对象是分配的一块内存，有足够的空间去表示它们所代表的值m
- 引用是自动形成的从变量到对象的指针

从技术上讲，一个对象是具有更复杂的结构的，每一个对象都有两个标准的头部信息:
- 一个类型标识符去标识这个对象的类型
- 一个引用的计数器，用来决定是不是可以回收这个对象

###对象的垃圾收集###

在Python中，每当一个变量名被赋予一个新的对象，之前那个对象占用的空间就会被回收(如果它没有被其他的变量名或对象所引用的话)。这种自动回收对象空间的计数就做垃圾收集
在Python内部，Python是这样实现这个功能的:它在每个对象中保持了一个计数器，计数器记录了当前指向该对象的引用的数目。一旦(并精确在同一时间)这个计数器被设置为0，这个对象的内存空间就会自动回收

##共享引用##

{% highlight python %}
a = 3
b = a
{% endhighlight %}

上面代码的实际效果就是变量a和变量b都引用了相同的对象(也就是说，指向了相同的内存)。这在Python中叫做共享引用——多个变量名引用了同一个对象

{% highlight python %}
a = 3
b = a
a = a+2
{% endhighlight %}

上面代码的最终结果就是，a指向数据为5的内存空间，b指向数据为3的内存空间。事实上，是没有办法修改对象3的值的，之前就提到过，整数是不可变的，因此没有办法在远处修改。在Python中，变量总是一个指向对象的指针，而不是可改变的内存区域的标签:给一个变量赋一个新的值，并不是替换了原始的对象，而是让这个变量去引用完全不同的一个对象。实际的效果就是对一个变量赋值，仅仅会影响那个被赋值的变量

###共享引用和在原处修改###

但是事实上有一些对象和操作确实会在原处改变对象(例如列表)。

{% highlight python %}
L1=[2,3,4]
L2=L1
L1=24
{% endhighlight %}

上面代码的结果是，L1指向一个值为24的对象，L2仍是引用最初的列表

{% highlight python %}
L1=[2,3,4]
L2=L1
L1[0]=24
{% endhighlight %}

上面代码的结果是，L1和L2同时引用了值为[24,3,4]的列表
必须意识以上两段代码的不同之处

如果不想发生以上的情况，那就需要Python拷贝对象，而不是创建引用。
有很多方法可以拷贝一个列表，最常用的方法就是从头到尾的分片
但是，分片这种方法是不能应用在其他的可变的核心类型上(字典和集合，因为它们不是序列)，复制一个字典或集合应该使用X.copy()方法调用。在标准库中的copy模块有一个通用的复制任意对象类型的调用:

{% highlight python %}
import copy
X = copy.copy(Y)
X = copy.deepcopy(Y)
{% endhighlight %}

在Python中，可变的对象包括了列表、字典以及一些通过class语句定义的对象

###共享引用和相等###

通常来说，考虑到效率的问题，Python会缓存并复用了小的整数和小的字符串，例如如下的代码:

{% highlight python %}
x = 42
x = 'shrubbery'
{% endhighlight %}

这里的对象42也许并没有被马上回收，而是仍被存在一个系统表中，等待下一次你的代码生成另一个42来重复引用。尽管有这种机制，但是大部分对象都会在不再引用时马上回收。

在Python中有两种"相等":
==操作符:测试两个被引用的对象是否有相同的值
is操作符:检查对象的同一性，就是检查两个变量名是否是指向同一个对象

#字符串#
Python字符串——一个有序的字符的集合
Python的字符串被划分为不可变序列，意味着它们不可以在原处修改
常见的字符串常量和表达式

|-----------------------------+---------------------------------------------|
|    操作                     |       解释                                  |
|:---------------------------:|:--------------------------------------------|
|  s=''                       |    空字符串                                 |
|  s="spam's"                 |    双引号和单引号相同                       |
|  s='s\np\ta\x00m'           |    转义序列                                 |
|  s="""..."""                |    三重引号字符串块                         |
|  s=r'\temp\spam'            |    Raw字符串                                |
|  s=b'spam'                  |    Python3.0中的字节字符串                  |
|  s=u'spam'                  |    仅在Python2.6中使用的Unicode字符串       |
|  s1+s2                      |    合并                                     |
|  s * 3                      |    重复                                     |
|  s[i]                       |    索引                                     |
|  s[i:j]                     |    分片                                     |
|  len(s)                     |    长度                                     |
|  "a %s parrot" % kind       |    字符串格式化表达式                       |
|  "a {0} parrot".format(kind)|    Python2.6和Python3.0中的字符串格式化方法 |
|  s.find('pa')               |    字符串方法调用:搜索                      |
|  s.rstrip()                 |    移除空格                                 |
|  s.replace('pa','xx')       |    替换                                     |
|  s.split(',')               |    用展位符分隔                             |
|  s.isdigit()                |    内容测试                                 |
|  s.lower()                  |    短信息转换                               |
|  s.endswidth()              |    结束测试                                 |
|  'spam'.join(strlist)       |    插入分隔符                               |
|  s.encode('latin-1')        |    Unicode编码                              |
|  for x in S:print(x)        |    迭代                                     |
|  'spam' in X                |                                             |
|  [c * 2 for c in S]         |                                             |
|  map(ord,S)                 |                                             | 
|-----------------------------+---------------------------------------------|

##字符串常量##

###单双引号字符串是一样的###

在Python中，单引号和双引号字符是可以互换的
此外，Python自动在任意的表达式中合并相邻的字符串常量，尽管可以简单地在它们之间增加+操作符来明确地表示这是一个合并操作

###用转义序列代表特殊字节###

反斜杠用来引入特殊的字节编码——转义序列
转义序列让我们能够在字符串中嵌入不容易通过键盘输入的字节

|---------------+------------------------------|
|  转义         |   意义                       |
|:-------------:|:-----------------------------|
|  `\newline`   |   忽视(连续)                 |
|  `\\`         |   反斜杠(保留\)              |
|  `\'`         |   单引号(保留')              |
|  `\"`         |   双引号(保留")              |
|  `\a`         |   响铃                       |
|  `\b`         |   倒退                       |
|  `\f`         |   换页                       |
|  `\n`         |   新行(换行)                 |
|  `\r`         |   返回                       |
|  `\t`         |   水平制表符                 |
|  `\v`         |   垂直制表符                 |
|  `\N{id}`     |   Unicode数据库ID            |
|  `\uhhhh`     |   Unicode16位的十六进制值    |
|  `\UHHHHHHHH` |   Unicode32位的十六进制值    |
|  `\xhh`       |   十六进制                   |
|  `\ooo`       |   八进制                     |
|  `\0`         |   Null(不是字符串结尾)       |
|  `\other`     |   不转义(保留)               |
|---------------+------------------------------|

###raw字符串抑制转义###

如果字母r(大写或小写)出现在字符串的第一引号的前面，它将会关闭转移机制


###三重引号编写多行字符串块###

Python还有一种三重引号的字符串常量格式，有时称作块字符串。这个形式以三重引号开始(单引号双引号都可以)，并紧跟任意行数的文本，并且以开始时同样的三重引号结尾

##实际应用中的字符串##

###索引和分片###

**索引(S[i])获取特定偏移的元素:**
- 第一个元素的偏移为0
- 负偏移索引意味着从最后或右边反向进行计数
- S[0]获取了第一个元素
- S[-2]获取了倒数第二个元素

**分片(S[i:j])提取对应的部分作为一个序列:**
- 上边界并不包含在内
- 如果没有给出的话，分片的边界默认为0和序列的长度
- S[1:3]获取了从偏移为1的元素，直到但不包括偏移为3的元素
- S[1:]获取了从偏移为1直到末尾(偏移为序列长度)之间的元素
- S[:3]获取了从偏移为0直到但是不包括偏移为3之间的元素
- S[:-1]获取了从偏移为0直到但不包括最后一个元素之间的元素
- S[:]获取了从偏移0到末位之间的所有元素，这有效地实现了顶层S拷贝

分片表达式，还可以有第三个索引参数，用作步长，完整形式的分片变成了:X[I:J:K],这表示:**索引X对象中的元素，从偏移为I直到偏移为J-1，每隔K元素索引一次**

###字符串转换工具###

int():将字符串转换为数字
str():将数字转换为字符串表达形式
float():将字符串转换为浮点数

**字符串代码转换**
ord():将单个字符转换为对应的ASCII码
chr():获取ASCII码并将其转化为对应的字符

##字符串方法##

除了表达式运算符之外，字符串还提供了一系列的方法去实现更复杂的文本处理任务。方法就是与特定的对象相关联在一起的函数。从技术角度来讲，它们附属于对象的属性，而这些属性不过是些可调用的函数罢了。

字符串是不可变的，所以不能在远处直接对其进行修改。为了在已存在字符串中创建新的文本值，我们可以通过分片和合并这样的操作来建立新的字符串。

##字符串格式化表达式##

如今的Python中的字符串格式化可以以两种形式实现:
**字符串格式化表达式**
这是从Python诞生的时候就有的最初的技术；这是基于C语言的"printf"模型，并且在大多数现有的代码中使用
**字符串格式化方法调用**
这是Python2.6和Python3.0新增加的技术，这是Python独有的方法，并且和字符串格式化表达式的功能有很大重叠

{% highlight python %}
'That is %d %s bird!' % (1,'dead')
{% endhighlight %}

上述代码的结果就是:That is 1 dead bird!

从技术上讲，字符串的格式化表达式往往是可选的——通常你可以使用多次的多字符串的合并和转换达到类似的目的。然后格式化允许我们将多个步骤合并为一个简单的操作，这一功能相当强大。

需要注意的是:格式化总是会返回新的字符串作为结果，而不是对左侧的字符串进行修改

字符串格式化代码
|---------+-------------------------------|
|  代码   |   意义　　　　　　　　　　　　|
|:-------:|:------------------------------|
|  s      |   字符串(或任何对象)          |
|  r      |   s,但使用repr，而不是str     |
|  c      |   字符                        |
|  d      |   十进制(整数)                |
|  i      |   整数                        |
|  u      |   无号(整数)                  |
|  o      |   八进制数                    |
|  x      |   十六进制数                  |
|  X      |   x，但打印大写               |
|  e      |   浮点指数                    |
|  E      |   e,但打印大写                |
|  f      |   浮点十进制                  |
|  F      |   浮点十进制                  |
|  g      |   浮点e或f                    |
|  G      |   浮点E或f                    |
|  %      |   常量%                       |
|---------+-------------------------------|

事实上，在格式化字符串中，表达式左侧的转换目标支持多种转换操作，这些操作自由一套相当严谨的语法，转换目标的通用结构看上去是这样的:
`%[(name)][flags][width][.precision]typecode`
有关格式化目标的语法在Python的标准手册中都有完整的介绍


###基于字典的字符串格式化###

字符串的格式化同时也允许左边的转换目标来引用右边字典中的键来提取对应的值。

{% highlight python %}
"%(n)d %(x)s" % {"n":1,"x":"spam"}
{% endhighlight %}

以上代码的结果是:'1 spam'

##字符串格式化调用方法##

###基础知识###

简而言之，Python2.6和Python3.0(及其以后的版本)中的新的字符串对象的format方法使用主体字符串作为模板，并且接受任意多个表示将要根据模板替换的值的参数。在主体字符串中，花括号通过为止或关键字指出替换目标及将要插入的参数

{% highlight python %}
template='{0},{1} and {2}'
template.format('spam','ham','eggs')
{% endhighlight %}

上述代码的结果是'spam,ham and eggs'

###添加键、属性和偏移量###

格式化字符串可以指定对象属性和字典键，方括号指定字典键，而点表示位置或关键字所引用的一项对象属性
{% highlight python %}
import sys
'My {1[spam] runs {0.platform}'.format(sys,{'spam':'laptop'})
{% endhighlight %}

上述代码运行的结果是:'My laptop runs win32'

###添加具体格式化###

格式化的语法:

{% highlight python %}
{fieldname!conversionflag:formatspec}
{% endhighlight %}

- fieldname是指定参数的一个数字或关键字，后面跟着可选的".name"或[index]成分引用
- conversionflag可以是r,s后者a分别是在该值上对repr、str或ascii内置函数的一次调用
- formatspec指定了如何表示该值，包括字段宽度、对齐方式、补零、小数点精度等细节，并且以一个可选的数据类型编码结束

更多细节可以查看Python的库手册。

###为什么要新的格式化方法###

格式化方法相对于原来的字符串格式化表达式有以下几个特点:
- 拥有%表达式所没有的一些额外功能
- 可以更加明确地进行替代值引用
- 考虑到操作符会有一个更容易记忆的方法名
- 不支持用于单个和多个替代之大小写的不同语法


##通常意义下的类型分类##

###同样分类的类型共享其操作集合###

在Python中有三个主要类型(以及操作)的分类:
- 数字(整数、浮点数、二进制、分数等)
	支持加法和乘法
- 序列(字符串、列表、元组)
	支持索引、分片和合并等
- 映射(字典)
	支持通过键的索引等

索引、分片以及其他的序列操作对于所有的序列来说都是同样有效的，对象的类型将会告诉Python去执行什么样的任务。

###可变类型能够在原处修改###

Python中的主要核心类型划分为如下两类:
- 不可变类型(数字、字符串、元组、不可变集合)
	不可变的分类中没有哪个对象类型支持原处修改，尽管我们总是可以运行表达式来创建新的对象并将其结果分配给变量
- 可变类型(列表、字典、可变集合)
	相反，可变的类型总是可以通过操作原处修改，而不用创建新的对象

#列表与字典#

##列表##

列表是Python中最具灵活性的有序集合对象类型。与字符串不同的是，列表可以包含任何类型的对象:数字、字符串甚至其他列表。列表是可变对象，它支持原地修改的操作
Python的列表是:
- 任意对象的有序集合
- 通过偏移读取
- 可变长度、异构以及任意嵌套
- 属于可变序列的分类
- 对象引用数组(列表中的存储的是对象的引用，而不是对象的拷贝)

##实际应用中的列表##

###基本列表操作###

由于列表是序列，它支持很多与字符串相同的操作。列表对"+"和"*"操作的响应与字符串很相似，两个操作的意思也是合并和重复，只不过是一个新的列表，而不是一个字符串

###索引、分片和矩阵###

对于列表而言，索引和分片操作与字符串中的操作基本相同。然而对列表进行索引的结果就是你指定的偏移处的对象(不管是什么类型)，而对列表分片时往往返回一个新的列表

{% highlight python %}
matrix = [[1,2,3],[4,5,6],[7,8,9]]
{% endhighlight %}

上述代码定义了一个3*3的二维矩阵

###原处修改列表###

**索引与分片的赋值**
当使用列表的时候，可以将它赋值给一个特定项(偏移)或整个片段(分片)来改变它的内容，索引和分片的赋值都是原地修改，它们对列表进行直接修改，而不是生成一个新的列表作为结果.Python中的索引赋值与C及大多数其他语言极为相似——Python用一个新值取代指定偏移的对象引用

**列表方法的调用**
最常用的列表方法是append，它能够简单地将一个单项(对象引用)加至列表末端。与合并不同的是，append允许传入单一对象而不是列表。L.append(X)与L+[X]的结果类似，不同的是，前者会原地修改L，而后者会生成新的列表
另一个比较常用的方法就是sort，它原地对列表进行排序。sort是使用Python标准的比较检验作为默认值(在这里指字符串比较)，而且以递增的顺序进行排序。另外，我们可以通过传入一个关键字参数来修改排序行为——这是指定按名称传递的函数调用中特殊的"name=value"语言

需要注意的是:要当心append和sort是原地修改列表对象的，方法的返回结果并没有返回列表(从技术上讲，两者的返回值都是None)。如果编写类似`L=L.append(X)`的语句，将不会得到修改后的值(实际上，会失去整个列表的引用)

- reverse:原地反转列表
- extend:在末端插入多个元素
- pop:删除最后一个元素，同时返回被删除的值
- remove:通过值删除某个元素
- insert:在偏移处插入某个元素
- index:查找某元素的偏移

##字典##

如果把列表看做是有序的对象集合，那么就可以把字典当成是无序的集合，它们主要的差别就在于:字典当中的元素师通过键来存取的，而不是通过偏移存取
Python字典的主要属性如下:
- 通过键而不是偏移来读取
- 任意对象的无序集合
- 可变长、异构、任意嵌套
- 属于可变映射类型
- 对象引用表(散列表)(字典中的存储的是对象的引用，而不是对象的拷贝)

##实际应用中的字典##

###原处修改字典###

与列表相同，向字典中已存在的索引值赋值会改变与索引相关联的值。然而，与列表不同的是，每当对新字典键进行赋值(之前没有被赋值的键)，就会在字典内生成一个新的元素。

###其他字典的方法###

- keys:返回字典的键列表
- values:返回字典的值列表
- items:返回字典的(key,value)对元组
- update:合并
- pop:从字典中删除一个键并返回它的值

###字典用法注意事项###

- **序列运算无效**
- **对新索引赋值会添加项**
- **键不一定总是字符串**

###创建字典的其他方法###

{% highlight python %}
 #Method1
D = {'name':'mel','age':45}

 #Method2
D = {}
D['name']='mel'
D['age']=45

 #Method3
D = dict(name='mel',age=45)

 #Method4
D = dict([('name','mel'),('age',45)])
{% endhighlight %}

以上四种形式都会建立相同的字典

###Python3.0中的字典变化###

字典的功能在Python3.0中已经有所变化了，具体来说，Python3.0中的字典:
- 支持一种新的字典解析表达式，这是列表和集合解析的"近亲"
- 对于D.key,D.values和D.items方法，返回可迭代的视图，而不是列表
- 由于前面一点，需要新的编码方式通过排序键来遍历
- 不再直接支持相对大小比较——取而代之的是手动比较
- 不再有D.has_key方法——相反，使用in成员关系测试

**字典视图**
在Python3.0中，字典的keys、values和items都返回视图对象，而在Python2.6中，它们返回实际的结果列表。Python3.0中的字典视图并非创建后不能改变，它们可以动态地反映在视图对象创建之后对字典做出点修改:

{% highlight python %}
D={'a':1,'b':2,'c':3}
K = D.keys()
V = D.values()
del D['b']
list(K)
{% endhighlight %}
上述代码中，最后一行的结果是['a','c']。

keys方法所返回的对象类似于集合，并且支持交集和并集等常见的操作；values视图不是这样，因为它们不是唯一的；但items结果是的，如果(key,value)对是唯一的并且可散列的话。

#元组、文件及其他#

##元组##

元组由简单的对象构成。元组与列表非常类似，只不过元组不能再原处修改(它们是不可变的)，通常是写成圆括号(而不是方括号)中一系列项。它的属性有:
- 任意对象的有序集合
- 通过偏移存取
- 属于不可变序列类型
- 固定长度、异构、任意嵌套
- 对象引用的数组

###实际应用中的元组###

**元组的特殊语法:逗号和圆括号**
因为圆括号也可以把表达式括起来，如果圆括号里的单一对象时元组对象而不是一个简单的表达式，需要对Python进行特别说明。如果确实想得到一个元组，只要在这一单个元素之后、关闭圆括号之前加上一个逗号就可以了

{% highlight python %}
x = (40)
y = (40,)
{% endhighlight %}
上述代码中，第一行的x是一个整数，第二行的y则是一个包含了一个元素40的元组

**转换、方法以及不可变性**
元组的操作和字符串及列表是一致的，值得注意的区别在于"+"、"*"以及分片操作应用于元组时将返回新元组，并且元组不提供字符串、列表和字典中的方法

###为什么有了列表还要元组###

元组的不可变性提供了某种完整性，这样你可以确保元组在程序中不会被另一个引用修改，而列表就没有这样的保证了

##文件##

内置open函数后创建一个Python文件对象，可以作为计算机上的一个文件链接。在调用open之后，你可以通过调用返回的文件对象的方法来读写相关外部文件
常见文件运算
|---------------------------------------+----------------------------------------------|
|  操作                                 |          解释                                |
|:--------------------------------------|:---------------------------------------------|
|  output=open(r'C:\spam','w')          |  创建输出文件('w'指写入)                     |
|  output=open('data','r')              |  创建只读文件('r'值只读)                     |
|  output=open('data')                  |  与上一行相同('r'是默认值)                   |
|  aString=intput.read()                |  把整个文件读进单一字符串                    |
|  aString=intput.read(N)               |  读取之后的N个字节(一或多个)到一个字符串中   |
|  aString=input.readline()             |  读取下一行(包括行末标识符)到一个字符串      |
|  aList=input.readlines()              |  读取整个文件到字符串列表                    |
|  output.write(aString)                |  写入字节字符串到文件                        |
|  output.writelines(alist)             |  把列表内所有字符串写入文件                  |
|  output.close()                       |  手动关闭(当文件收集完成时会替你关闭文件)    |
|  output.flush()                       |  把输出缓冲区刷到硬盘中，但不关闭文件        |
|  anyFile.seek(N)                      |  修改文件位置到偏移量N处，以便进行下一个操作 |
|  for line in open('data'):use line    |  文件迭代器一行一行地读取                    |
|  open('f.txt',encoding='latin-1')     |  Python3.0 Unicode文本文件(str字符串)        |
|  open('f.bin','rb')                   |  Python3.0 二进制byte文件(bytes字符串)　　　 |
|---------------------------------------+----------------------------------------------|

###打开文件###

为了打开一个文件，程序会调用内置open函数，首先是外部文件名，接着是处理模式。模式使用字符串'r'代表以只读方式打开文件(默认值)，'w'代表以写的方式打开文件，'a'代表追加模式

###使用文件###

一旦存在一个文件对象，就可以调用其方法来读写相关的外部文件。不管在任何情况下，Python程序中的文本文件都采用字符串的形式，读取文件时会返回字符串形式的文本。
上面表格中的方法是子常用的读写方法，如下是一些基础用法的提示:
- 文件迭代器是最好的读取行的工具
- 内容是字符串，不是对象
	当你把数据写入文件时，Python不会自动把对象转换为对象，你必须传递一个已经格式化的字符串。
- close是通常选项
- 文件是缓冲的并且是可查找的

###实际应用中的文件###

**用pickle存储Python的原生对象**
pickle模块是能够让我们直接在文件中存储几乎任何Python对象的高级工具，也并不要求我们把字符串转换来转换去，它就像是超集通用的数据格式化和解析工具

##重访类型分类##

关于对象类型，有以下的一些药店需要记住:
- 对象根据分类共享操作；
- 只有可变对象(列表、字典和集合)可以原处修改，我们不能原处修改数字、字符串或元组
- 数字类型包括了:整数、浮点数、复数、小数和分数
- 集合类似于一个无值的字典的键，但是，它们不能映射为值，并且没有顺序；因此，集合不是一个映射类型或者一个序列类型，frozenset是集合的一个不可变的版本

|-----------------+-------------+--------------|
|  对象类型       |   分类      |  是否可变    |
|:----------------|:------------|:-------------|
|  数字           |   数值      |  否          |
|  字符串         |   序列      |  否          |
|  列表           |   序列      |  是          |
|  字典           |   对应      |  是          |
|  元组           |   序列      |  否          |
|  文件           |   扩展      |  N/A         |
|  Sets           |   集合      |  是          |
|  frozenset      |   集合      |  否          |   
|  bytearray(3.0) |   序列      |  是          |
|-----------------+-------------+--------------|

##引用 VS 拷贝##

引用的一大优点是:你可以在程序范围内任何地方传递大型对象而不必途中产生拷贝。
如果确实需要拷贝，有如下的方法:
- 没有限制条件的分片表达式(L[:])能够复制序列
- 字典copy方法(X.copy())能够复制字典
- 有些内置函数(例如:list)能够生成拷贝(list(L))
- copy标准库模块能够生成完整拷贝

关于拷贝还需要注意的是:无条件值的分片以及字典copy方法只能做顶层复制。也就是说，不能够复制嵌套的数据结构。如果需要一个深层嵌套的数据结构的完整的、完全独立的拷贝，那么就要使用标准的copy模块，包括`import copy`语句，并进行这样的拷贝:`x = copy.deepcopy(Y)`

##比较、相等性和真值##

所有的Python对象也可以支持比较操作，测试相等性、相对大小等.Python的比较总是检查复合对象的所有部分，直到可以得出结果为止。事实上，当嵌套对象存在时，Python能够自动遍历数据结构，并从左到右递归地应用比较，要多深就走多深。过程中首次发现的差值将决定比较的结果。
有两种方式可以测试相等性:
- "=="操作符测试值的相等性。Python运行相等测试
- "is"表达式测试对象的一致性。Python测试二者是否是同一个对象

一般来说，Python中不同的类型的比较方法如下:
- 数字通过相对大小进行比较
- 字符串按照字典顺序，一个字符接一个字符地对比进行比较("abc"<"ac")
- 列表和元组从左到右对每部分进行比较
- 字典通过排序之后的(键、值)列表进行比较。
- 数字混合类型比较在Python3.0中是错误的

###Python中真和假的含义###

在Python中，整数0代表假，整数1代表真
除此之外，Python也把任意的空数据结构视为假，把任何非空数据结构视为真。真和假的概念是Python中每个对象的固有属性:每个对象不是真就是假:
- 数字如果非零，则为真 
- 其他对象如果非空，则为真

**None对象**
Python还有一个特殊的对象:None，总被认为是假，一般都是起到一个空的占位作用

###Type对象###

事实上，即使是类型本身在Python中也是对象类型

#Python语句简介#

##重访Python程序结构##

概念层次:
1. 程序由模块构成
2. 模块包含语句
3. 语句包含表达式
4. 表达式建立并处理对象

##Python的语句##

Python语句
|----------------------+-----------------------|
|     语句             |   角色                |
|:---------------------|:----------------------|
|  赋值                |   创建引用值          |
|  调用                |   执行函数            |
|  打印调用            |   打印对象            |
|  if/elif/else        |   选择动作            |
|  for/else            |   序列迭代            |
|  while/else          |   一般循环            |
|  pass                |   空占位符            |
|  break               |   循环推出            |
|  continue            |   循环继续            |
|  def                 |   函数和方法          |
|  return              |   函数结果            | 
|  yield               |   生成器函数          |
|  global              |   命名空间            | 
|  nonlocal            |   命名空间(Pyton3.0)  |
|  import              |   模块访问            | 
|  from                |   属性访问            | 
|  class               |   创建对象            | 
|  try/except/finally  |   捕捉异常            | 
|  raise               |   触发异常            | 
|  assert              |   调试检查            | 
|  with/as             |   环境管理器(2.6)     |
|  del                 |   删除引用            | 
|----------------------+-----------------------|
相关说明:
- 从技术上讲，print在Python3.0中不是一个保留字，也不是一条语句，而是一个内置函数调用，由于它几乎总是作为一条表达式语句运行，通常将其看做是一条语句类型。
- yield实际上是一个表达式，而不是一条语句，也是一个保留字

注意事项:
- 在Python2.6中，nonlocal不可用
- 在Python2.6中,print是一条语句，而不是一个内置函数调用


#赋值、表达式和打印#

##赋值语句##

赋值语句的特性:

- 赋值语句建立对象的引用
- 变量名在首次赋值时会被创建
- 变量名在引用前必须先赋值

Python赋值语句形式:

|------------------------------+---------------------------------------|
|:-----------------------------|:--------------------------------------|
|        运算                  |   解释                                |
|  spam = 'Spam'               |  基本形式                             |
|  spam,ham='yum','YUM'        |  元组赋值运算(位置性)                 |
|  [spam,ham]=['yum','YUM']    |  列表赋值运算(位置性)                 |
|  a,b,c,d='spam'              |  序列赋值运算，通用性                 |
|  a,*b ='spam'                |  扩展的序列解包(Python3.0)            |
|  spam=ham='lunch'            |  多目标赋值运算                       |
|  spams += 42                 |  增强赋值运算(相当于spams=spams+42)   |
|------------------------------+---------------------------------------|

其中有几点需要说明:

- 第三行和第二行的赋值结果是一样的，spam绑定到'yum',ham绑定到'YUM',在Python中，这叫做分解赋值
- 第四行的赋值结果是:a赋值为's',b赋值为'p',c赋值为'a',d赋值为'm'
- 第五行，用右边的字符串的第一个字母来匹配a，用剩下的部分来匹配b:a赋值为's',b赋值为'pam'.这在Python称作扩展的解包。需要注意的是，带星号的变量总是返回的是一个列表，哪怕只有一个元素或没有元素
- 最后一行的用法和C/C++等其他语言中的语法和意义都是一样的，需要说明的是，在Python中，每个二元表达式运算符都有增强赋值语句
- **赋值语句执行时，Python会建立临时的元组，来存储右侧变量原始的值**

根据上面最后一点的说明，在Python中可以实现不用第三个变量就能交换两个变量的值:

{% highlight python %}
a = 1
b = 2
b,a=a,b
{% endhighlight %}

###多目标赋值语句###

**多目标赋值以及共享引用**

当使用多目标赋值时，需要注意的是，这些变量都是指向同一个对象的。这对于不可变的类型来说，没什么问题，但是对于原处可变的类型来说，需要特别注意了。

{% highlight python3 %}
a = b = []
b.append(42)
a,b
{% endhighlight %}

上面的代码执行后，a和b都是[42]

###增强赋值语句###

Python支持一下的增强语句:

|--------+--------+--------+--------+
|  X+=Y  |  X&=Y  |  X-=Y  |  X|=Y  |
|  X*=Y  |  X^=Y  |  X/=Y  |  X>>=Y |
|  X%=Y  |  X<<=Y |  X**=Y |  X//=Y |
|--------+--------+--------+--------+

在Python中使用了优化技术，增强赋值语句会在底层实现时比较高效

**另外需要注意的是，在使用增强赋值语句时，对于可变变量来说是原处修改的，需要特别注意！**

###变量命名规则###

- 语法:(下划线或字母)+(任意数目的字母、数字或下划线)
- 区分大小写
- 禁止使用保留字

Python3.0中的保留字:

|---------+------------+-----------+-------------+----------|
|  False  |  class     |  finally  |  is         |  return  |
|  None   |  continue  |  for      |  lamdba     |  try     |
|  True   |  def       |  from     |  nonlocal   |  while   |
|  and    |  del       |  global   |  not        |  with    |
|  as     |  elif      |  if       |  or         |  yield   |
|  assert |  else      |  import   |  pass       |          |
|  break  |  except    |  in       |  raise      |          |
|---------+------------+-----------+-------------+----------|

**命名惯例**

- 以单一下划线开头的变量名(_X)不会被from module import *语句导入
- 前后有下划线的变量名(_X_)是系统定义的变量名，对解释器有特殊意义
- 以两下划线开头、但结尾没有两个下划线的变量名(__X)是类的本地("压缩")变量

##打印操作##

在Python中，print语句可以实现打印:只是对程序员友好的标准输出流的接口而已
标准输出流、标准输入流、错误流是脚本启动时所创建的3中数据连接中的一种。

- 在Python3.X中，打印是一个内置函数，用关键字参数来表示特定模式
- 在Python2.X中，打印是语句，拥有自己的特定语法

###Python3.0中的print函数###

print函数不会返回任何值，从技术上讲，它将返回None

**调用格式**

从语法上讲，Python3.0中的print函数有如下的形式

{% highlight python %}
print([object,..][,sep=' '][,end='\n'][,file=sys.stdout])
{% endhighlight %}

在上述表达式中，方括号中的项是可选的，并且可能会在一个给定的调用中省略，并且=后面的值都给出了参数的默认值。这个内置的函数吧字符串sep所分割开的一个或多个对象的文本表示，后面跟着字符串and，都打印到流file中
这些参数是这样控制print操作的:

- sep是在每个对象的文本之间插入的一个字符串，如果没有传递的话，它默认地是一个单个空格；传递一个空字符串将会抑制分隔符
- end是添加在打印文本末尾的一个字符串，如果没有传递的话，它默认的是一个\n换行字符。传递一个空字符将会避免在打印的文本的末尾移动到下一个输入行——下一个print将会保持添加到当前输出行的末尾。
- file指定了文本将要发送到的文件、标准流或者其他类似文件的对象；如果没有传递的话，默认的是sys.stdout。带有一个类似文件的write(string)的方法的任何对象都可以传递，但真正的文件应该已经为了输出而打开。

###打印流重定向###

{% highlight python3 %}
import sys
sys.stdout=open('log.txt','a')
...
print(x,y,z)
{% endhighlight %}

上面的代码就简单的标准输出流重定向到了文本文件中，而且是以追加的模式。其实，甚至可以将sys.stdout重设为非文件对象，只要该对象有预期的协议(write方法)。

#if测试和语法规则#

##if语句##

###通用格式###

if语句一般形式如下:

{% highlight python3 %}
if <test1>:
	<statements1>
elif <test2>:
	<statements2>
else:
	<statements3>
{% endhighlight %}

另外需要注意的是，Python中是没有`switch/case`语句的

##Python语法规则##

Python的语法特性:

- 语句是逐个运行的。
- 块和语句的边界会自动检测
- 复合语句=首行+":"+缩进语句
- 空白行、空格以及注释通常都会忽略
- 文档字符串(docstring)会忽略，但会保存并由工具显示

###代码分隔符###

Python会自动以行缩进检测块的边界，也就是程序代码左侧的空白空间。缩进至右侧相同距离的所有语句属于同一块的代码，换句话说，块内的语句会垂直对齐，就好像在一栏之内。更深层的嵌套块就是比所在块进一步向右缩进

缩进的时候，可以使用空格也可以使用制表符，Python不在乎你怎么缩进，只在乎缩进是否一致。
不过，最好的是使用空格进行缩进，因为一个制表符在不同的编辑器中呈现的效果是不同的，其次也最好不要使用制表符和空格符混合使用

###语句的分隔符###

- 如果使用语法括号对，语句就可以横跨数行
- 如果语句以反斜杠结尾，就可横跨数行
- 字符串常量有特殊规则
- 其他规则

##真值测试##

在Python中:

- 任何非零数字或非空对象都为真
- 数字零、空对象以及特殊对象None都被认作是假
- 比较和相等测试会递归地应用在数据结构中
- 比较和相等测试会返回True或False(1和0的特殊版本)
- 布尔and和or运算会返回真或假的操作对象
- Python中的and、or运算都是短路运算

#while和for循环#

##while循环##

while语句是Python语言中最通用的迭代结构，简而言之，只要顶端测试一直计算到真值，就会重复执行一个语句块。

###一般格式###

{% highlight python3 %}
while <test>:
  <statements1>
else:
  <statements2>
{% endhighlight %}

###break,continue,pass和循环else###

**break**

跳出最近所在的循环(跳过整个循环语句)。

**continue**

跳到最近所在循环的开头处(来到循环的首行)。

**pass**

什么事也不做，只是空占位符语句。

**循环else块**

只有当前循环正常离开时才会执行(也就是没有碰到break语句)

###一般循环格式###

加入break和continue语句后，while的一般格式变为:

{% highlight python3 %}
while <test1>:
  <statements1>
  if <test2>:break
  if <test3>:continue
else:
  <statements2>
{% endhighlight %}

###pass###

pass语句是无运算的占位符，当语法需要语句并且还没有任何实用的语句可写时，就可以使用它。

###循环else###

在while语句中加入else和C/C++中的语法不太一样，这里详细说明一下。else后面的代码只有当循环正常结束时才会执行，如果是用break跳出循环的，这部分代码就不会运行，具体看一个求质数的例子:

{% highlight python3 %}
x = y // 2
while x > 1:
  if y % x == 0:
    print(y,'has factor',x)
    break
  x -= 1
else:
  print(y,'is prime')
{% endhighlight %}

再看一个对比的例子，没有使用else的情况:

{% highlight python3 %}
found=False
while x and not found:
  if (matchx[0]):
    print('Ni')
    found=True
  else:
    x=x[1:]
if not found:
  print('not found')
{% endhighlight %}

使用else后的情况:

{% highlight python3 %}
while x:
  if (match(x[0])):
    print('Ni')
    break
else:
  print('not found')
{% endhighlight %}

##for循环##

for循环在Python中是一个通用的序列迭代器:可以遍历任何有序的序列对象内元素。for语句可以用于字符串、列表、元组、其他内置可迭代对象。

###一般格式###

{% highlight python3 %}
for <target> in <object>:
  <statements>
else:
  <statements>
{% endhighlight %}

此处的else的作用和while语句中的一样。另外需要注意的是，当Python运行for循环时，会逐个将序列对象中的元素赋值给目标，然后为每个元素执行循环体。


##编写循环的技巧##

- 内置**range**函数:返回一系列连续增加的整数，可作为for中的索引
- 内置**zip**函数:返回并行元素的元组的列表，可用于在for中遍历数个数列

###循环计数器:while和range###

**range**

当range函数只有一个参数时，会返回从零算起的整数列表，但其中不包括该参数的值。如果传进两个参数，那第一个参数是上边界，第二个参数是下边界。如果传进三个参数时，第三个参数表示步进值。

range提供了一种简单的方法，重复特定次数的动作:

{% highlight python3 %}
for i in range(5):
  print(i,'Pythons')
{% endhighlight %}

相应的C++代码则是:

{% highlight c++ %}
int i;
for(i = 0;i < 5;++i)
{
  std::cout<<i<<"Python";
}
{% endhighlight %}

###并行遍历:zip和map###

zip会取得一个或多个序列为参数，然后返回元组的列表，将这些序列中的并排的元素配成对。

{% highlight python3 %}
L1=[1,2,3,4]
L2=[5,6,7,8]
list(zip(L1,L2))
{% endhighlight %}

上述代码的执行结果是:[(1,5),(2,6),(3,7),(4,8)]

当参数的长度不同时，zip会以最短序列的长度为准来截断所得到的元组。

使用zip构造字典:

{% highlight python3 %}
keys=['spam','eggs','totast']
values=[1,2,5]
D = dict(zip(keys,values))
{% endhighlight %}

###产生偏移和元素:enumerate###

enumerate函数一个比较新的内置函数，它能同时返回元素值和偏移值:

{% highlight python3 %}
s='spam'
for (offset,item) in enumerate(s):
  print(item,'appears at offset',offset)
{% endhighlight %}

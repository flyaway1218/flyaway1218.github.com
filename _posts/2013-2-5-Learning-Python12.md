---
title: 《Learning Python》学习笔记——12.迭代器和解析,第一部分
time: 2013-2-5
layout: post
category: Python
---

#迭代器:初探#
上一章曾经提到过，其实for循环是可用于任何可迭代的对象上的。实际上，对Python中所有会从左至右扫描对象的迭代工具而言都是如此，这些迭代工具包括了for循环、列表解析、in成员关系测试以及map内置函数等。

"可迭代对象"的概念在Python中是相当新颖的，基本这就是序列观念的通用化:如果对象时实际保存的序列，或者可以再迭代工具环境中一次产生一个结果的对象,那就看做是可迭代的。

##文件迭代器##
作为内置数据类型的文件也是可迭代的，它有一个名为`__next__`的方法，每次调用时，就会返回文件中的下一行。当到达文件末尾时，`__next__`会引发内置的StopIteration异常，而不是返回空字符串。

这个接口就是Python中所谓的迭代协议:有`__next__`方法的对象会前进到下一个结果，而在一系列结果的末尾时，则会引发StopIteration。任何这类对象都认为是可迭代的。任何这类对象也能以for循环或其他迭代工具遍历，因为所有迭代工具内部工作起来都是在每次迭代中调用`__next__`，并且捕捉StopIteratin异常来确定何时离开。

{% highlight python3 %}
for line in open('script.py'):
	print(line.upper(),end='')
{% endhighlight %}

上面的代码就是文件迭代的一个例子，并且这种用法是最高效的文件读取方法，主要有三个优点:这是最简单的写法，运行快，并且从内存使用情况来说也是最好的。

替代的写法是:
{% highlight python3 %}
for line in open(script.py').readlines():
	print(line.upper(),end='')
{% endhighlight %}
这种调用方法会把文件一次性读到内存中，如果文件太大，那么内存会被消耗光的。

##手动迭代:iter和next##
为了支持手动迭代代码(用较少的录入)，Python3.0还提供了一个内置函数next，它会自动调用一个对象的`__next__`方法。给定一个对象X，调用`next(X)`等同于`X.__next__()`，但前者简单很多。

从技术角度来讲，迭代协议还有一点值得注意。当for循环开始时，会通过它传给iter内置函数，以便从可迭代对象中获得一个迭代器，返回的对象含有需要的next方法。调用iter的步骤对于文件来说不是必须的，因为文件对象就是自己的迭代器，但是对于其他的一些内置数据类型来说，就不一定了。

列表以及很多其他的内置对象，不是自身的迭代器，因为它们支持多次打开迭代器。对这样的对象，我们必须调用iter来启动迭代:

{% highlight python3 %}
L=[1,2,3]
iter(L) is L	#return false
L.__next__()	#会报错

I = iter(L)
I.__next__()
I.__next__()
{% endhighlight %}
虽然Python迭代工具自动调用这些(`iter`,`__next__`)函数，我们也可以使用它们来手动地应用迭代协议。

#列表解析:初探#

##列表解析基础知识##

{% highlight python3 %}
L=[1,2,3,4,5]
L = [x+10 for x in L]
{% endhighlight %}

列表解析写在一个方括号中，因为它们最终是构建一个新的列表的一种方式。它们以我们所组成的一个任意的表达式开始，该表达式使用我们所组成的一个循环变量(x+10)。这后面跟着我们现在应该看作是一个for循环头部的部分，它申明了循环变量，以及一个可迭代对象(for x in L)

要运行该表达式，Python在解释器内部执行一个遍历L的迭代，按照顺序把x赋给每个元素，并且收集对各元素运行左边的表达式的结果。我们得到的结果列表就是列表解析所表达的内容——针对L中的每个x,包含了x+10的一个新列表。

其实列表解析式并不是必须的，因为它能完成的工作都能够通过for循环完成，但是列表解析式比手动的for循环语句运行得更快(往往速度快一倍)，因为它们的迭代在解释器内部是以C语言的速度执行的，而不是以手动的Python代码执行的，特别是对于较大的数据集合，这是使用列表解析的一个主要的性能优点。

当我们考虑在一个序列中的每个项上执行一个操作时，都可以考虑使用列表解析。


##扩展的列表解析语法##
实际上，列表解析可以有更高级的应用。作为一个特别有用的扩展，表达式中嵌套的for循环可以有一个相关的if子句，来过滤那些测试不为真的结果项。
{% highlight python3 %}
lines = [line.rstrip() for line in open('script.py') if line[0]='p']
{% endhighlight %}
这条if子句检查从文件读取的每一行，看它的第一个字符是否是p；如果不是，从结果列表中省略改行。

事实上，如果我们愿意的话，列表解析可以变得更加复杂——它们的完整语法允许任意数目的for子句，每个子句有一个可选的相关的if子句。

#Python3.0中的新的可迭代对象#
Pyton3.0中的一个基本的改变是，它比Python2.x更强调迭代。除了与文件和字典这样的内置类型相关的迭代，字典方法keys、values和items都在Python3.0中返回可迭代对象。
返回一个可迭代对象而不是返回一个结果列表的好处在于节省了内存的空间。

##多个迭代器VS单个迭代器##
多个迭代器:在它们的结果中能保持不同位置的多个迭代器
单个迭代器:只能保持一个迭代器，在遍历其结果之后，它们就用尽了。

通常通过针对iter调用返回一个新的对象，来支持多个迭代器；单个迭代器一般意味着一个对象返回其自身。

##字典视图迭代器##
在Python3.0中，字典的keys、values和items方法返回可迭代的视图对象，它们一次产生一个结果项，而不是在内存中一次产生全部结果列表。视图项保持和字典中的那些项相同的物理顺序，并且反映对底层的字典做出的修改。

和所有迭代器一样，我们总可以通过把一个Python3.0字典视图传递到list内置函数中，从而强制构建一个真正的列表。然而，这通常不是必须的。

此外，Python3.0字典仍然有自己的迭代器，它返回连续的键。因此，无需直接在此环境中调用keys:

{% highlight python3 %}
for key in D:print(key,end='')
{% endhighlight %}

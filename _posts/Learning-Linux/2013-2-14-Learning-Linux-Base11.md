---
layout: post
title: 《鸟哥的Linux私房菜:基础篇》学习笔记——11.学习shell script
time: 2013-2-14
category: LinuxBase
published: false
---


#什么是shell script#

shell script是利用shell功能所写的一个"程序"(program),这个程序是使用纯文本文件,将一些shell的语法与命令(含外部命令)写在里面，搭配正则表达式、管道命令与数据流重定向等功能，以达到我们所想要的处理目的

shell script用在系统管理上是很好的一项工具，但是用在处理大量数值运算上，就不够好了，因为shell script的速度较慢，且使用的CPU资源较多，造成主机资源的分配不良


##第一个script的编写与执行##

在shell script的编写中还需要用到下面的注意事项:
1. 命令的执行时从上而下、从左而右地分析与执行
2. 命令执行时，命令、参数间的多个空白都会被忽略掉
3. 空白行也将被忽略掉，并且[Tab]按键所得的空白同样视为空格键
4. 如果读取到一个Enter符号(CR)，就尝试开始执行该行(或该串)命令
5. 至于如果一行的内容太多，则可以使用"\[Enter]"来扩展至下一行
6. "#"可作为批注，任何加在"#"后面的数据将全部视为批注文字而被忽略

当编写好一个名为`/home/dmtsai/shell.sh`的script后，可以通过以下的方法来执行:
- 直接命令执行:
		- 绝对路径:使用`/home/dmtsai/shell.sh`来执行命令
		- 相对路径:假设工作目录在`/home/dmtsai/`，则使用`./shell`来执行
		- 变量`PATH`功能`:将shell.sh放在`PATH`指定的目录内
- 以bash进程来执行:通过`bash shell.sh`或`sh shell.sh`来执行

整个script可以分成数段，大致是这样的:

1. 第一行`#!/bin/bash`声明这个script使用的shell名称
	 script中的第一行必须声明这个script所使用的shell名称，否则很可能会无法执行,声明的方式是:`#!/bin/bash`
2. script内容的说明
	 整个script当中，除了第一行的`#!`是用来声明shell的之外，其他的#都是批注用途。一般来说，一样要养成说明该script的内容与功能、版本信息、作者与联络方式、建立日期、历史记录等习惯。
3. 主要环境变量的声明
	 务必要把一些重要的环境变量设置好，`PATH`与`LANG`是当中最重要的
4. 主要程序部分
5. 告知执行结果
	 我们可以利用`exit`这个命令来让程序中断，并且回传一个数值给系统。(其实就是返回值)

##编写shell script的良好习惯##

养成良好的script的编写习惯，在每个script的文件头处记录好:
- script的功能
- script的版本信息
- script的作者与联络方式
- script的版权声明方式
- script的History(历史记录)
- script内较为特殊的命令，使用"绝对路径"的方式来执行
- script执行时需要的环境变量预先声明与设置


##简单的shell script练习##

##script的执行方式区别(source,shscript,./script)##

不同的script执行方式会造成不一样的结果。尤其对bash的环境影响很大。脚本的执行方式除了之前谈到的方式，还可以利用source或小数点(.)来执行。

- 利用直接执行的方式来执行script
	当使用之前提到过的方式(不论是绝对路径、相对路径、`$PATH`还是利用bash或sh)执行脚本时，该script都会使用一个新的bash环境来执行脚本内的命令，也就是说，使用这种方式时，其实script是在子进程的bash内执行的。重点是，**当子进程完成后，子进程内的各项变量后操作将会结束而不会回传到父进程中**
- 利用`source`来执行脚本:在父进程中执行
	如果利用`source`来执行script的话，script会直接在当前的bash进程中执行。这就是为什么你注销系统而要让某些写入`~/.bashrc`设置生效时，需要使用`source ~/.bashrc`而不能使用`bash ~/.bashrc`


#善用判断式#

##利用test命令的测试功能##

当我们需要检测系统上面某些文件或者是相关属性时，利用`test`这个命令来工作真是好用的不得了
`test`有很多测试标志，归纳成下面的表格
|-----------------+--------------------------------------------------------------------------------------------------------------|
|:---------------:|:------------------------------------------------------------------------------------------------------------:|
|  测试的标志     |  代表意义                                                                                                    |
|    -f           |  该文件名是否存在且为文件(file)(常用)                                                                        |
|    -d           |  该文件名是否存在且为目录(directory)(常用)                                                                   |
|    -c           |  该文件名是否存在且为一个character device设备                                                                |
|    -b           |  该文件名是否存在且为一个block device设备                                                                    |
|    -S           |  该文件名是否存在且为一个Socket文件                                                                          |
|    -p           |  该文件名是否存在且为一个FIFO(pipe)文件                                                                      |
|    -L           |  该文件名是否存在且为一个连接文件                                                                            |
|                 |  关于文件的权限检测                                                                                          |
|    -r           |  该文件名是否存在且具有"可读"的权限                                                                          |
|    -w           |  该文件名是否存在且具有"可写"的权限                                                                          |
|    -x           |  该文件名是否存在且具有"可执行"的权限                                                                        |
|    -u           |  该文件名是否存在且具有"SUID"的属性                                                                          |
|    -g           |  该文件名是否存在且具有"SGID"的属性                                                                          |
|    -k           |  该文件名是否存在且具有"Sticky bit"的属性                                                                    |
|    -s           |  该文件名是否存在且为"非空白文件"                                                                            |
|                 |  两个文件之间的比较                                                                                          |
|    -nt          |  (newer than)判断file1是否比file2新                                                                          |
|    -ot          |  (old than)判断file1是否比file2旧|                                                                           |
|    -et          |  判断file1与file2是否为同一个文件，可用在判断hard link的判定上。主要意义在于判定两个文件是否均指向同一个inode|
|                 |  关于两个整数之间的判定                                                                                      |
|    -eq          |  两数值相等(equal)                                                                                           |
|    -ne          |  两数值不等(not equal)                                                                                       |
|    -gt          |  n1大于n2(greater than)                                                                                      |
|    -lt          |  n1小于n2(less than)                                                                                         |
|    -ge          |  n1大于等于n2(greater than or equal)                                                                         |
|    -le          |  n1小于等于n2(less than or equal)                                                                            |
|                 |  判定字符串的数据                                                                                            |
| Test -z string  |  判定字符串是否为0，若string为空字符串，则为true                                                             |
| Test -n string  |  判定字符串是否非为0，若string为空字符串，则为false 注:-n也可省略                                            |
| test str1=str2  |  判定str1是否等于str2，若相等，则回传true                                                                    |
| Test str1!=str2 |  判定str1是否不等于str2，若相等，则回传false                                                                 |
|                 |  多重条件判定                                                                                                |
|    -a           |  两个条件同时成立！如:`test -r file -a -x file`,则file同时具有r与x权限时，才回传true                         |
|    -o           |  任何一个条件成立！                                                                                          |
|    -!           |  反向状态                                                                                                    |
|-----------------+--------------------------------------------------------------------------------------------------------------|

##利用判断符号[]##

除了使用test以外，我们还可以利用判断符号`[]`来进行数据的判断
在使用判断符`[]`时，需要注意的是:
- 在中括号[]内每个组件都需要有空格键来分隔
- 在中括号[]内的变量，最好都以双引号括号起来
- 在中括号[]内的常量，最好都以单或双引号括起来


##shell script的默认变量($0,$1...)##

可以给一个script设置参数，例如`ls -la`一样，在script中可以通过一些默认变量来调用传进来的参数

|------------+-------------------------------------------------------|
|  默认变量  |  意义                                                 |
|:----------:|:-----------------------------------------------------:|
|  $0        |  该脚本的文件名                                       |
|  $n        |  第n个参数                                            |
|  $#        |  后面接的参数个数                                     |
|  $@        |  代表"$1"、"$2"、"$3"之意，每个变量是独立的           |
|  $*        |  代表“"$1c$2c$3c$4"”,其中c为分隔字符，默认为空格    |
|------------+-------------------------------------------------------|

另外`shift`可以造成参数变量号码偏移

#条件判断式#

##利用if...then##

判断式如下所示:
{% highlight bash %}
if [条件一]; then
		当条件一成立时，可以进行的命令工作内容
elif [条件二]; then 
		当条件二成立时，可以进行的命令工作内容
else
		当条件一与条件二均不成立时，可以进行的命令工作内容
fi
{% endhighlight %}

##利用case...esac##

语法如下

{% highlight bash %}
case $变量名称 in			#关键字为case，还有变量前有$
	"第一个变量内容")   #每一个变量内容建议用双引号括起来，关键字则为小括号
			程序段
			;;							#每个类型结尾要使用两个连续的分号来处理
	"第二个变量内容")
			程序段
			;;
	*)									#最后一个变量内容都会用*来代表所有其他值
			不包含第一个变量内容与第二个变量内容的其他程序执行段
			;;
esac									#最终的case结尾！
{% endhighlight %}

##利用function功能##

函数语法格式为
{% highlight bash %}
function fname(){
		程序段
}
{% endhighlight %}

由于shell script的执行方式是由上而下、由左而右，因此在shell script当中的function的设置一定要在程序的最前面(其实，简单来说就先定义后使用)

**function也是拥有内置变量的。它的内置变量与shell script很类似，函数名称用$0表示，而后接的变量也是用$1,$2...来表示的**


#循环(loop)#

##不定循环##

不定循环有两种状态:

{% highlight bash %}
while [ condition ]
do
	程序段落
done
{% endhighlight %}
说明:当condition条件成立时，就进行循环


{% highlight bash %}
until [condition]
do
	程序段落
done
{% endhighlight %}
说明:当condition条件成立时，就终止循环;否则就持续进行循环的程序段

##固定循环##

语法是:

{% highlight ruby %}
for var in con1 con2 con3...
do
		程序段
done
{% endhighlight %}

##固定循环的数值处理##

{% highlight bash %}
for (( 初始值;限制值;执行步长 ))
do
		程序段
done
{% endhighlight %}



#shell script的追踪与调试#

`sh [-nvx] script.sh`
参数:
-n: 不要执行script,仅查询语法的问题
-v: 在执行script前，先将script的内容输出到屏幕上
-x: 将使用到的script内容显示到屏幕上，这是很有用的参数！



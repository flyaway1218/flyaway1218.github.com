---
layout: post
title: 《鸟哥的Linux私房菜:基础篇》学习笔记——9.认识与学习bash
time: 2013-2-14
category: LinuxBase
---


#认识bash这个shell#

##硬件、内核shell##

我们必须通过"Shell"将我们输入的命令与内核通信，好让内核可以控制硬件来正确无误地工作

其实Shell的功能只是提供用户操作系统一个接口。

每个用户都可以设置自己的所有使用的shell版本，这个信息是存储在`/etc/passwd`中的，系统默认采用是的bash，但是是可以修改的。

系统合法的shell均写在`/etc/shells`中

##bash shell的功能##
bash中的命令历史是存储在用户主文件夹的.bash_history中，不过需要注意的是，~./bash_history中记录的是前一次登陆以前所执行过的命令，而至于这一次登陆所执行的命令都被暂存在临时内存中，当你成功注销系统后，该命令记忆才会记录到.bash_history当中

通过type命令我们可以知道每个命令是否为bash的内置命令

在bash中可以通过"\\[Enter]"来对[Enter]进行转义

#Shell的变量功能#

##变量的显示与设置:echo,unset##

变量的显示:echo   echo ${}

变量的修改:直接用"="连接变量与它的内容`myname=flyway`

变量设置的规则:

1. 变量与变量内容以一个等号"="来连接
2. 等号两边不能直接接空格
3. 变量名称只能是英文字母与数字，但是开头字符不能是数字
4. 变量内容若有空格符可使用双引号或单引号将变量内容结合起来

   `var="lang is $LANG"`     那么`echo $var`可得"lang is en_US"\\
   `ar='lang is $LANG'`      那么`echo $var`可得"lang is $LANG"

5. 可用转义字符"\"将特殊符号编程一般字符
6. 在一串命令中，还需要通过其他命令提供的信息，可以使用反单引号"`命令`"或"$(命令)"。

   `version=$(unname -r)`再`echo $version`可得 "2.6.18-128.el5"

7. 若该变量为了增加变量内容时，则可用$(变量)或"$变量名称"累加内容`echo $var`
		`PATH="$PATH":/home/bin`
8. 若该变量需要其他其他子进程执行，则需要以export来是变量变成环境变量:
		`export PATH`
9. 通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断
10. 取消变量的方法为使用"unset 变量名称"

##环境变量的功能##

系统中的变量一般可以分为三种:系统环境变量、与bash接口有关的变量和用户自定义变量

env可以用来查看环境变量与常见环境变量说明

环境变量的分析:

- HOME:代表用户的主文件夹
- SHELL:它说明了当前这个环境使用的shell是哪个程序。Linux默认使用/bin/bash的
- HISTSIZE:我们曾今执行过的命令可以被系统记录下来，而记录的"条数"则是由这个值来设置的。
- MAIL:使用mail命令在收信时系统会去读取的邮件信箱文件(mailbox)
- PATH:执行文件查找的路径，目录与目录之间用冒号":"隔开，由于文件的查找是依序由PATH的变量内的目录来查询，所以目录顺序也是重要的。
- LANG:语系数据，这很重要。中文编码通常是zh_CN.gb2312或者是zh_CN.UTF-8
- RANDOM:"随机数"的变量，随机数生成器，生成介于0~32767之间


可以用set查看所有的变量,包含环境变量、与bash接口有关的变量和自定义变量
其中比较重要的有以下几个:

- PS1(提示符的设置)
		这个东西就是我们的"命令提示符",当我们每次按下[Enter]按键去执行某个命令后，最后要再次出现提示符时，就会主动去读取这个变量值。变量值中符号的意义:

  - `\d`:可显示出"星期月日"的日期格式，如"Mon Feb 2"
  - `\H`:完整的主机名
  - `\h`:仅取主机名的在第一个小数点之前的名字
  - `\t`:显示时间,为24小时格式的"HH:MM:SS"
  - `\T`:显示时间,为12小时格式的"HH:MM:SS"
  - `\A`:显示时间,为24小时格式的"HH:MM"
  - `\@`:显示时间,为12小时格式的"am/pm"样式
  - `\u`:目前用户的账号名称
  - `\w`:BASH的版本信息
  - `\W`:完整的工作目录名称，由根目录写起的目录名称。但主文件夹会以~替代
  - `\#`:利用basename函数取得工作目录名称，所以仅会列出最后一个目录名
  - `\$`:提示符，如果是root时，提示符为#，否则就是$
- $(关于shell的PID)
  
  `$`本身也是变量，这个代表的是目前这个Shell的线程代号，即所谓的PID。

- ？(关于上个执行命令的回传码)

  在bash里这个变量很重要，这个变量是上一个执行的命令所回传的值。当我们执行某个命令时，这些命令会回传一个执行后的代码。一般来说，如果成功执行该命令，则会回传一个0值。

- OSTYPE,HOSTTYPE,MACHTYPE(主机硬件与内核的等级)

  32位CPU:i386、i586、i586

  64位CPU:x86_64

- export:自定义变量转换成环境变量

  **子进程仅会继承父进程的环境变量，子进程不会继承父进程的自定义变脸**

  可以通过export命令来将一个自定义变量转变为环境变量

##影响显示结果的语系变量(locale)##

locale:表示用户的语言环境,不仅仅是指编码方式。locale包含很多习惯定义，一共有十二类:

- LC_CTYPE:字符(文字)辨识的编码
- LC_NUMERIC:数字系统显示的信息
- LC_TIME:时间系统的显示数据
- LC_COLLATE:字符串的比较和排序习惯
- LC_MONETARY:货币格式的显示
- LC_MESSAGES:信息提示，主要是菜单、错误信息等
- LC_NAME:姓名书写方式
- LC_ADDRESS:地址书写方式
- LC_TELEPHONE:电话号码的书写方式
- LC_MEASUREMENT:度量衡表达方式
- LC_PAPER:默认纸张尺寸的大小
- LC_IDENTIFICATION:对locale自身包含信息的概述

系统所支持的locale文件放置在`/usr/share/i18n/locales`中

可以通过locale列出当前系统所支持的语系,当前所使用的语系文件都放置在`/usr/lib/locale/`目录中

整体系统默认的语系定义在`/etc/sysconfig/i18n`中

可以修改当前系统的locale，修改其十二个类别，然后重新生成当前系统所使用的语系文件，覆盖`/usr/lib/locale/`中的语系文件

##变量的有效范围##

基本上可以这么理解:

环境变量=全局变量
自定义变量=局部变量

##变量键盘读取、数组与声明:read,array,declare##

**read**\\
read [-pt] variable

读取来自键盘输入的变量

- -p:后面可以接提示符
- -t:后面可以接等待的秒数，不会一直等待用户

**declare/tepeset**\\
declare [-aixr] variable

声明变量的类型

- -a:将变量定义成为数组
- -i:将变量定义成为整数数字
- -x:用法与export相同，将后面的变量编程环境变量
- -r:将变量设置成readonly类型，该变量不可被更改内容，也不能重设

在默认情况下，bash对于变量有几个基本的定义:

- 变量类型默认为"字符串"
- bash环境中的数值运算，默认最多仅能到达整数类型

##与文件系统及程序的限制关系:ulimit##

我们的bash是可以限制用户的某些系统资源的，包括可以打开的文件数量、可以使用的CPU时间、可以使用的内存总量等。
可以使用ulimit进行设置。

##变量内容的删除、替代与替换##

**删除与替换**

|------------------------------+----------------------------------------------------------------|
|  变量设置方式                |                 说明                                           |
|:----------------------------:|:--------------------------------------------------------------:|
|  ${变量#关键字}              |  若变量内容从头开始的数据符合"关键字"，则将符合的最短数据删除  |
|  ${变量##关键字}             |  若变量内容从头开始的数据符合"关键字"，则将符合的最长数据删除  |
|  ${变量%关键字}              |  若变量内容从尾向前的数据符合"关键字"，则将符合的最短数据删除  |
|  ${变量%%关键字}             |  若变量内容从尾向前的数据符合"关键字"，则将符合的最长数据删除  |
|  ${变量/旧字符串/新字符串}   |  若变量内容符合"旧字符串"，则第一个旧字符串会被新字符串替换    |
|  ${变量//旧字符串/新字符串}  |  若变量内容符合"旧字符串"，则全部的旧字符串会被新字符串替换    |
|------------------------------+----------------------------------------------------------------|

**替代**

|--------------------+----------------------+----------------------+-----------------------|
|  变量设置方式      |  str没有设置         |  str为空字符串       |  str已设置非空字符串  |
|:------------------:|:--------------------:|:--------------------:|:----------------------|
|  var=${str-expr}   |  var=expr            |  var=                |  var=$str             |
|  var=${str:-expr}  |  var=expr            |  var=expr            |  var=$str             |
|  var=${str+expr}   |  var=                |  var=expr            |  var=expr             |
|  var=${str:+expr}  |  var=                |  var=                |  var=expr             |
|  var=${str=expr}   |  var=expr\\str=expr  |  str不变\\var=       |  str不变\\var=$str    |
|  var=${str:=expr}  |  var=expr\\str=expr  |  var=expr\\str=expr  |  str不变\\var=$str    |
|  var=${str?expr}   |  expr输出至stderr    |  var=                |  var=str              |
|  var=${str:?expr}  |  expr输出至stderr    |  expr输出至stderr    |  var=str              |
|--------------------+----------------------+----------------------+-----------------------|

#命令别名与历史命令#

##命令别名设置:alias,unslias##

alias 别名="命令 参数"

别名可以替代现有命令，也可以创造新命令。用于简便地输入长命令。例如

- alias shutdown="shutdown -h now"
- alias rm="rm -i"
- alias ll="ls -al"

## history ##
可以通过history命令列出之前所有的历史命令

#Bash Shell的操作环境#

##路径与命令查找顺序##

同一个命令被执行的顺序:

1. 以相对/绝对路径执行命令，例如`/bin/ls`或`./ls`
2. 由alias找到该命令来执行
3. 由bash内置的命令来执行
4. 通过$PATH这个变量的顺序找到第一个命令来执行

##bash的登录与欢迎信息:`/etc/issue`,`/etc/motd`##

登录界面的字符串是写在`/etc/issue`中的，这个文件内容可以使用反斜杠作为变量调用:

|  \d  |  本地端时间的日期                             |
|  \l  |  显示第几个终端机接口                         |
|  \m  |  显示硬件的等级(i386/i486/i586/i686...)       |
|  \n  |  显示主机的网络名称                           | 
|  \o  |  显示domain name                              |
|  \r  |  操作系统的版本(相当于uname -r)               | 
|  \t  |  显示本地端时间的时间                         | 
|  \s  |  操作系统的名称                               |
|  \v  |  操作系统的版本                               |

**注意**

当使用telnet远程连接主机的时候，主机的登陆界面就会显示`/issue.net`而不是`/etc/issue`

如果想要让用户登陆后取得一些信息，例如你想要让大家都知道的信息，那么可以将信息写入到`/etc/motd`

##bash的环境配置文件##

bash在启动时直接读取一些配置文件，以规划好bash的操作环境
之前谈到的命令别名、自定义变量在你注销bash之后就会失效，所以如果想要保留你的设置，就得要将这些设置写入配置文件才行。

**login与non-login shell**

login shell:取得bash时需要完整的登录流程

non-login shell:取得bash接口的方法不需要重复登录的举动，例如在X Window登陆后再以X的图形界面启动终端机

**login shell**

一般来说，login shell其实只会读取两个配置文件:

1. `/etc/profile`:这是系统整体的设置，最好不要修改这个文件
2. `~/.bash_profile`或`~/.bash_login`或`~/.profile`:属于用户个人设置，你要改自己的数据，就写入这里

**/etc/profile**

这是每个用户登陆取得bash时一定会读取的配置文件

这个文件设置的变量主要有:

- PATH:会依据UID决定PATH变量要不要含有sbin系统命令目录
- MAIL:依据账号设置好用户的mailbox到`/var/spool/mail/账号名`
- USER:根据用户的账号设置此变量内容
- HOSTNAME:依据主机的hostname命令决定此变量内容
- HISTSIZE:历史命令记录条数。

`/etc/profile`还会去调用外部的设置数据

**~/.bash_profile(login shell才会读)**

bash在读完了整体环境配置的`/etc/profile`并借此调用其他配置文件后，接下来则是会读取用户的个人配置文件。在login shell的bash环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是:

1. ~/.bash_profile
2. ~/.bash_login
3. ~/.profile

其实bash的login shell只会读取上面三个文件的其中一个，而读取的顺序则是依照上面的顺序


**source:读入环境配置文件的命令**

可以通过`source 配置文件名`的方式来将配置文件读入到bash中，而不需要重新登录


**~/.bashrc(non-lgoin shell会读)**

当以non-login shell登陆时，bash还会主动调用`/etc/bashrc`文件，这个文件帮我们定义了下面的数据:

- 依据不同的UID规定umask的值
- 依据不同的UID规定提示符(就是PS1变量)
- 调用/etc/profile.d/*.sh的设置


**其他相关的配置文件**

- `/etc/man.config`:这个文件的内容规定了使用man的时候man page的路径到哪里去寻找
- `~/.bash_histroy`:历史命令记录的地方
- `~/.bash_logout`:记录了当我注销bash后系统再帮我做完师门操作后才离开

##终端机的环境设置:stty,set##

我们可以利用`stty -a`来列出目前环境中所有的按键列表,注意，如果出现`^`，则表示[Ctrl]那个按键的意思

几个重要的代表意义是:

- eof:End of File的意思，代表结束输入
- erase:向后删除字符
- intr:送出一个interrupt(中断)的信号给目前正在运行的程序
- kill:删除目前命令行上的所有文字
- quit:送出一个quit信号给目前正在运行的进程
- start:在某个进程停止后，重新启动它的输出
- stop:停止目前屏幕的输出
- susp:送出一个terminal stop的信号格正在运行的进程

##通配符与特殊符号##

|-------+--------------------------------------------------|
| 符号  |           意义                                   |
|:-----:|:------------------------------------------------:|
|  *    |  代表0个到无穷多个任意字符                       |
|  ？   |  代表一定有一个任意字符                          |
|  []   |  同样代表一定有一个在中括号内的字符(非任意字符)  |
|  [-]  |  代表在编码顺序内的所有字符                      |
|  [^]  |  逆向选择                                        |
|-------+--------------------------------------------------|

bash中的特殊符号,理论上你的"文件名"尽量不要使用到上述的字符

|-------+--------------------------------------------------------------------|
|  符号 |                  内容                                              |
|:-----:|:------------------------------------------------------------------:|
|  #    |  批注符号,这个最常被使用在script中，视为说明，其后的数据均不执行   |
|  \    |  转义符号,将"特殊字符或通配符"还原成一般字符                       |
|  \|    |  管道(pipe)，分隔两个管道命令的界定                                |
|  ;    |  连续命令执行分隔符，连续性命令的界定(注意，与管道命令并不相同)    |
|  ~    |  用户主文件夹                                                      |
|  $    |  使用变量前导符，即是变量之前需要加的变量替代值                    |
|  &    |  作业控制(job control),将命令变成背景下工作                        |
|  !    |  逻辑运算意义上的"非"(not)的意思                                   |
|  /    |  目录符号，路径分隔的符号                                          |
| >,>>  |  数据流重定向，输出导向，分别是"替换"与"累加"                      |
| <,<<  |  数据流重定向，输入导向                                            |
|  ''   |  单引号，不具有变量置换的功能                                      |
|  ""   |  具有变量置换的功能                                                |
|  ``   |  两个"`"中间为可以先执行的命令，也可以使用$()                      |
|  ()   |  在中间为子shell的起始与结束                                       |
|  {}   |  在中间为命令块的组合                                              |
|-------+--------------------------------------------------------------------|

#数据流重定向#

##什么是数据流重定向##

**standard output**:命令所回传的正确的信息

**standard error output**:命令执行失败后，所回传的错误信息

数据流重定向可以将standard output与standard error output分别传送到其他的文件或设备去

重定向的特殊字符:

1. 标准输入(stdin):代码为0，使用<或<<
2. 标准输出(stdout):代码为1，使用>或>>
3. 标准错误输出(stderr):代码为2，使用2>或2>>

重定向文件的创建方式:

1. 该文件若不存在，系统会自动将它创建
2. 当这个文件存在时，若使用的是>或2>，则系统会将这个文件清空，然后再将数据写入
3. 若使用的是>>或2>>，则系统会在这个文件的最下方追加进去

例子:
ll / > ~/rootfile

总结:

- 1>:以覆盖的方式将正确的数据输出到指定的文件或设备上
- 1>>:以累加的方式将正确的数据输出到指定的文件或设备上
- 2>:以覆盖的方式将错误信息的数据输出到指定的文件或设备上
- 2>>:以累加的方式将错误信息的数据输出到指定的文件或设备上

**黑洞**

可以将需要忽略的信息输出导向到`/dev/null`中，这个`/dev/null`可以吃掉任何导向这个设备的信息

**写入到同一个文件**

如果要将正确的返回数据和错误信息的数据写入到同一个文件中，但又没有使用特殊的语法，此时两条数据可能会交叉写入该文件内，造成次序的混乱

{% highlight bash %}
find /home -name .bashrc > list 2> list    #错误
find /home -name .bashrc > list 2>&1       #正确
find /home -name .bashrc &> list           #正确
{% endhighlight %}

**重定向的使用情况**

- 屏幕输出信息很重要，而且我们需要将它保存下来的时候
- 后台执行中的程序，不希望它干扰屏幕正常的输出结果时
- 一些系统的例行命令的执行结果，希望它可以存下来时
- 一些执行命令的可能已知错误信息时，想用`2> /dev/null`将它丢掉时
- 错误信息与正确信息需要分别输出时

##命令执行的判断依据:;,&&,||##

不考虑命令相关性的连续命令执行可以使用分号来分隔命令

**$?命令回传码与&&或||**

若前一个命令执行的结果为正确，在Linux下面会回传一个$?=0的值，那么我们可以通过这个变量来判断命令是否被正确执行。

|----------------+---------------------------------------------------------------------------------------------|
|  命令执行情况  |                  说明                                                                       |
|:--------------:|:-------------------------------------------------------------------------------------------:|
|  cmd1 && cmd2  |  若cmd1执行完毕且正确执行($?=0),则开始执行cmd2\\若cmd1执行完毕且为错误($?!=0),则cmd2不执行  |
|  cmd1 \|\| cmd2  |  若cmd1执行完毕且正确执行($?=0),则cmd2不执行\\若cmd1执行完毕且为错误($?!=0),则开始执行cmd2  |
|----------------+---------------------------------------------------------------------------------------------|

**注意**:&&与\|\|放置的顺序其实是很重要的，因为命令永远是从左往右执行的。通常来说，假设判断式是这样的:

`cmd1 && cmd2 || cmd3`

#管道命令#

bash命令执行的时候有输出的数据会出现，那么如果这群数据必须要经过几道手续之后才能得到我们所想要的格式，这就牵涉到管道(pipe)命令了。
管道命令使用的是"|"这个界定符号

`ls -al /etc | less`

管道命令`|`仅能够处理经由前面一个命令传来的正确信息，也就是standard output的信息，对于standard error 并没有直接处理的能力
每个管道后面接的第一个数据必定是"命令"，而且这个命令必须要能够接受standard input的数据才行，这样的命令可以是"管道命令"
管道命令主要有两个需要注意的地方:

- 管道命令仅会处理standard output，对于standard error output会予以忽略
- 管道命令必须要能够接受来自前一个命令的数据成为standard input继续处理才行

##选取命令:cut,grep##

所谓选取命令，就是将一段数据经过分析后，取出我们所想要的，或者是经由分析关键字，取得我们所想要的那一行
不过需要注意的是，一般来说，选取信息通常是针对"行"来分析的，并不是整篇信息分析的

**cut**

这个命令可以将一段信息的某一段"切"出来，处理的信息以"行"为单位
参数:

- -d:后面接分隔字符，与-f一起使用
- -f:依据-d的分隔符将一段信息切割成为数段，用-f取出第几段的意思
- -c:以字符(characters)的单位取出固定字符区间

cut主要的用途在于将同一行里面的数据进行分解，最常使用在分析一些数据或文字数据的时候。这是因为有时我们会以某些字符当做切割的参数，然后来将数据加以切割，以取得我们所需要的数据。

**grep**

`grep [-acinv] [--color=auto] '查找字符串' filename`
参数:

- -a:将binary文件以text文件的方式查找数据
- -c:计算找到'查找字符串'的次数
- -i:忽略大小写的不同，所以大小写视为相同
- -n:顺便输出行号
- -v:反向选择，即显示出没有'查找字符串'内容的那一行
- --color=auto:可以将找到的关键字部分加上颜色显示

grep是一个很棒的命令，grep可以解析一行文字，取得关键字，若该行又存在关键字，就会整行列出来

##排序命令:sort,wc,uniq##

**sort**

sort是很有趣的命令，它可以帮我们进行排序，而且可以依据不同的数据类型来排序。

**uniq**

uniq可以将重复的数据仅列出一个显示，这个命令用来将重复的行删除掉只显示一个。

**wc**

这个命令可以帮助我们计算输出的信息的整体数据

##双向重定向:tee##

tee命令会同时将数据流送到文件与大屏幕，而输出到屏幕的，其实就是stdout，可以让下个命令继续处理

##字符转换命令:tr,col,join,paste,expand##

**tr**

tr可以用来删除一段信息当中的文字，或者是进行文字信息的替换

**col**

col命令可以将[tab]按键替换成为空格键。col经常被利用于将man page转存为纯文本文件以方便查阅的功能

**join**

将两个文件当中有相同数据的那一行加在一起。需要注意的是，在使用join之前，你所需要处理的文件应该要事先经过排序(sort)处理

**paste**

`paste`直接将两行贴在一起，且中间以[tab]键隔开

**expand**

将[tab]按键转成空格键

##切割命令:split##

如果你有文件太大，导致一些携带式设备无法复制的问题，split可以帮你将一个大文件依据文件大小或行数来切割成为小文件，快速又有效

`split [-bl] file PREFIX`

- -b:后面可接欲切割的文件大小，可加单位，例如b,k,m等
- -l:以行数来进行切割
- PREFIX:代表前导符，可作为切割文件的前导文字


##参数代换:xargs##

这个命令就是在产生某个命令的参数。xarg可以读入stdin的数据，并且以空格符或断行字符进行分辨，将stdin的数据分割成为arguments。因为是以空格符作为分隔，所以，如果有一些文件名或者是其他意义的名词内含有空格符的时候，xargs可能就会误判

##关于减号-的用途##

某些命令需要用到文件名来进行处理，该stdin与stdout可以利用减号"-"来替代


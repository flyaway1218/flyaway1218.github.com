<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Flyaway's Wiki</title>
 <link href="http://username.github.com/atom.xml" rel="self"/>
 <link href="http://username.github.com"/>
 <updated>2013-03-01T14:40:53+08:00</updated>
 <id>http://username.github.com</id>
 <author>
   <name>Flyaway</name>
   <email>flyaway1217@gmail.com</email>
 </author>

 
 <entry>
   <title>《Learning Python》学习笔记——19.模块:宏伟蓝图</title>
   <link href="http://username.github.com/Python/2013/03/01/Learning-Python19.html"/>
   <updated>2013-03-01T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/03/01/Learning-Python19</id>
   <content type="html">&lt;p&gt;模块是最高级别的程序组织单元，它将程序代码和数据封装起来以便重新使用。每一个文件都是一个模块，并且模块导入其他模块之后就可以使用导入模块定义的变量名。模块可以由两个语句和一个重要的内置函数进行处理:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;import&lt;/code&gt;:是客户端(导入者)以一个整体获取一个模块&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;from&lt;/code&gt;:允许客户端从一个模块文件中获取特定的变量名&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;imp.reload&lt;/code&gt;:在不中止Python程序的情况下，提供了一种重新载入模块文件代码的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;为什么使用模块&lt;/h1&gt;
&lt;p&gt;简而言之，模块是通过使用自包含的变量的包，也就是所谓的命名空间提供了将部件组织为系统的简单的方法。在模块导入的时候，模块文件的全局作用域就变成了模块对象的命名空间。最后，Python的模块允许将独立的文件连接成一个更大的程序系统。&lt;/p&gt;

&lt;h1 id=&quot;python&quot;&gt;Python程序架构&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;如何组织一个程序&lt;/h2&gt;
&lt;p&gt;一般来讲，一个Python程序包括了多个含有Python语句的文本文件。程序是作为一个主体的、顶层的文件来构造的，配合有零个或多个支持的文件，在Python中这些文件称作模块。&lt;/p&gt;

&lt;p&gt;在Python中，顶层文件包含了程序的主要控制流程:这就是你需要运行来启动应用的文件。模块文件就是工具的库，顶层文件使用了在模块文件中定义的工具，而这些模块使用了其他模块所定义的工具。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;导入和属性&lt;/h2&gt;
&lt;p&gt;在Python中，交叉文件的模块连接在导入语句执行时才会进行解析，实际效果就是，将模块名(简单地认为是变量名)赋值给载入的模块对象。事实上，在一个读入语句中的模块名有两个作用:识别加载的外部文档，但是它也会变成赋值给被载入模块的变量。模块定义的对象也会在执行时创建，&lt;code&gt;import&lt;/code&gt;会一次运行在目标文档中的语句从而建立其中的内容。&lt;/p&gt;

&lt;p&gt;导入的概念在Python中贯穿始末。任何文件都能够从任何其他文件中导入其工具，导入链要多深就有多深。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;标准库模块&lt;/h2&gt;
&lt;p&gt;Python自带了很多实用的模块，称为标准链接库。这个集合大约有200个模块，包含与平台不相关的常见程序设计任务。这些工具不是Python语言的组成部分，但是，你可以在任何安装了标准Python的情况下，导入适当的模块来使用。&lt;/p&gt;

&lt;h1 id=&quot;import&quot;&gt;import如何工作&lt;/h1&gt;
&lt;p&gt;在Python中，导入并非只是把一个文件文本插入到另一个文件而已。导入其实是运行时的匀速，程序第一次导入指定文件时，会执行三个步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;找到模块文件。&lt;/li&gt;
  &lt;li&gt;编译成位码(需要时)&lt;/li&gt;
  &lt;li&gt;执行模块的代码来创建其所定义的对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意:这三个步骤只在程序执行时，模块第一次导入时才会进行。在这之后，导入相同模块时，会跳过这个三步骤，而只提取内存中已经加载的模块对象。&lt;/strong&gt;从技术上讲，Python把载入的模块存储到一个名为&lt;code&gt;sys.modules&lt;/code&gt;的表中，并在一次导入操作的开始时检查该表，如果模块不存在，将会启动上述三个步骤的过程。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;搜索&lt;/h2&gt;
&lt;p&gt;在使用&lt;code&gt;import&lt;/code&gt;时，只能列出简单名称。路径和后缀是可以省略掉的，因为Python使用了标准模块搜索路径来找出&lt;code&gt;import&lt;/code&gt;语句所对应的模块文件。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;编译(可选)&lt;/h2&gt;
&lt;p&gt;遍历模块搜索，找到符合import语句的源代码文件后，Python会检查文件的时间戳，如果发现字节码比源代码文件旧，就会在程序运行时自动重新生成字节码；如果字节码不必源文件旧，就会跳过编译这个过程。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;运行&lt;/h2&gt;
&lt;p&gt;import操作的最后步骤是执行模块的字节码。文件中的所有语句都会依次执行，从头至尾。&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;模块搜索路径&lt;/h1&gt;
&lt;p&gt;Python的模块搜索路径是下面这些组件组合而成的结果，其中有些进行了预定义，而其中有些你可以进行调整来告诉Python去哪里搜索。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;程序的主目录&lt;/li&gt;
  &lt;li&gt;PYTHONPATH目录(如果设置了的话)&lt;/li&gt;
  &lt;li&gt;标准链接库目录&lt;/li&gt;
  &lt;li&gt;任何.pth文件的内容(如果存在的话)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这四个组件组合起来就变成了&lt;code&gt;sys.path&lt;/code&gt;，它是目录名称字符串的列表。上面的1和3是自动定义的，2和4可以用来进行扩展。需要特别说明的是.pth文件，你可以在.pth的文本文件中一行一行地列出需要添加到模块搜索路径中的目录，它是PYTHONPATH设置的一种替代方案。&lt;/p&gt;

&lt;h2 id=&quot;syspath&quot;&gt;sys.path列表&lt;/h2&gt;
&lt;p&gt;如果你想知道模块搜索路径在机器上的实际配置，可以通过打印内置的sys.path列表来查看这个路径。目录名称字符串列表就是Python内部实际的搜索路径。导入时，Python会由左至右搜索这个列表中的每个目录。Python在程序启动时进行配置，自动将顶级文件的主目录、任何PYTHONPATH目录、已经创建的任何.pth文件路径的内容，以及标准库目录合并，结果就是sys.path中的目录名的字符串的列表。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;模块文件的选择&lt;/h2&gt;
&lt;p&gt;Python总是由左至右搜索sys.path的，并且加载模块搜索路径那些目录中最先出现的相符文件。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;高级的模块选择概念&lt;/h2&gt;
&lt;p&gt;一般来说，导入工作就是在机器上搜索并载入文件，然而重新定义Python中import操作所做的事也是有可能的，也就是使用所谓的导入钩子(import hook)。这些钩子可以让导入做各种有用的事情。&lt;/p&gt;

&lt;h2 id=&quot;distutils&quot;&gt;第三方工具:distutils&lt;/h2&gt;
&lt;p&gt;本章对模块搜索路径设置的说明，主要是针对自己编写的用户定义的源代码。Python的第三方扩展，通常是使用标准链接库中的distutils工具来自动安装，所以不需要路径设置，就能使用第三方库。&lt;/p&gt;

&lt;p&gt;使用distutils的系统一般都附带setup.py脚本，执行这个脚本可以进行程序的安装。这个脚本会导入并使用distutils模块，将这种系统放在属于模块自动搜索路径的目录内(通常是在Python安装目录树下的Lib\site-packages子目录中)。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——18.迭代和解析，第二部分</title>
   <link href="http://username.github.com/Python/2013/02/26/Learning-Python18.html"/>
   <updated>2013-02-26T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/02/26/Learning-Python18</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;回顾列表解析:函数式编程工具&lt;/h1&gt;

&lt;h2 id=&quot;map&quot;&gt;列表解析与map&lt;/h2&gt;
&lt;p&gt;列表解析在一个序列上的值应用一个任意表达式，将其结果搜集到一个新的列表中并返回。从语法上说，列表解析是由方括号封装起来的(为了提醒你它们构造了一个列表)。它们的简单形式是在方括号中编写一个表达式，Python之后将这个表达式的应用循环中每次迭代的结果搜集起来。例如，假如我们希望搜集字符串中的所有字符的ASCII码，可以这样做:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;c&quot;&gt;#循环的方法&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;spam&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#map函数的方法&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;spam&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#列表解析&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;spam&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;增加测试和嵌套循环&lt;/h2&gt;
&lt;p&gt;其实，列表解析还要比上面说的通用的多，我们可以在for之后编写一个if分支，用来增加选择逻辑。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;c&quot;&gt;#列表解析&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#map&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述的两行代码都是搜集了0~9中的偶数的平方和，可以很明显的看到，完成同样的功能，列表解析的语句简单地多。&lt;/p&gt;

&lt;p&gt;实际上，列表解析还能够更加通用。你可以在一个列表解析中编写任意数量的嵌套的for循环，并且每一个都有可选的关联的if测试。通用结构如下所示:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;expression&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterable1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comdition1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterable2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;targetN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterableN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conditionN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当for分句嵌套在列表解析中时，它们工作起来就像等效的嵌套的for循环语句。例如，如下的代码:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;与下面如此冗长的代码有相同的效果:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;列表解析和矩阵&lt;/h2&gt;
&lt;p&gt;使用Python编写矩阵的一个基本的方法就是使用嵌套的列表结构，例如，下面的代码定义了两个3x3的矩阵:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;列表解析也是处理这样结构的强大工具，它们能够自动扫描行和列。&lt;/p&gt;

&lt;p&gt;取出第二列的所有元素:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;#[2,5,8]&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#[2,5,8]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;取出对角线上的元素:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))]&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;#[1,5,9]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;混合多个矩阵，下面的代码创建了一个单层的列表，其中包含了矩阵对元素的乘积。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;#[2,4,6,12,15,18,28,32,36]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面的代码再复杂一点，构造一个嵌套的列表，其中的值与上面的一样:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;#[[2,4,6],[12,15,18],[28,32,36]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的最后一个比较难于理解，它等同于如下基于语句的代码:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;理解列表解析&lt;/h2&gt;
&lt;p&gt;基于对运行在当前Python版本下的测试，map调用比等效的for循环要快两倍，而列表解析往往比map调用要稍快一些。速度上的差距来自底层实现，map和列表解析是在解释器中以C语言的速度来运行的，比Python的for循环在PVM中步进要快得多。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;重访迭代器:生成器&lt;/h1&gt;
&lt;p&gt;如今的Python对延迟提供更多的支持——它提供了工具在需要的时候才产生结果，而不是立即产生结果。特别地，有两种语言结构尽可能地拖延结果创建。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;生成器函数:&lt;/strong&gt;编写为常规的def语句，但是是使用yield语句一次返回一个结果，在每个结果之间挂起和继续它们的状态。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;生成器表达式:&lt;/strong&gt;生成器表达式类似于上一小节的列表解析，但是，它们返回按需产生结果的一个对象，而不是构建一个结果列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于上面二者都不会一次性构建一个列表，它们节省了内存空间，并且允许计算时间分散到各个结果请求。&lt;/p&gt;

&lt;h2 id=&quot;yield-vs-return&quot;&gt;生成器函数:yield VS return&lt;/h2&gt;
&lt;p&gt;之前我们写的函数都是接受输入参数并立即返回单个结果的常规函数，然而，也有肯能来编写可以送回一个值并随后从其退出的地方继续的函数。这样的函数叫做生成器函数，因为它们随着时间产生值的一个序列。&lt;/p&gt;

&lt;p&gt;一般来说，生成器函数和常规函数一样，并且，实际上也是用常规的def语句编写的。然后，当创建时，它们自动实现迭代协议，以便可以出现在迭代背景中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;状态挂起&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和返回一个值并退出的函数不同，生成器函数自动在生成值的时刻挂起并继续函数的执行。因此，它们对于提前计算整个一系列值以及在类中手动保存和恢复状态都很有用。由于生成器函数在挂起时保存的状态包含了它们的整个本地作用域，当函数恢复时，它们的本地变量保持了信息并且使其可用。&lt;/p&gt;

&lt;p&gt;生成器函和常规函数之间的主要不同之处在于，生成器yield一个值，而不是return一个值。yield语句挂起该函数并向调用者发送一个值，但是，保留足够的状态以使得函数从它离开的地方继续。当继续时，函数在上一个yield返回立即继续执行。从函数角度来看，这允许其代码随着时间产生一系列的值，而不是一次计算它们并在诸如列表的内容中送回它们。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;迭代协议整合&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可迭代对象定义了一个&lt;code&gt;__next__&lt;/code&gt;方法，它要么返回迭代中的下一项，要么引发一个特殊的StopIteration异常来终止迭代。一个对象的迭代器用iter内置函数接受。&lt;/p&gt;

&lt;p&gt;如果支持该协议的话，Python的for循环以及其他的迭代技术，使用这种迭代协议来便利一个序列或值生成器；如果不支持，跌打返回去重复索引序列。&lt;/p&gt;

&lt;p&gt;要支持这一协议，函数包含一条yield语句，该语句特别编译为生成器。当调用时，它们返回一个迭代器对象，该对象支持用一个名为&lt;code&gt;__next__&lt;/code&gt;的自动创建的方法来继续执行的接口。生成器函数也可能有一条return语句，总是在def语句块的末尾，直接终止值的生成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生成器函数应用&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gensquares&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个函数在每次循环时都会产生一个值，之后将其返回给它的调用者。当它被暂定后，它的上一个状态保存了下来	并且在yield语句之后把控制器马上回收。它允许函数避免临时再做所有的工作，当结果的列表很大或者在处理每一个结果都需要很多时间时，这一点尤其重要。生成器将在loop迭代中处理一系列值的时间分布开来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;扩展生成器函数协议:send和next&lt;/strong&gt;
在Python2.5中，生成器函数协议中增加了一个send方法。send方法生成一系列结果的下一个元素，这一点像&lt;code&gt;__next__&lt;/code&gt;方法一样，但是它提供了一种调用者与生成器之间进行通信的方法，从而能够影响它的操作。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;G&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;#0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;77&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;#77 1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;88&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;#88 2&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;#None 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的代码比较难于理解，而且书上的翻译比较劣质，没看懂。在网上查了一些资料，结合自己的理解，上述代码的运行过程应该是这样的:生成了一个函数对象，赋值给了G，然后调用了&lt;code&gt;next()&lt;/code&gt; 函数，生成了生成器的第一个值0，所以返回值是0。此时函数运行到yield语句，碰到yield语句后立即挂起函数，保存状态，等待下一次迭代。程序中之后又调用了&lt;code&gt;send()&lt;/code&gt;方法，将77传递给了yield语句，yield语句将&lt;code&gt;send()&lt;/code&gt;传递过来的值(此处是77)赋值给X，然后打印出来。然后函数继续运行，直到再次碰到yield，此时是第二次碰到yield，所以返回了1，接着函数又被挂起，等待下一次迭代。接着又调用了&lt;code&gt;send()&lt;/code&gt;，同上次调用一样，将传进的参数(此处是88)作为yield的返回值赋值给X，然后打印，接着继续运行函数，直到再次碰到yield，此时是第三次，因此输出2。最后又再次调用了&lt;code&gt;next()&lt;/code&gt;函数，其实&amp;rsquo;next()&amp;rsquo;函数就是传递了一个None,因此，我们得到的结果是None和3。&lt;/p&gt;

&lt;p&gt;此处需要注意的是，其实&lt;code&gt;next()&lt;/code&gt;和&lt;code&gt;send(None)&lt;/code&gt;是等价的。通过&lt;code&gt;send()&lt;/code&gt;方法，我们就能够和生成器实现通信。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;生成器表达式：迭代器遇到列表解析&lt;/h2&gt;
&lt;p&gt;在最新版的Python中，迭代器和列表解析的概念形成了这种语言的一个新特性——生成器表达式。从语法上讲，生成器表达式就像一般的列表解析一样，但是它们是扩在&lt;strong&gt;圆括号&lt;/strong&gt;中而不是&lt;strong&gt;方括号&lt;/strong&gt;中的。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#List comprehension:build a list&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#Genterator expression:make an iterable&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从执行过程上来讲，生成器表达式很不相同:不是在内存中构建结果，而是返回一个生成器对象，这个对象将会支持迭代协议。&lt;/p&gt;

&lt;p&gt;生成器表达式大体上可以认为是对内存空间的优化，他们不需要像方括号的列表解析一样，一次构造出整个结果列表。它们在实际中运行起来可能稍慢一些，所以它们可能只对于非常庞大的结果集合的运算来说是最优的选择。&lt;/p&gt;

&lt;h2 id=&quot;vs&quot;&gt;生成器函数VS生成器表达式&lt;/h2&gt;
&lt;p&gt;生成器函数和生成器表达式自身都是迭代器，并由此只支持一次活跃迭代，我们无法有在结果集中位于不同位置的多个迭代器。&lt;/p&gt;

&lt;h1 id=&quot;python30&quot;&gt;Python3.0解析语法概括&lt;/h1&gt;
&lt;p&gt;我们已经在本章中关注过列表解析和生成器，但是，别忘了，还有两种在Python3.0中可用的解析表达式形式:集合解析和字典解析。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;#List comprehension:build list&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;#Generator expression:produces items&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;#Set comprehension:new in 3.0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#Directionary comprehension:new in 3.0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是，上面最后两种表达方式都是一次性构建所有对象的，它们没有根据需要产生结果的概念。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;列表解析、集合解析、字典解析都是一次性构建对象的，直接返回的。&lt;/li&gt;
  &lt;li&gt;生成器函数和生成器表达式不是在内存中构建结果的，它们是返回一个生成器对象，这个对象支持迭代协议，根据调用者需要产生结果。&lt;/li&gt;
  &lt;li&gt;集合解析、字典解析都支持嵌套相关的if子句从结果中过滤元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-6&quot;&gt;函数陷阱&lt;/h1&gt;

&lt;h2 id=&quot;section-7&quot;&gt;本地变量是静态检测的&lt;/h2&gt;
&lt;p&gt;Python定义的在一个函数中进行分配的变量名时默认为本地变量的，它们存在于函数的作用域并只在函数运行时存在。Python静态检测Python的本地变量，当编译def代码时，不是通过发现赋值语句在运行时进行检测的。被赋值的变量名在函数内部是当做本地变量来对待的，而不是仅仅在赋值以后的语句才被当做是本地变量。&lt;/p&gt;

&lt;h2 id=&quot;return&quot;&gt;没有return语句的函数&lt;/h2&gt;
&lt;p&gt;在Python函数中，return(以及yield)语句是可选的。从技术上说，所有的函数都会返回了一个值，如果没有提供return语句，函数将自动返回None对象。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——17.函数的高级话题</title>
   <link href="http://username.github.com/Python/2013/02/22/Learning-Python17.html"/>
   <updated>2013-02-22T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/02/22/Learning-Python17</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;函数设计概念&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;耦合性:对于输入使用参数并且输出使用return语句。&lt;/li&gt;
  &lt;li&gt;耦合性:只有在真正必要的情况下使用全局变量。&lt;/li&gt;
  &lt;li&gt;耦合性:不要改变可变类型的参数，除非调用者希望这样做。&lt;/li&gt;
  &lt;li&gt;聚合性:每一个函数都应该有一个单一的、统一的目标。&lt;/li&gt;
  &lt;li&gt;大小:每一个函数应该相对较小。&lt;/li&gt;
  &lt;li&gt;耦合:避免直接改变在另一个模块文件中的变量。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-1&quot;&gt;函数对象:属性和注解&lt;/h1&gt;

&lt;h2 id=&quot;section-2&quot;&gt;间接函数调用&lt;/h2&gt;
&lt;p&gt;由于Python函数是对象，我们可以编写通用的处理他们的程序。函数对象可以赋值给其他的名字、传递给其他函数、嵌入到数据结构、从一个函数返回给另一个函数等等，就好像它们是简单的数字或字符串。&lt;/p&gt;

&lt;p&gt;把函数赋值给其他变量:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Indirect call!&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#Prints:Indirect call!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;传递给其他函数:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;indirect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;indirect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Argument call&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#Prints:Argument call&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;把函数对象填入到数据结构中:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Spam!&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Ham!&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上述的代码中可以看到，Python是非常灵活的！&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;函数内省&lt;/h2&gt;
&lt;p&gt;由于函数是对象，我们可以用用常规的对象工具来处理函数。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;内省工具允许我们探索实现细节，例如函数已经附加了代码对象，代码对象提供了函数的本地变量和参数等方面的细节：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__code__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__code__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;co_varnames&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__code__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;co_argument&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;工具编写者可以利用这些信息来管理函数。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;函数属性&lt;/h2&gt;
&lt;p&gt;函数对象不仅局限于上一小节中列出的系统定义的属性，我们也可以向函数附加任意的用户定义的属性:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Button-Press&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样的属性可以用来直接把状态信息附加到函数对象，而不必使用全局、非本地和类等其他技术。和非本地不同，这样的属性信息可以在函数自身的任何地方访问。这种变量的名称对于一个函数来说是本地的，但是，其值在函数退出后仍然保留。属性与对象相关而不是与作用域相关，但直接效果是类似的。&lt;/p&gt;

&lt;h2 id=&quot;python30&quot;&gt;Python3.0中的函数注解&lt;/h2&gt;
&lt;p&gt;在Python3.0也可以给函数对象附加注解信息——与函数的参数相关的任意的用户定义的数据。Python为声明注解提供了特殊的语法，但是，它自身不做任何事情；注解完全是可选的，并且，出现的时候只是直接附加到函数对象的__annotations__属性以供其他用户使用。&lt;/p&gt;

&lt;p&gt;从语法上讲，函数注解编写在def头部行，对于参数，它们出现在紧随参数名之后的冒号之后；对于返回值，它们编写于紧跟在参数列表之后的一个&lt;code&gt;-&amp;gt;&lt;/code&gt;之后。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;spam&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注解和没注解过的函数在功能和使用上完全一样，只不过，注解过的函数，Python会将它们的注解的数据收集到字典中并将它们附加到函数对象自身。参数名变成键，如果编写了返回值注解的话，它存储在键&lt;code&gt;return&lt;/code&gt;下，而注解的值则是赋给了注解表达式的结果:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__annotations__&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;#Prints:{&amp;#39;a&amp;#39;:&amp;#39;spam&amp;#39;,&amp;#39;c&amp;#39;:&amp;lt;class &amp;#39;float&amp;#39;&amp;gt;,&amp;#39;b&amp;#39;:(1,10),&amp;#39;return&amp;#39;:&amp;lt;class &amp;#39;int&amp;#39;&amp;gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果编写了注解的话，仍然可以对参数使用默认值，例如:&lt;code&gt;a:'spam'=4&lt;/code&gt; 意味着参数a的默认值是4，并且用字符串&amp;rsquo;spam&amp;rsquo;注解它。&lt;/li&gt;
  &lt;li&gt;在函数头部的各部分之间使用空格是可选的。&lt;/li&gt;
  &lt;li&gt;注解只在&lt;code&gt;def&lt;/code&gt;语句中有效。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;lambda&quot;&gt;匿名函数:lambda&lt;/h1&gt;
&lt;p&gt;除了&lt;code&gt;def&lt;/code&gt;语句之外，Python还提供了一种生成函数对象的表达式形式。由于它与LISP语言中的一个工具很相似，所以称为lambda。就像&lt;code&gt;def&lt;/code&gt;一样，这个表达式创建了一个之后能够调用的函数，但是它返回了一个函数而不是将这个函数赋值给一个变量名。这也就是lambda有时叫做匿名函数的原因。实际上，它们常常以一个行内函数定义的形式使用，或者用作推迟执行一些代码。&lt;/p&gt;

&lt;h2 id=&quot;lambda-1&quot;&gt;lambda表达式&lt;/h2&gt;
&lt;p&gt;lambda的一般形式是关键字lambda，之后是一个或多个参数，紧跟的是一个冒号，之后是一个表达式：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argument1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argument2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argumentN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expression&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由lambda表达式所返回的函数对象与由def创建并赋值后的函数对象工作起来是完全一样的，但是lambda有一些不同之处让其在扮演特定的角色时很有用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;lambda是一个表达式，而不是一个语句。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;lambda的主体是一个单个的表达式，而不是一个代码块。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一下两段代码生成了同样功能的函数:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                   &lt;span class=&quot;c&quot;&gt;#Return 9&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                      &lt;span class=&quot;c&quot;&gt;#Return 9&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;默认参数也能在lambda中使用&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;fee&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;fie&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;foe&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;wee&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                      &lt;span class=&quot;c&quot;&gt;#Prints:&amp;#39;weefiefoe&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在lambda主体中的代码像在def内的代码一样都遵循相同的作用域查找法则。&lt;/p&gt;

&lt;h2 id=&quot;lambda-2&quot;&gt;为什么要使用lambda&lt;/h2&gt;
&lt;p&gt;通常来说，lambda起到了一种函数速写的作用，允许在使用的代码内嵌入一个函数的定义。它们总是可选的，因为总是能够用def来代替。&lt;/p&gt;

&lt;p&gt;lambda通常用来编写跳转表:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;#Prints:4,8,16&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;#Prints:9&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实际上，我们可以用Python中的字典或者其他数据结构来构建更多种类的行为表:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;got&amp;#39;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;already&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;&amp;#39;got&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;&amp;#39;one&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;#Prints:8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样编写代码可以使字典成为更加通用的多路分支工具。&lt;/p&gt;

&lt;p&gt;最后需要注意的是，lambda也是可以嵌套的&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;#Prints:103&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;map&quot;&gt;在序列中映射函数:map&lt;/h1&gt;
&lt;p&gt;map函数会对一个序列对象中的每个元素应用被传入的函数，并且返回一个包含了所有函数调用结果的一个列表。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;counters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;#[11,12,13,14]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于map期待传入一个函数，它恰好是lambda最常出现的地方之一。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;#[11,12,13,14]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;filterreduce&quot;&gt;函数式编程工具:filter和reduce&lt;/h1&gt;
&lt;p&gt;在Python内置函数中，map函数是用来进行函数式编程的这类工具中最简单的内置函数代表。所谓的函数式编程就是对序列应用一些函数的工具。例如过滤出一些元素(filter)，以及对每对元素都应用函数并运行到最后的结果(reduce)。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;#[1,2,3,4]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;序列中的元素若其返回值是真的话，将会被加入到结果列表中。&lt;/p&gt;

&lt;p&gt;reduce接受一个迭代器来处理，但是，它自身不是一个迭代器，它返回一个单个的结果。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;functools&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reduce&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;#Import in 3.0,not in 2.6&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;#Return:10&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;#Return:24&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面两个reduce调用，计算了一个列表中所有元素的累加和与累积乘积。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——16.参数</title>
   <link href="http://username.github.com/Python/2013/02/22/Learning-Python16.html"/>
   <updated>2013-02-22T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/02/22/Learning-Python16</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;传递参数&lt;/h1&gt;
&lt;p&gt;函数传递参数时的一些简要的关键点:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;参数的传递是通过自动将对象赋值给本地变量名来实现的。所有的参数实际上都是通过指针进行传递的，作为参数被传递的对象从来不自动拷贝。&lt;/li&gt;
  &lt;li&gt;在函数内部的参数名的赋值不会影响调用者。&lt;/li&gt;
  &lt;li&gt;改变函数的可变对象参数的值会对调用者有影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际上，Python的参数传递模型和C语言的相当相似:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;不可变参数&amp;rdquo;通过值&amp;rdquo;进行传递。&lt;/strong&gt;像整数和字符串这样的对象是通过对象引用而不是拷贝进行的，但是因为不论怎么样都不可能在原处改变不可变对象，实际的效果就很像创建了一份拷贝。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可变对象是通过&amp;rdquo;指针&amp;rdquo;进行传递的。&lt;/strong&gt;这就意味着，可变对象能够在函数内部进行原处修改。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;避免可变参数的修改&lt;/h2&gt;
&lt;p&gt;避免参数的修改有很多种方式:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;传递参数时，传递一个拷贝:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;changer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;函数内部进行拷贝&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;changer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;将可变对象转化为不可变对象&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;changer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;对参数输出进行模拟&lt;/h2&gt;
&lt;p&gt;对于参数的返回值有一个小技巧:因为&lt;code&gt;return&lt;/code&gt;能够返回任意种类的对象，如果这些值封装进一个元组或其他的集合类型，那么它也能够返回多个值。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;multiple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#Return new values in a tuple&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码貌似返回了两个值，其实只有一个:一个包含了2个元素的元组，它的括号是可以省略的。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;特定的参数匹配模型&lt;/h1&gt;

&lt;h2 id=&quot;section-4&quot;&gt;基础知识&lt;/h2&gt;
&lt;p&gt;匹配模型的大纲:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;位置:从左至右进行匹配。&lt;/li&gt;
  &lt;li&gt;关键字参数:通过参数名进行匹配。(调用者可以定义哪一个函数接受这个值，通过在调用时使用参数的变量名，使用&lt;code&gt;name=value&lt;/code&gt;这种语法。)&lt;/li&gt;
  &lt;li&gt;默认参数:为没有传入值的参数定义参数值。&lt;/li&gt;
  &lt;li&gt;可变参数:搜集任意多基于位置或关键字的参数。&lt;/li&gt;
  &lt;li&gt;可变参数解包:传递任意多的基于位置或关键字的参数。&lt;/li&gt;
  &lt;li&gt;Keyword-only参数:参数必须按照名称传递。(只存在于Python3.0中)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;匹配语法&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;语法&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;位置&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;　　解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;func(value)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;调用者&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;常规参数:通过位置进行匹配。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;func(name=value)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;调用者&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;关键字参数:通过变量名匹配。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;func(*sequence)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;调用者&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;以name传递所有的对象，并作为独立的基于位置的参数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;func(**dict)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;调用者&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;以name成对的传递所有的关键字/值，并作为独立的关键字参数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;def func(name)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;函数&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;常规参数:通过位置或变量名进行匹配。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;def func(name=value)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;函数&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;默认参数值，如果在调用中传递的话。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;def func(*name)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;函数&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;匹配并收集(在元组中)所有包含位置的参数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;def func(**name)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;函数&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;匹配并收集(在字典中)所有包含位置的参数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;def func(*args,name)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;函数&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;参数必须在调用中按照关键字传递。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;def func(*,name=value)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;函数&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　参数必须在调用中按照关键字传递。(Python3.0)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;相应的说明:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在函数的调用中(表中的前4行)，简单的通过变量名位置进行匹配，但是使用&lt;code&gt;name=value&lt;/code&gt;的形式告诉Python依照变量名进行匹配，这些叫做关键字参数。在调用中使用*sequence或**dict允许我们在一个序列或字典中相应地封装任意多的位置相关或者关键字的对象，并且在将他们传递给函数的时候，将它们解包为分开的、单个的参数。&lt;/li&gt;
  &lt;li&gt;在函数的头部，一个简单的变量名时通过位置或变量名进行匹配的(取决于调用者是如何传递给它参数的)，但是&lt;code&gt;name=value&lt;/code&gt;的形式定义了默认的参数值。&lt;code&gt;*name&lt;/code&gt;的形式收集了任意的额外不匹配的参数到元组中，并且&lt;code&gt;**name&lt;/code&gt;的形式将会手机额外的关键字参数到字典中。在Python3.0及其以后的版本中，跟在&lt;code&gt;*name&lt;/code&gt;或一个单独的&lt;code&gt;*&lt;/code&gt;之后的、任何正式的或默认的参数名称，都是keyword-only参数，并且必须在调用时按照关键字传递。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;细节&lt;/h2&gt;
&lt;p&gt;在使用混合的参数模型的时候，Python将会遵循下面有关顺序的法则。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在函数调用中，参数必须以此顺序出现:任何位置参数(value)，后面跟着任何关键字参数(name=value)和&lt;code&gt;*sequence&lt;/code&gt;形式的组合，后面跟着&lt;code&gt;**dict&lt;/code&gt;形式。&lt;/li&gt;
  &lt;li&gt;在函数头部，参数必须以此顺序出现：任何一般参数(name)，紧跟着任何默认参数(name=value)，后面是&lt;em&gt;name(在Python3.0中是&lt;/em&gt;)形式，后面跟着任何name或name=value keyword-only参数(Python3.0中)，后面跟着&lt;code&gt;**name&lt;/code&gt;形式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在调用和函数头部中，如果出现&lt;code&gt;**arg&lt;/code&gt;形式的话，都必须出现在最后。&lt;/p&gt;

&lt;p&gt;Python内部是使用以下的步骤来在赋值前进行参数匹配的:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过位置分配非关键字参数。&lt;/li&gt;
  &lt;li&gt;通过匹配变量名分配关键字参数。&lt;/li&gt;
  &lt;li&gt;其他额外的非关键字分配到&lt;code&gt;*name&lt;/code&gt;元组中。&lt;/li&gt;
  &lt;li&gt;其他额外的关键字参数分配到&lt;code&gt;**name&lt;/code&gt;字典中。&lt;/li&gt;
  &lt;li&gt;用默认值分配给在头部未得到分配的参数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在这之后，Python会进行检测，确保每个参数只传入了一个值。如果不是这样的话，将会发生错误。当所有匹配都完成了，Python把传递给参数名的对象赋值给它们。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;关键字参数和默认参数的实例&lt;/h2&gt;
&lt;p&gt;如果没有使用任何特殊的匹配语法，Python默认会通过位置从左至右匹配变量名。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;#Prints 1,2,3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;关键字参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;关键字参数允许通过变量名进行匹配，而不是通过位置。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#Prints 1,2,3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;默认参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认参数允许创建函数可选的参数。如果没有传入值的话，在函数运行前，参数就被赋了默认值。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;#Prints 1,2,3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;#Prints 1,4,3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;#Prints 1,2,6&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;关键字参数和默认参数的混合&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;totast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ham&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;totast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ham&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                   &lt;span class=&quot;c&quot;&gt;#Ouput:(1,2,0,0)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ham&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;#Ouput:(1,0,0,1)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;#Ouput:(1,0,0,0)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#Ouput:(3,2,1,0)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;#Ouput:(1,2,3,4)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-8&quot;&gt;任意参数的实例&lt;/h2&gt;
&lt;p&gt;最后两种匹配扩展，&lt;code&gt;*&lt;/code&gt;和&lt;code&gt;**&lt;/code&gt;，是让函数支持接收任意数目的参数的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;收集参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在函数定义中，在元组中收集不匹配的位置参数。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当这个函数调用时，Python将所有位置相关的参数收集到一个新的元组中，并将这个元组赋值给变量args。因此它是一个一般的元组对象，能够进行索引或迭代。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;**&lt;/code&gt;特性类似，但是它只对关键字参数有效。将这些关键字参数传递给一个新的字典，这个字典之后将能够通过一般的字典工具进行处理。在这种情况下，&lt;code&gt;**&lt;/code&gt;允许将关键字参数转化为字典，你能够在之后使用键调用进行步进或字典迭代。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;#Prints:1 (2,3) {&amp;#39;x&amp;#39;:2,&amp;#39;y&amp;#39;:1}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解包参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在最新的Python版本中，我们在调用函数时能够使用&lt;code&gt;*&lt;/code&gt;语法。在这种情况下，它与函数定义的意思相反。它会解包参数的集合，而不是创建参数的集合。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;#Prints 1,2,3,4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;相似的，在函数调用时，&lt;code&gt;**&lt;/code&gt;会以键/值对的形式解包一个字典，使其成为独立的关键字参数。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;#Prints 1,2,3,4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;别混淆函数头部和函数调用时&lt;code&gt;*&lt;/code&gt;/&lt;code&gt;**&lt;/code&gt;的语法:在头部，它意味着收集任意多的参数，而在调用时，它解包任意数量的参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应用函数通用性&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;python30-keyword-only&quot;&gt;Python3.0 Keyword-Only参数&lt;/h2&gt;
&lt;p&gt;Python3.0把函数头部的排序规则通用化了，允许我们指定keyword-only参数——即必须只按照关键字传递并且不会由一个位置参数来填充的参数。&lt;/p&gt;

&lt;p&gt;从语法上讲，keyword-only参数编码为命名的参数，出现在参数列表中的*args之后。所有这些参数都必须在调用中使用关键字语法来传递。&lt;/p&gt;

&lt;p&gt;我们也可以在参数列表中使用一个&lt;code&gt;*&lt;/code&gt;字符，来表示一个函数不会接受一个变量长度的参数列表，而是仍然期待跟在&lt;code&gt;*&lt;/code&gt;后面的所有参数都作为关键字传递。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kwonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;kwonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#Prints:1,2,3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;kwonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;#Prints:1,2,3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;kwonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;#Error!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码中，b和c必须按照关键字传递，不允许其他额外的位置传递。&lt;/p&gt;

&lt;p&gt;另外，默认函数仍然对keyword-only参数有效，所以，实际上，带有默认值的keyword-only参数都是可选的，但是，那些没有默认值的keyword-only参数真正地变成了函数必需的keyword-only参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;排序规则&lt;/strong&gt;
最后，注意keyword-only参数必须在一个单个星号后指定，而不是两个星号——命名的参数不能出现在&lt;code&gt;**args&lt;/code&gt;任意关键字形式的后面，并且一个&lt;code&gt;**&lt;/code&gt;不能独自出现在参数列表中。这两种做法将产生错误。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kwonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;#Error!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kwonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;#Error!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这就意味着，在一个函数的头部，keyword-only参数必须编写在&lt;code&gt;**args&lt;/code&gt;任意关键字形式之前，且在&lt;code&gt;*args&lt;/code&gt;任意位置形式之后。&lt;/p&gt;

&lt;p&gt;实际上，在函数调用中，类似的排序规则也是成立的：当传递keyword-only参数的时候，它们必须出现在一个&lt;code&gt;**args&lt;/code&gt;形式之前。keyword-only参数可以编写在&lt;code&gt;*arg&lt;/code&gt;之前或者之后，并且可能包含在&lt;code&gt;**args&lt;/code&gt;中:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;#Prints:1 (2,3) 6 {&amp;#39;x&amp;#39;:4,&amp;#39;y&amp;#39;:5}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#Error!&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#Prints:1 (2,3) 7 {&amp;#39;x&amp;#39;:4,&amp;#39;y&amp;#39;:5}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#Prints:1 (2,3) 7 {&amp;#39;x&amp;#39;:4,&amp;#39;y&amp;#39;:5}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#Prints:1 (2,3) 7 {&amp;#39;x&amp;#39;:4,&amp;#39;y&amp;#39;:5}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>《鸟哥的Linux私房菜:基础篇》学习笔记——5.Linux文件与目录管理</title>
   <link href="http://username.github.com/LinuxBase/2013/02/14/Learning-Linux-Base5.html"/>
   <updated>2013-02-14T00:00:00+08:00</updated>
   <id>http://username.github.com/LinuxBase/2013/02/14/Learning-Linux-Base5</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;目录与路径&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;相对路径与绝对路径&lt;/h2&gt;

&lt;p&gt;绝对路径:路径的写法一定由根目录/写起。&lt;/p&gt;

&lt;p&gt;相对路径:路径的写法不是由/写起。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;目录的相关操作&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;特殊的目录&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;符号&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;意义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;代表此层目录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;..&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;代表上一层目录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;代表前一个工作目录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;~&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;代表“目前用户身份”所在的主文件夹&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;~account&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;代表account这个用户的主文件夹&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;常用的处理目录的命令:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cd:切换目录&lt;/li&gt;
  &lt;li&gt;pwd:显示当前目录&lt;/li&gt;
  &lt;li&gt;mkdir:新建一个新的目录&lt;/li&gt;
  &lt;li&gt;rmdir:删除一个空的目录&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;详细的命令解释与说明，可以参看《鸟哥基础篇》P163~165&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;path&quot;&gt;关于执行文件路径的变量:$PATH&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不同身份用户默认的PATH不同，默认能够随意执行的命令也不同&lt;/li&gt;
  &lt;li&gt;PATH是可以被修改的&lt;/li&gt;
  &lt;li&gt;本目录(.)最好不要被放置到PATH中&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-3&quot;&gt;文件与目录管理&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;cp&lt;/strong&gt;:复制文件或目录&lt;/p&gt;

&lt;p&gt;参数说明:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-p:连同文件的属性一起复制过去，而非使用默认属性(备份常用)&lt;/li&gt;
  &lt;li&gt;-u:若destination比source旧才更新destination&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-4&quot;&gt;文件内容查阅&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;cat:由第一行开始显示文件内容&lt;/li&gt;
  &lt;li&gt;tac:从最后一行开始显示，可以看出tac是cat的倒写形式&lt;/li&gt;
  &lt;li&gt;nl:显示的时候，顺便输出行号&lt;/li&gt;
  &lt;li&gt;more:一页一页地显示文件内容&lt;/li&gt;
  &lt;li&gt;less:与more类似，但是比more更好的是，它可以往前翻页&lt;/li&gt;
  &lt;li&gt;head:只看头几行&lt;/li&gt;
  &lt;li&gt;tail:只看结尾几行&lt;/li&gt;
  &lt;li&gt;od:以二进制的方式读取文件内容&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;touch&quot;&gt;修改文件时间或创建新文件:touch&lt;/h2&gt;

&lt;p&gt;文件的三个时间属性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;modification time(mtime):当该文件的&amp;rdquo;内容数据&amp;rdquo;更改时，就会更新这个时间。内容数据指的是文件的内容，而不是文件的属性或权限。&lt;/li&gt;
  &lt;li&gt;status time(ctime):当该文件的&amp;rdquo;状态&amp;rdquo;改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间。&lt;/li&gt;
  &lt;li&gt;access time(atime):当&amp;rdquo;该文件的内容被取用&amp;rdquo;时，就会更新这个读取时间。举例来说，我们使用cat读取文件，就会更新这个文件的atime。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;在默认情况下，ls显示出来的是该文件的mtime，也就是这个文件的内容上次被更改的时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;touch最经常被使用的情况:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个空的文件&lt;/li&gt;
  &lt;li&gt;将某个文件日期修改为目前日期(mtime和atime)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-5&quot;&gt;文件与目录的默认权限与隐藏权限&lt;/h1&gt;

&lt;h2 id=&quot;umask&quot;&gt;文件默认权限:umask&lt;/h2&gt;

&lt;p&gt;unmask指定:&amp;rdquo;目前用户在新建文件或目录时候的权限默认值&amp;rdquo;，unmask的分数指的是&amp;rdquo;该默认值需要减掉的权限&amp;rdquo;&lt;/p&gt;

&lt;p&gt;默认情况下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;文件的默认权限:-rw-rw-rw-&lt;/li&gt;
  &lt;li&gt;目录的默认权限:drwdrwdrw&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意:umask的分数是指该默认值需要减掉的权限&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;举例:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新建文件时:(-rw-rw-rw-)-(&amp;mdash;&amp;ndash;w&amp;ndash;w&amp;ndash;)==&amp;gt;-rw-r&amp;ndash;r&amp;ndash;&lt;/li&gt;
  &lt;li&gt;新建目录时:(drwdrwdrw)-(d&amp;mdash;-w&amp;ndash;w&amp;ndash;)==&amp;gt;drwxr-xr-x&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chattrlsattr&quot;&gt;文件隐藏属性chattr,lsattr&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chattr:设置文件的隐藏属性&lt;/li&gt;
  &lt;li&gt;lsattr:显示文件的隐藏属性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体的属性说明请参见《鸟哥的基础篇》P183&lt;/p&gt;

&lt;p&gt;比较重要的是:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a:当设置a之后，这个文件就只能增加数据，而不能删除也不能修改数据，只有root才能设置这个属性&lt;/li&gt;
  &lt;li&gt;i:i可以让一个文件&amp;rdquo;不能删除&amp;rdquo;、改名、设置连接也无法写入或添加数据。只有root才能设置这个属性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;suidsgidsbit&quot;&gt;文件特殊权限:SUID,SGID,SBIT&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;SetUID(SUID)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SUID权限仅对二进制程序有效&lt;/li&gt;
  &lt;li&gt;执行者对于该程序具有x的可执行权限&lt;/li&gt;
  &lt;li&gt;本权限仅在执行该程序过程中有效&lt;/li&gt;
  &lt;li&gt;执行者将具有该程序所有者的权限&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Set GID(SGID)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SGID对二进制程序有用&lt;/li&gt;
  &lt;li&gt;程序执行者对于该程序来说，需具备x的权限&lt;/li&gt;
  &lt;li&gt;执行者在执行的过程中将会获得该程序用户组的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Sicky Bit(SBIT)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当用户对于此目录具有w,x权限，即具有写入的权限时 &lt;/li&gt;
  &lt;li&gt;当用户在该目录下创建文件或目录时，仅有自己与root才有权力删除该文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;file&quot;&gt;查看文件类型:file&lt;/h2&gt;

&lt;p&gt;可以通过file命令来查某个文件的基本数据&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;命令与文件的查询&lt;/h1&gt;

&lt;h2 id=&quot;section-7&quot;&gt;脚本文件名的查询&lt;/h2&gt;

&lt;p&gt;which:寻找&amp;rdquo;执行文件&amp;rdquo;&lt;/p&gt;

&lt;p&gt;which是根据PATH所规范的路径去查询&amp;rdquo;执行文件&amp;rdquo;的文件名&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;文件名的查找&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;whereis:寻找特定文件(利用数据库查找,速度快)&lt;/li&gt;
  &lt;li&gt;locate:依据/var/lib/mlocate内的数据库记载,找出用户输入的关键字文件名&lt;/li&gt;
  &lt;li&gt;updatedb:根据/etc/updatedb.conf的设置去查找系统硬盘内的文件名，并更新/var/lib/mlocate内的数据库文件&lt;/li&gt;
  &lt;li&gt;find:直接查找硬盘上的文件(速度慢)&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>《鸟哥的Linux私房菜:基础篇》学习笔记——4.Linux的文件权限与目录配置</title>
   <link href="http://username.github.com/LinuxBase/2013/02/14/Learning-Linux-Base4.html"/>
   <updated>2013-02-14T00:00:00+08:00</updated>
   <id>http://username.github.com/LinuxBase/2013/02/14/Learning-Linux-Base4</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;用户与用户组&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Linux用户身份与用户组记录的文件&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户账号信息:/etc/passwd&lt;/li&gt;
  &lt;li&gt;个人密码:/etc/shadow&lt;/li&gt;
  &lt;li&gt;所有组名记录:/etc/group&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;linux&quot;&gt;Linux文件权限概念&lt;/h1&gt;

&lt;h2 id=&quot;linux-1&quot;&gt;Linux文件属性&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;7&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;drwx&amp;mdash;&amp;mdash;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;root&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;root&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4096&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Sep 5 0:37&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;.gconf&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对这七列信息的详细说明:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第一列代表这个文件的类型与权限(一共有10个字符)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;第一个字符代表这个文件是&amp;rdquo;目录、文件或链接文件&amp;rdquo;&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style=&quot;text-align: center&quot;&gt;字符&lt;/th&gt;
              &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[d]&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;目录&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[-]&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;文件&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[|]&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;连接文件&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[b]&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;设备文件里面的可供存储的接口设备&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[c]&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;设备文件里面的串行端口设备&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;接下来的字符，以3个为一组，均是&amp;rdquo;rwx&amp;rdquo;的3个参数的组合。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;注意:这3个权限的位置不会改变，如果没有权限，就会出现减号[-]而已&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;第一组为&amp;rdquo;文件所有者的权限&amp;rdquo;&lt;/li&gt;
          &lt;li&gt;第二组为&amp;rdquo;同用户组的权限&amp;rdquo;&lt;/li&gt;
          &lt;li&gt;第三组为&amp;rdquo;其他非本用户组的权限&amp;rdquo;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二列表示有多少文件名连接到此节点&lt;/p&gt;

    &lt;p&gt;每个文件都会将它的权限与属性记录到文件系统的i-node中，不过我们使用的目录树却是使用文件名来记录，因此每个文件名就会连接到一个i-node。这个属性记录的就是有多少不同的文件名连接到同一个i-node号码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第三列表示这个文件(或目录)的&amp;rdquo;所有者账号&amp;rdquo;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第四列表示这个文件的所属用户组&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第五列为这个文件的大小，默认单位是B&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第六列为这个文件的创建日期或是最近的修改日期&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第七列为该文件名&lt;/p&gt;

    &lt;p&gt;特殊情况:如果文件名之前多了个&amp;rdquo;.&amp;rdquo;,那么这个文件为&amp;rdquo;隐藏文件&amp;rdquo;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;如何改变文件属性与权限&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chgrp:改变文件所属用户组&lt;/li&gt;
  &lt;li&gt;chown:改变文件所有者&lt;/li&gt;
  &lt;li&gt;chmod:改变文件的权限&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以使用数字来表示各个权限:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;r:4&lt;/li&gt;
  &lt;li&gt;w:2&lt;/li&gt;
  &lt;li&gt;x:1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;rwx = 4+2+1=7&lt;/p&gt;

&lt;p&gt;r-x = 4+0+1=5&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;目录与文件的权限意义&lt;/h2&gt;

&lt;p&gt;文件权限对于一般文件和目录是不同的:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;文件的权限&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文件是实际含有数据的地方，包括一般文本文件、数据库内容文件、二进制可执行文件等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;r:可读取此文件的实际内容，如读取文本文件的文字内容等。&lt;/li&gt;
  &lt;li&gt;w:可以编辑、新增或者是修改该文件的内容(&lt;strong&gt;但不含删除该文件&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;x:该文件具有可以被系统执行的权限。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们的文件是否能被执行则是由是否具有&amp;rdquo;x&amp;rdquo;这个权限来决定，而跟文件名是没有绝对的关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目录的权限&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文件是存放实际数据的所在，目录主要的内容是记录文件名列表，文件名与目录有强烈的关联。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;r:表示具有读取目录结构列表的权限&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;w:可写入的权限，对目录来说这是很强大的。因为它表示你具有更改目录结构列表的权限，也就是下面这些权限:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;新建的文件与目录 &lt;/li&gt;
      &lt;li&gt;删除已经存在的文件与目录(不论该文件的权限如何)&lt;/li&gt;
      &lt;li&gt;将已存在的文件或目录进行重命名&lt;/li&gt;
      &lt;li&gt;转义该目录内的文件、目录位置&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;x:表示用户能否进入该目录成为工作目录的用途&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linux-2&quot;&gt;Linux文件种类与扩展名&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;一个Linux文件能不能被执行，与它的第一列的10个属性有关，与文件名根本一点关系都没有。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;linux-3&quot;&gt;Linux目录配置&lt;/h1&gt;

&lt;h2 id=&quot;linuxfhs&quot;&gt;Linux目录配置标准:FHS&lt;/h2&gt;

&lt;p&gt;FHS:Filesystem Hierarchy Standard&lt;/p&gt;

&lt;p&gt;FHS依据文件系统使用的频繁与否与是否允许用户随意改动，而将目录定义成为四种交互作用的形态：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&amp;nbsp;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;可分享的(shareable)&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;不可分享的(unshareable)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不变的(static)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/usr(软件放置处)  /opt(第三方软件)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc(配置文件)  /boot(开机与内核文件)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;可变动的(variable)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/var/mail(用户邮件信箱)  /var/spool/news(新闻组)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/var/rub(程序相关)  /var/lock(程序相关)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;可分享的&lt;/strong&gt;:可以分享给其他系统挂在使用的目录&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不可分享的&lt;/strong&gt;:自己机器上运行的设备文件或者是与程序有关的socket文件等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不变的&lt;/strong&gt;:一些不会经常变动的数据，例如函数库、文件说明文件、系统管理员所管理的主机服务配置文件等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可变动的&lt;/strong&gt;:经常改变的数据，例如登陆文件、新闻组等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FHS所定义的三个目录:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;/(root,根目录):与开机系统有关&lt;/li&gt;
  &lt;li&gt;/usr(UNIX software resource):与软件安装/执行有关&lt;/li&gt;
  &lt;li&gt;/var(variable):与系统运作过程有关&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;根目录(/)的意义与内容&lt;/strong&gt;
FHS标准建议:根目录(/)所在分区越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。如此不但性能较好，根目录所在的文件系统也较不容易发生问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:开机过程中仅有根目录会被挂载，其他分区则是在完成之后才会进行挂载行为。所以有些目录不可与根目录分开，下面五个目录是不可与根目录分开的:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;/etc: 配置文件&lt;/li&gt;
  &lt;li&gt;/bin: 重要执行文件&lt;/li&gt;
  &lt;li&gt;/dev: 所需要的设备文件&lt;/li&gt;
  &lt;li&gt;/lib: 执行文件所需的函数库与内核所需的模块&lt;/li&gt;
  &lt;li&gt;/sbin: 重要的系统执行文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;这个五个目录千万不可与根目录分开放在不同的分区&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;/usr的意义与内容&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;FHS建议所有软件开发者应该将他们的数据合理地分别放置到这个目录下的子目录，而不要自行新建该软件自己独立的目录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;/var的意义与内容&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;/var目录主要针对常态性变动的文件，包括缓存(cache)、登录文件(log file)以及某些软件所产生的文件。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>《鸟哥的Linux私房菜:基础篇》学习笔记——3.首次登陆与在线求助man page</title>
   <link href="http://username.github.com/LinuxBase/2013/02/14/Learning-Linux-Base3.html"/>
   <updated>2013-02-14T00:00:00+08:00</updated>
   <id>http://username.github.com/LinuxBase/2013/02/14/Learning-Linux-Base3</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;在命令行模式下执行命令&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;开始执行命令&lt;/h2&gt;

&lt;p&gt;命令行模式登陆后取得的程序被称为shell，这个程序负责最外层跟用户的通信工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一个被输入的数据绝对是命令或者是可执行文件&lt;/strong&gt;，无论命令中有几个空格，shell都视为一格。&lt;/p&gt;

&lt;p&gt;另外需要注意的是，在Linux中，大小写是敏感的。&lt;/p&gt;

&lt;h1 id=&quot;linuxman-page&quot;&gt;Linux系统的在线求助系统man page&lt;/h1&gt;

&lt;p&gt;man是manual的简写。&lt;/p&gt;

&lt;p&gt;man中的数字说明表&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;代号&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&amp;nbsp;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;用户在shell环境中可以操作的命令或可执行文件。&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;系统内核可调用的函数与工具等。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;一些常用的函数与函数库，大部分为C的函数库。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;设备文件的说明，通常在/dev下的文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;配置文件或者是某些文件的格式&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;游戏&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;惯例与协议等，例如Linux文件系统、网络协议、ASCII code等说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;系统管理员可用的管理命令。&lt;/strong&gt;　　　　　　　　　　　　　　&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;跟kernel有关的文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;section-2&quot;&gt;正确的关机方法&lt;/h1&gt;

&lt;p&gt;要关机时需要注意下面几件事情&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;查看系统的使用状态。
    &lt;ul&gt;
      &lt;li&gt;who:查看还有谁登陆在系统上&lt;/li&gt;
      &lt;li&gt;netstat -a:查看网络的联机状态&lt;/li&gt;
      &lt;li&gt;ps -aux:查看后台执行的程序&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;通知在线用户关机的时刻&lt;/li&gt;
  &lt;li&gt;正确的关机命令使用
    &lt;ul&gt;
      &lt;li&gt;sync:将数据同步写入到硬盘中&lt;/li&gt;
      &lt;li&gt;shutdown:惯用的关机命令&lt;/li&gt;
      &lt;li&gt;reboot,halt,poweroff:重启、关机&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;shutdown -h now&lt;/code&gt;立刻关机&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>《鸟哥的Linux私房菜:基础篇》学习笔记——2.主机规划与磁盘分区</title>
   <link href="http://username.github.com/LinuxBase/2013/02/14/Learning-Linux-Base2.html"/>
   <updated>2013-02-14T00:00:00+08:00</updated>
   <id>http://username.github.com/LinuxBase/2013/02/14/Learning-Linux-Base2</id>
   <content type="html">&lt;h1 id=&quot;linux&quot;&gt;Linux与硬件的搭配&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;强调：各个组件或设备在Linux下面都是一个文件。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;linux-1&quot;&gt;各硬件设备在Linux中的文件名&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;几乎所有的硬件设备文件都在/dev目录内&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;设备&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;设备在Linux内的文件名&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;IDE硬盘&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/dev/hd[a-d]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SCSI/SATA/USB硬盘&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/dev/sd[a-p]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;U盘&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/dev/sd[a-p]与SATA相同&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;软驱&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/dev/fd[0-1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;打印机&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;25针:/dev/lp[0-2]   USB:/dev/usb/lp[0-15]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;鼠标&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;USB:/dev/usb/mouse[0-15]  PS2:/dev/psaux&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;当前CD ROM/DVD ROM&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/dev/cdrom&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;当前鼠标&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/dev/mouse&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;磁带机&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;IDE:/dev/ht0\SCSI:/dev/st0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;section&quot;&gt;磁盘分区&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;磁盘连接的方式与设备文件名的关系&lt;/h2&gt;

&lt;p&gt;对于老式计算机来说，一般有两个IDE接口，而一个IDE扁平电缆可以连接两个设备，所以一共可以连接4个IDE设备。这两个IDE接口通常称为IDE1(primary)和IDE2(secondary)，而同一根电缆上的两个接口被区分为Master(主设备)与Slave(从设备)。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;IDE1(Priary)&lt;/td&gt;
      &lt;td&gt;/dev/hda&lt;/td&gt;
      &lt;td&gt;/dev/hdb&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IDE2(Secondary)&lt;/td&gt;
      &lt;td&gt;/dev/hdc&lt;/td&gt;
      &lt;td&gt;/dev/hdd&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;与IDE不同，SATA/USB/SCSI等磁盘接口都是用SCSI模块来驱动的，但是并没有特定的设备顺序，它们的命名方式是根据&lt;strong&gt;Linux内核检测到磁盘的顺序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外，USB只有开机完成后才被系统识别。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;磁盘的组成复习&lt;/h2&gt;

&lt;p&gt;每个扇区为512bytes&lt;/p&gt;

&lt;p&gt;磁盘的第一个扇区十分重要，其中记录了两个关于磁盘的重要的信息:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;主引导分区(Master Boot Record,MBR)&lt;/strong&gt;:可以安装引导加载程序的地方，有446bytes.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;分区表&lt;/strong&gt;:记录整块硬盘分区的状态,有64bytes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;磁盘分区表&lt;/h2&gt;

&lt;p&gt;柱面是文件系统的最小单位，也是分区的最小单位。&lt;/p&gt;

&lt;p&gt;在分区表的64bytes中，总共可以分为4组记录区，每组记录区中记录了该区段的起始与结束的柱面号。这个4组记录区被称为主(Primary)或扩展(Extended)分区，其中，扩展(Extened)分区不能超过1个，也就是说，主分区可以有多个(不超过4个),而不止1个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分区命名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分区的命名方式是在设备文件名后加上数字，其中1-4是保留给Primary或Extended使用的。&lt;/p&gt;

&lt;p&gt;例子:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;/dev/hda1&lt;/li&gt;
  &lt;li&gt;/dev/hda2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;扩展分区&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;磁盘的第一个扇区中的64Bytes只能记录4个分区信息，因此我们可以利用额外的扇区来记录更多的分区信息。扩展分区就是用来做这项工作的。扩展分区的目的是使用额外的扇区来记录信息，&lt;strong&gt;扩展分区本身并不能拿来格式化。&lt;/strong&gt;由扩展分区继续分出来的分区称为逻辑分区(logical parition),同时需要注意的是，由于逻辑分区是由扩展分区继续分出来的，所以&lt;strong&gt;逻辑分区可以使用的柱面范围就是扩展分区所设定的范围。&lt;/strong&gt;由1-4这四个号码是保留给Primary和Extended所使用的，所以&lt;strong&gt;逻辑分区的设备名称是从5开始的，这很重要！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;其实所谓的&amp;rdquo;分区&amp;rdquo;只是针对第一个扇区中的64bytes的分区表进行设置而已。&lt;/li&gt;
  &lt;li&gt;硬盘默认的分区表仅能写入四组分区信息&lt;/li&gt;
  &lt;li&gt;这四组分区信息我们称为主或扩展分区&lt;/li&gt;
  &lt;li&gt;分区的最小单位是柱面&lt;/li&gt;
  &lt;li&gt;主分区和扩展分区最多可以由四个(硬盘的限制)&lt;/li&gt;
  &lt;li&gt;扩展分区最多只能由一个(OS的限制)&lt;/li&gt;
  &lt;li&gt;逻辑分区是由扩展分区持续切割出来分区&lt;/li&gt;
  &lt;li&gt;能够被格式化后作为数据访问的分区为主分区与逻辑分区。扩展分区无法格式化&lt;/li&gt;
  &lt;li&gt;逻辑分区的数量依OS而不同，在Linux中，IDE硬盘最多有59个逻辑分区(5-63号)，SATA硬盘则有11个逻辑分区(5-15号)&lt;/li&gt;
  &lt;li&gt;分区其实就是以柱面为单位的“连续”磁盘空间。&lt;/li&gt;
  &lt;li&gt;考虑到磁盘的连续性，一般建议将扩展分区的柱面号码分配在最后面的柱面内。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;开机流程与主引导分区&lt;/h2&gt;

&lt;p&gt;整个开机流程应该是这样的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BIOS:开机主动执行的韧体，会认识第一个可开机的设备。(韧体就是写入到硬件上的一个软件程序)&lt;/li&gt;
  &lt;li&gt;MBR: 第一个可开机设备的第一个扇区内的主引导分区块，内包含了引导加载程序。&lt;/li&gt;
  &lt;li&gt;引导加载程序(Boot loader):一支可读取内核文件来执行的软件。&lt;/li&gt;
  &lt;li&gt;内核文件: 开始操作系统的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Boot loader是安装在MBR上的一套软件，由于MBD只有446Bytes，所以这个引导加载程序是非常小而完美的。引导加载程序的主要任务如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提供菜单:用户可以选择不同的开机选项，这也是多重引导的重要功能&lt;/li&gt;
  &lt;li&gt;载入内核文件: 直接指向可开机的程序区段来开始OS&lt;/li&gt;
  &lt;li&gt;转交其他Loader: 将引导加载功能转交给其他loader负责。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意:引导加载程序除了可以安装在MBR之外，还可以安装在每个分区的引导扇区&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;每个分区都拥有自己的启动扇区&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;实际可开机的内核文件是放置到各分区内的&lt;/li&gt;
  &lt;li&gt;Loader只会认识自己的系统分区内的可开机内核文件，以及其他loader。&lt;/li&gt;
  &lt;li&gt;Loader可直接指向或间接地将管理权转交给另一个管理程序。&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>《鸟哥的Linux私房菜:基础篇》学习笔记——1.Linux是什么</title>
   <link href="http://username.github.com/LinuxBase/2013/02/14/Learning-Linux-Base1.html"/>
   <updated>2013-02-14T00:00:00+08:00</updated>
   <id>http://username.github.com/LinuxBase/2013/02/14/Learning-Linux-Base1</id>
   <content type="html">&lt;h1 id=&quot;linux&quot;&gt;Linux内核版本&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:通常来说我们所说的应该Linux应该是指OS中的内核，而不是指整个OS。Linux就是一个OS最底层的内核及其提供的内核工具。&lt;/p&gt;

&lt;p&gt;版本号的格式:主版本.次版本.释出版本-修改版本。&lt;/p&gt;

&lt;p&gt;举例:2.6.18-92.e15&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主、次版本号为奇数:开发中的版本号。如2.5.xx，这种内核通常是内核开发工程师所使用的，主要用来添加和测试新功能。&lt;/li&gt;
  &lt;li&gt;主、次版本号为偶数:稳定的版本号。如2.6.xx，这种内核是开发成熟的，一般用于PC或企业版本中，重点是为用户提供稳定的版本。&lt;/li&gt;
  &lt;li&gt;释出版本: 释出版本是指，在主、次版本架构不变的情况下，新增功能累积到一定的程度后所新释出的内核版本。&lt;/li&gt;
  &lt;li&gt;修改版本: 由于Linux是使用GPL授权的，所以每个人都能修改器内核版本，你可以对某个版本的内核进行修改，而修改后的版本就是修改版本了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;linux-distributoins&quot;&gt;Linux Distributoins&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Linux Distributions = Kernel + Softwares + Tools + Documents&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Linux Distribution的中文翻译:可完全安装套件&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——15.作用域</title>
   <link href="http://username.github.com/Python/2013/02/07/Learning-Python15.html"/>
   <updated>2013-02-07T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/02/07/Learning-Python15</id>
   <content type="html">&lt;h1 id=&quot;python&quot;&gt;Python作用域&lt;/h1&gt;
&lt;p&gt;在一个Python程序只用变量名时，Python创建、改变或查找变量名都是在所谓的命名空间(一个保存变量名的地方)中进行的。也就是说，在代码中变量名被赋值的位置决定了这个变量名能被访问到的范围,也即决定了它存在于哪个命名空间中。&lt;/p&gt;

&lt;p&gt;除了打包程序之外，函数还为程序增加了一个额外的命名空间层:默认情况下，一个函数所有变量名都是与函数的命名空间相关联的。这意味着:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个在def内的定义的变量能够在def内的代码使用,不能在函数的外部应用这样的变量名。&lt;/li&gt;
  &lt;li&gt;def之中的变量名与def之外的变量名并不冲突，一个在def之外被赋值的变量X与在这个def之中赋值的变量X是完全不同的变量。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;作用域法则&lt;/h2&gt;
&lt;p&gt;在开始编写函数之前，我们编写的所有代码都是位于一个模块的顶层(也就是说，并不是嵌套在def之中)，所以我们使用的变量名要么是存在于模块文件本身，要么就是Python内置预先定义好的。函数定义本地作用域，而模块定义的全局作用域。这两个作用域有如下关系:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;内嵌的模块是全局作用域&lt;/strong&gt;
每个模块都是一个全局作用域(也就是说，一个创建于模块文件顶层的变量的命名空间)。对于模块外部来说，该模块的全局变量就成为了这个模块对象的属性，但是在这个模块中能够像简单的变量一样使用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;全局作用域的作用范围仅限于单个文件&lt;/strong&gt;
这里的全局指的是在一个文件的顶层的变量名仅对于这个文件内部的代码而言是全局的。在Python中是没有基于一个单个的、无所不包的情景文件的全局作用域的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;每次对函数的调用都创建了一个新的本地作用域&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;赋值的变量名除非声明为全局变量或非局部变量，否则均为局部变量&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;所有的变量名都可以归纳为本地、全局或者内置的&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;legb&quot;&gt;变量名解析:LEGB原则&lt;/h2&gt;
&lt;p&gt;Python的变量名解析机制有时称为LEGB法则，当在&lt;strong&gt;函数&lt;/strong&gt;中使用未认证的变量名时，Python搜索4个作用域:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;本地作用域(L)&lt;/li&gt;
  &lt;li&gt;上一层结构中def或lambda的本地作用域(E)(其实就是函数嵌套的情况)&lt;/li&gt;
  &lt;li&gt;全局作用域(G)&lt;/li&gt;
  &lt;li&gt;最后是内置作用域(B)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Python按顺序在上面4个作用域中查找变量，并且在第一个能够找到这个变量名的地方停下来，如果在这4个作用域中都没找到，Python会报错。&lt;/p&gt;

&lt;p&gt;这里需要强调的是，上面四个作用域是函数中代码的搜索过程，也就是说，&lt;strong&gt;在函数中能直接使用上一层中的变量！&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#return 40 not 12&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;内置作用域&lt;/h2&gt;

&lt;p&gt;内置作用域是通过一个名为&lt;strong&gt;builtin&lt;/strong&gt;的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;builtins&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;builtins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因此，事实上有两种方法可以引用一个内置函数:通过LEGB法则带来的好处，或者手动导入&lt;strong&gt;builtin&lt;/strong&gt;模块。其中第二种方法在一些复杂的任务里是很有用的，因为一些局部变量有可能会覆盖内置的变量或函数。再次强调的是，&lt;strong&gt;LEGB法则只使它找到的第一处变量名的地方生效!&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;global&quot;&gt;global语句&lt;/h1&gt;
&lt;p&gt;global语句是一个命名空间的声明，它告诉Python解释器打算生成一个或多个全局变量，也就是说，存在于整个模块内部作用域(命名空间)的变量名。关于全局变量名:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;全局变量是位于模块文件内部顶层的变量名。&lt;/li&gt;
  &lt;li&gt;全局变量如果是在函数内部被赋值的话，必须经过声明。&lt;/li&gt;
  &lt;li&gt;全局变量名在函数的内部不经过声明也可以被引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;global语句包含了关键字global，其后跟着一个或多个由逗号分开的变量名。当在函数主题被赋值或引用时，所有列出来的变量名将被映射到整个模块的作用域内。
举个例子:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;88&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#Prints 99&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-2&quot;&gt;作用域和嵌套函数&lt;/h1&gt;
&lt;p&gt;这部分内容是关于LEGB查找法则中E这一层的，它包括了任意嵌套函数内部的本地作用域。嵌套作用域有时也叫做静态嵌套作用域。实际上，嵌套是一个语法上嵌套的作用域，它是对应于程序源代码的物理结构上的嵌套结构。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;嵌套作用域的细节&lt;/h2&gt;
&lt;p&gt;对于一个函数来说:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个引用(X)首先在本地(函数内)作用域查找变量名X；之后会在代码的语法上嵌套了的函数中的本地作用域，从内到外查找；之后查找当前的全局作用域(模块文件)；最后在内置作用域内(模块&lt;strong&gt;builtin&lt;/strong&gt;)。全局声明将会直接从全局(模块文件)作用域进行搜索。其实就是从引用X的地方开始，一层一层网上搜索，直到找到的第一个X。&lt;/li&gt;
  &lt;li&gt;在默认情况下，一个赋值(X=value)创建或修改了变量名X的当前作用域。如果X在函数内部声明为全局变量，它将会创建或改变变量名X为整个模块的作用域。另一方面，如果X在函数内部声明为nonlocal，赋值会修改最近的嵌套函数的本地作用域中的名称X。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;嵌套作用域举例&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;88&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#Prints 88:enclosing def local&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先需要说明的是，上面这段代码是合法的，def是一个简单的执行语句，可以出现在任意其他语句能够出现的地方，包括嵌套在另一个def之中。代码中，f2是在f1中定义的函数，在此情况下，f2是一个临时函数，仅在f1内部执行的过程中存在(并且只对f1中的代码可见)。通过LEGB查找法则，f2内的X自动映射到了f1的X。&lt;/p&gt;

&lt;p&gt;值得注意的是，&lt;strong&gt;这个嵌套作用域查找在嵌套的函数已经返回后也是有效的。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;88&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#Remember X in enclosing def scope&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#Return f2 but don&amp;#39;t call it&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#Make return function&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#Call it now:Prints 88&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码中，不管调用几次action函数，返回值都是88，f2记住了f1中嵌套作用域中的X，尽管此时f1已经不处于激活的状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工厂函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上述这些行为有时叫做闭合(closure)或者工厂函数——一个能够记住嵌套作用域的变量值的函数，即使那个作用域也许已经不存在了。通常来说，使用类来记录状态信息时更好的选择，但是像这样的工厂函数也提供了一种替代方案。
具体的例子:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;maker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#Pass 2 to N&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;		&lt;span class=&quot;c&quot;&gt;#Pass 3 to X,N remembers 2: 3**2,Return 9&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;		&lt;span class=&quot;c&quot;&gt;#return 4**2&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#g remembers 3,f remembers 2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;		&lt;span class=&quot;c&quot;&gt;#return 27&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;		&lt;span class=&quot;c&quot;&gt;#return 9&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上面代码中可以看到，f和g函数分别记录了不同的N值，也就是记录了不同的状态，每一次对这个工厂函数进行赋值，都会得到一个状态信息的集合，每个函数都有自己的状态信息，由maker中的变量N保持。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;作用域与带有循环变量的默认参数相比较&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在已给出的法则中有一个值得注意的特例：如果lambda或者def在函数中定义，嵌套在一个循环之中，并且嵌套的函数引用了一个上层作用域的变量，该变量被循环所改变，所有在这个循环中产生的函数都将会有相同的值——在最后一次循环中完成时被引用变量的值。具体的例子:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeActions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;acts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;			&lt;span class=&quot;c&quot;&gt;#Tries to remember each i&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#All remember same last it&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acts&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;尽管是在尝试创建一个函数列表，使得每个函数拥有不同的状态值，但是事实上，这个列表中的函数的状态值都是一样的，是4。因为嵌套作用域中的变量在嵌套的函数被调用时才进行查找，所以它们实际上记住的是同样的值(在最后一次循环迭代中循环变量的值)。&lt;/p&gt;

&lt;p&gt;为了能让这类代码能够工作，必须使用默认参数把当前的值传递给嵌套作用域的变量。因为默认参数是在嵌套函数创建时评估的(而不是在其稍后调用时)，每一个函数记住了自己的变量i的值。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makeActions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;acts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;			&lt;span class=&quot;c&quot;&gt;#Use default instead&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#Remember current i&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acts&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;nonlocal&quot;&gt;nonlocal语句&lt;/h1&gt;
&lt;p&gt;事实上，在Python3.0中，我们也可以修改嵌套作用域变量，只要我们在一条nonlocal语句中声明它们。使用这条语句，嵌套的def可以对嵌套函数中的名称进行读取和写入访问。nonlocal应用于一个嵌套的函数的作用域中的一个名称，而不是所有def之外的全局模块作用域——它们可能只存在于一个嵌套的函数中，并且不能由一个嵌套的def中第一次赋值创建。&lt;/p&gt;

&lt;p&gt;换句话说，nonlocal即允许对嵌套的函数作用域中的名称变量赋值，并且把这样的名称作用域查找限制在嵌套的def。&lt;/p&gt;

&lt;h2 id=&quot;nonlocal-1&quot;&gt;nonlocal基础&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;nonlocal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这条语句允许一个嵌套函数来修改在一个语法嵌套函数的作用域中定义的一个或多个名称。在Python 2.X中，当一个函数def嵌套在另一个函数中，嵌套的函数可以引用上一层函数中定义的各种变量，但是不能修改它们。在Python3.0中，在一条nonlocal语句中声明嵌套的作用域，使得嵌套的函数能够赋值，并且由此也能够修改这样的名称。&lt;/p&gt;

&lt;p&gt;除了允许修改嵌套的def中的名称，nonlocal语句还加快了引用——就像global语句一样，nonlocal使得对该语句中列出的名称的查找从嵌套的def的作用域中开始，而不是从声明函数的本地作用域开始，也就是说，nonlocal也意味着&amp;rdquo;完全略过我的本地作用域&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;实际上，当执行到nonlocal语句的时候，nonlocal中列出的名称必须在一个嵌套的def中提前定义过，否则，将会产生一个错误。直接效果和global很相似:global意味着名称位于上一层的模块中，nonlocal意味着它们位于一个上一层的def函数中。nonlocal甚至更加严格——作用域查找只限定在嵌套的def。也就是说，nonlocal只能出现在嵌套的def中，而不能在模块的全局作用域中或def之外的内置作用域中。&lt;/p&gt;

&lt;p&gt;当在一个函数中使用的时候，global和nonlocal语句都在某种程度上限制了查找规则:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;global使得作用域查找从嵌套的模块的作用域开始，并且允许对那里的名称赋值。如果名称不存在与该模块中，作用域查找继续到内置作用域，但是，对全局名称的赋值总是在模块作用域中创建或修改它们。&lt;/li&gt;
  &lt;li&gt;nonlocal限制作用域查找只是嵌套的def，要求名称已经存在于那里，并且允许对它们赋值。作用域查找不会继续到全局或内置作用域。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nonlocal-2&quot;&gt;nonlocal应用&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;使用nonlocal进行修改&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tester&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;		&lt;span class=&quot;c&quot;&gt;#each call gets its own state&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;nested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;nonlocal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#remember state in enclosing scope&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;		&lt;span class=&quot;c&quot;&gt;#Allowed to change it if onolocal&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nested&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tester&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 		&lt;span class=&quot;c&quot;&gt;#Increments state on each call&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;spam&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;		&lt;span class=&quot;c&quot;&gt;#Prints:spam 0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;ham&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;		&lt;span class=&quot;c&quot;&gt;#Prints:ham 1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;eggs&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;		&lt;span class=&quot;c&quot;&gt;#Prints:eggs 2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;边界情况&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当执行一条nonlocal语句时，nonlocal名称必须已经在一个嵌套的def作用域中赋值过，否则将会得到一个错误。&lt;/li&gt;
  &lt;li&gt;nonlocal限制作用域查找仅为嵌套的def，nonlocal不会在嵌套的模块的全局作用域或所有def之外的内置作用域中查找。&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——14.函数基础</title>
   <link href="http://username.github.com/Python/2013/02/07/Learning-Python14.html"/>
   <updated>2013-02-07T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/02/07/Learning-Python14</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;为何使用函数&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;最大化代码的重用和最小化代码冗余&lt;/li&gt;
  &lt;li&gt;流程的分解&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-1&quot;&gt;编写函数&lt;/h1&gt;

&lt;h2 id=&quot;def&quot;&gt;def语句&lt;/h2&gt;
&lt;p&gt;在Python中创建一个函数是通过&lt;code&gt;def&lt;/code&gt;关键字进行的，&lt;code&gt;def&lt;/code&gt;语句将创建一个函数对象并将其赋值给一个变量名。&lt;code&gt;def&lt;/code&gt;语句一般的格式如下所示:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通常情况下，函数体中会有一个&lt;code&gt;return&lt;/code&gt;语句，可以出现在函数体的任何位置，它表示函数调用的结束，并将结果返回至函数调用处。但是&lt;code&gt;return&lt;/code&gt;语句是可选的，并不是必须的。从技术角度上说，一个没有返回值的函数自动返回了none对象，但是这个值可以被忽略掉。&lt;/p&gt;

&lt;h2 id=&quot;def-1&quot;&gt;def语句是实时执行的&lt;/h2&gt;
&lt;p&gt;Python的&lt;code&gt;def&lt;/code&gt;语句实际上是一个可执行的语句:当它运行的时候，它创建一个新的函数对象并将其赋值给一个变量名。(请记住，Python中所有的语句都是实时运行的，没有对像独立编译时间这样的流程)因为它是一个语句，它可以出现在任一语句可以出现的地方——甚至是嵌套在其他语句中。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;它在运行时简单地给一个变量名进行赋值。与C语言这样的编译语言不同，Python函数在程序运行之前并不需要全部定义，更确切地说，&lt;code&gt;def&lt;/code&gt;在运行时才评估，而在&lt;code&gt;def&lt;/code&gt;之中的代码在函数调用时才会评估。&lt;/p&gt;

&lt;p&gt;就像Python中其他语句一样，函数仅仅是对象，在程序执行时它清除地记录在了内存之中。实际上，除了调用之外，函数允许任意的属性附加到记录信息以供随后使用:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;othername&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#Assign function object&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;othername&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#Call func again&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;		&lt;span class=&quot;c&quot;&gt;#call object&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#attach attribute&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-2&quot;&gt;一个例子:定义和调用&lt;/h1&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#return 8&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#return 12.56&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Ni&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#return &amp;#39;NiNiNi&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码中对函数的三次调用都能正确运行，因为&amp;rdquo;*&amp;ldquo;对数字和序列都有效，在Python我们从未对变量、参数或者返回值有过类似的声明，我们可以把times用作数字的乘法或是序列的重复。&lt;/p&gt;

&lt;p&gt;换句话说，&lt;strong&gt;函数times的作用决定于传递给它的参数，&lt;/strong&gt;这是Python的核心概念之一。&lt;/p&gt;

&lt;p&gt;需要强调的是，如果我们传入了一个不支持函数操作的参数，Python会自动检测出不匹配，并抛出一个异常，这样就能减少我们编写不必要的类型检测代码。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;局部变量&lt;/h2&gt;
&lt;p&gt;所有在函数内部定义的变量默认都是局部变量，所有的局部变量都会在函数调用时出现，并在函数退出时消失。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——13.文档</title>
   <link href="http://username.github.com/Python/2013/02/05/Learning-Python13.html"/>
   <updated>2013-02-05T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/02/05/Learning-Python13</id>
   <content type="html">&lt;h1 id=&quot;pyton&quot;&gt;Pyton文档资源&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;形式&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;角色&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;#注释&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;文件中的文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;dir函数&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对象中可用属性的列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;文档字符串:&lt;code&gt;__doc__&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;附加在对象上的文件中的文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;PyDoc:help函数&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对象的交互帮助&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;PyDoc:HTML报表&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;浏览器中的模块文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;标准手册&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;正式的语言和库的说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;网站资源&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在线教程、例子等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;出版的书籍&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;商业参考书籍&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section&quot;&gt;#注释&lt;/h2&gt;
&lt;p&gt;井字号注释是代码编写的最基本方式。Python会忽略#之后所有文字(只要#不是位于字符串常量中)，所以你可以在这个字符之后插入一些对程序员有意义的文字和说明。不过，这类注释只能在源码中看到。&lt;/p&gt;

&lt;h2 id=&quot;dir&quot;&gt;dir函数&lt;/h2&gt;
&lt;p&gt;内置的dir函数是抓取对象内可用所有属性列表的简单方式，它能够调用任何有属性的对象。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;文档字符串&lt;/h2&gt;
&lt;p&gt;除了#注释外，Python也支持可自动附加在对象上的文档，而且在运行时还可保存查看。从语法上来说，这类注释是写成字符串，放在模块文件、函数以及类语句的顶端，就在任何可执行程序代码之前。Python会自动封装这个字符串，也就是成为所谓的文档字符串，使其成为相应对象的&lt;code&gt;__doc__&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;这个文档协议的重点在于，注释会保存在&lt;code&gt;__doc__&lt;/code&gt;属性中以供查看(文件导入之后)。
文档字符串的例子:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;Module documentation&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;Words to Here&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;square&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
	&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;	function documentation&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;	can we have your liver then?&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;	&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#square&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&amp;quot;class documentation&amp;quot;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;square&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;square&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__doc__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;pydochelp&quot;&gt;PyDoc:help函数&lt;/h2&gt;
&lt;p&gt;文档字符串技术是实用的工具，Python现在配备了一个工具，使其更易于显示。标准PyDoc工具是Python程序代码，知道如何提取文档字符串并且自动提取使其结构化的信息，并将其格式化成各种类型的排列友好的报表。&lt;/p&gt;

&lt;p&gt;两种最主要的PyDoc接口是内置的help函数和PyDoc GUI/HTML接口。help函数会启用PyDoc从而产生简单的文字报表。&lt;/p&gt;

&lt;h2 id=&quot;pydochtml&quot;&gt;PyDoc:HTML报表&lt;/h2&gt;
&lt;p&gt;想要更宏观的显示的话，PyDoc也提供GUI接口，可以将其报表通过HTML网页格式来呈现，可通过任何浏览器来查看。在这种模式下，PyDoc可以在本地运行，也能在远程服务器上运行。报表中会包含自动创建的超链接，让你能够点击应用程序中相关组件的稳定。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;标准手册&lt;/h2&gt;
&lt;p&gt;为了获得语言以及工具集最新的完整说明，Python标准手册随时可以提供支持。Python手册以HTML和其他格式来实现，在Windows上是随着Python系统安装的。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;常见编写代码的陷阱&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;别忘了逗号&lt;/li&gt;
  &lt;li&gt;从第1行开始&lt;/li&gt;
  &lt;li&gt;空白行在交互模式提示符下很重要&lt;/li&gt;
  &lt;li&gt;缩进要一致&lt;/li&gt;
  &lt;li&gt;不要在Python中写C代码&lt;/li&gt;
  &lt;li&gt;使用简单的for循环，而不是while或range&lt;/li&gt;
  &lt;li&gt;要注意赋值语句中的可变对象&lt;/li&gt;
  &lt;li&gt;不要期待在原处修改对象的函数会返回结果&lt;/li&gt;
  &lt;li&gt;一定要使用括号调用函数&lt;/li&gt;
  &lt;li&gt;不要在导入和重载中使用扩展名或路径&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——12.迭代器和解析,第一部分</title>
   <link href="http://username.github.com/Python/2013/02/05/Learning-Python12.html"/>
   <updated>2013-02-05T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/02/05/Learning-Python12</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;迭代器:初探&lt;/h1&gt;
&lt;p&gt;上一章曾经提到过，其实for循环是可用于任何可迭代的对象上的。实际上，对Python中所有会从左至右扫描对象的迭代工具而言都是如此，这些迭代工具包括了for循环、列表解析、in成员关系测试以及map内置函数等。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;可迭代对象&amp;rdquo;的概念在Python中是相当新颖的，基本这就是序列观念的通用化:如果对象时实际保存的序列，或者可以再迭代工具环境中一次产生一个结果的对象,那就看做是可迭代的。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;文件迭代器&lt;/h2&gt;
&lt;p&gt;作为内置数据类型的文件也是可迭代的，它有一个名为&lt;code&gt;__next__&lt;/code&gt;的方法，每次调用时，就会返回文件中的下一行。当到达文件末尾时，&lt;code&gt;__next__&lt;/code&gt;会引发内置的StopIteration异常，而不是返回空字符串。&lt;/p&gt;

&lt;p&gt;这个接口就是Python中所谓的迭代协议:有&lt;code&gt;__next__&lt;/code&gt;方法的对象会前进到下一个结果，而在一系列结果的末尾时，则会引发StopIteration。任何这类对象都认为是可迭代的。任何这类对象也能以for循环或其他迭代工具遍历，因为所有迭代工具内部工作起来都是在每次迭代中调用&lt;code&gt;__next__&lt;/code&gt;，并且捕捉StopIteratin异常来确定何时离开。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;script.py&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;upper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的代码就是文件迭代的一个例子，并且这种用法是最高效的文件读取方法，主要有三个优点:这是最简单的写法，运行快，并且从内存使用情况来说也是最好的。&lt;/p&gt;

&lt;p&gt;替代的写法是:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;script.py&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readlines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;upper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种调用方法会把文件一次性读到内存中，如果文件太大，那么内存会被消耗光的。&lt;/p&gt;

&lt;h2 id=&quot;iternext&quot;&gt;手动迭代:iter和next&lt;/h2&gt;
&lt;p&gt;为了支持手动迭代代码(用较少的录入)，Python3.0还提供了一个内置函数next，它会自动调用一个对象的&lt;code&gt;__next__&lt;/code&gt;方法。给定一个对象X，调用&lt;code&gt;next(X)&lt;/code&gt;等同于&lt;code&gt;X.__next__()&lt;/code&gt;，但前者简单很多。&lt;/p&gt;

&lt;p&gt;从技术角度来讲，迭代协议还有一点值得注意。当for循环开始时，会通过它传给iter内置函数，以便从可迭代对象中获得一个迭代器，返回的对象含有需要的next方法。调用iter的步骤对于文件来说不是必须的，因为文件对象就是自己的迭代器，但是对于其他的一些内置数据类型来说，就不一定了。&lt;/p&gt;

&lt;p&gt;列表以及很多其他的内置对象，不是自身的迭代器，因为它们支持多次打开迭代器。对这样的对象，我们必须调用iter来启动迭代:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#return false&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__next__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;	&lt;span class=&quot;c&quot;&gt;#会报错&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__next__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__next__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然Python迭代工具自动调用这些(&lt;code&gt;iter&lt;/code&gt;,&lt;code&gt;__next__&lt;/code&gt;)函数，我们也可以使用它们来手动地应用迭代协议。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;列表解析:初探&lt;/h1&gt;

&lt;h2 id=&quot;section-3&quot;&gt;列表解析基础知识&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;列表解析写在一个方括号中，因为它们最终是构建一个新的列表的一种方式。它们以我们所组成的一个任意的表达式开始，该表达式使用我们所组成的一个循环变量(x+10)。这后面跟着我们现在应该看作是一个for循环头部的部分，它申明了循环变量，以及一个可迭代对象(for x in L)&lt;/p&gt;

&lt;p&gt;要运行该表达式，Python在解释器内部执行一个遍历L的迭代，按照顺序把x赋给每个元素，并且收集对各元素运行左边的表达式的结果。我们得到的结果列表就是列表解析所表达的内容——针对L中的每个x,包含了x+10的一个新列表。&lt;/p&gt;

&lt;p&gt;其实列表解析式并不是必须的，因为它能完成的工作都能够通过for循环完成，但是列表解析式比手动的for循环语句运行得更快(往往速度快一倍)，因为它们的迭代在解释器内部是以C语言的速度执行的，而不是以手动的Python代码执行的，特别是对于较大的数据集合，这是使用列表解析的一个主要的性能优点。&lt;/p&gt;

&lt;p&gt;当我们考虑在一个序列中的每个项上执行一个操作时，都可以考虑使用列表解析。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;扩展的列表解析语法&lt;/h2&gt;
&lt;p&gt;实际上，列表解析可以有更高级的应用。作为一个特别有用的扩展，表达式中嵌套的for循环可以有一个相关的if子句，来过滤那些测试不为真的结果项。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;lines&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rstrip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;script.py&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;p&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这条if子句检查从文件读取的每一行，看它的第一个字符是否是p；如果不是，从结果列表中省略改行。&lt;/p&gt;

&lt;p&gt;事实上，如果我们愿意的话，列表解析可以变得更加复杂——它们的完整语法允许任意数目的for子句，每个子句有一个可选的相关的if子句。&lt;/p&gt;

&lt;h1 id=&quot;python30&quot;&gt;Python3.0中的新的可迭代对象&lt;/h1&gt;
&lt;p&gt;Pyton3.0中的一个基本的改变是，它比Python2.x更强调迭代。除了与文件和字典这样的内置类型相关的迭代，字典方法keys、values和items都在Python3.0中返回可迭代对象。
返回一个可迭代对象而不是返回一个结果列表的好处在于节省了内存的空间。&lt;/p&gt;

&lt;h2 id=&quot;vs&quot;&gt;多个迭代器VS单个迭代器&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;多个迭代器:在它们的结果中能保持不同位置的多个迭代器&lt;/li&gt;
  &lt;li&gt;单个迭代器:只能保持一个迭代器，在遍历其结果之后，它们就用尽了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常通过针对iter调用返回一个新的对象，来支持多个迭代器；单个迭代器一般意味着一个对象返回其自身。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;字典视图迭代器&lt;/h2&gt;
&lt;p&gt;在Python3.0中，字典的keys、values和items方法返回可迭代的视图对象，它们一次产生一个结果项，而不是在内存中一次产生全部结果列表。视图项保持和字典中的那些项相同的物理顺序，并且反映对底层的字典做出的修改。&lt;/p&gt;

&lt;p&gt;和所有迭代器一样，我们总可以通过把一个Python3.0字典视图传递到list内置函数中，从而强制构建一个真正的列表。然而，这通常不是必须的。&lt;/p&gt;

&lt;p&gt;此外，Python3.0字典仍然有自己的迭代器，它返回连续的键。因此，无需直接在此环境中调用keys:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——11.while和for循环</title>
   <link href="http://username.github.com/Python/2013/02/04/Learning-Python11.html"/>
   <updated>2013-02-04T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/02/04/Learning-Python11</id>
   <content type="html">&lt;h1 id=&quot;while&quot;&gt;while循环&lt;/h1&gt;

&lt;p&gt;while语句是Python语言中最通用的迭代结构，简而言之，只要顶端测试一直计算到真值，就会重复执行一个语句块。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;一般格式&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statements1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statements2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;breakcontinuepasselse&quot;&gt;break,continue,pass和循环else&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;break&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;跳出最近所在的循环(跳过整个循环语句)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;continue&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;跳到最近所在循环的开头处(来到循环的首行)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pass&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;什么事也不做，只是空占位符语句。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;循环else块&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;只有当前循环正常离开时才会执行(也就是没有碰到break语句)&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;一般循环格式&lt;/h2&gt;

&lt;p&gt;加入break和continue语句后，while的一般格式变为:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statements1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statements2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;pass&quot;&gt;pass&lt;/h2&gt;

&lt;p&gt;pass语句是无运算的占位符，当语法需要语句并且还没有任何实用的语句可写时，就可以使用它。&lt;/p&gt;

&lt;h2 id=&quot;else&quot;&gt;循环else&lt;/h2&gt;

&lt;p&gt;在while语句中加入else和C/C++中的语法不太一样，这里详细说明一下。else后面的代码只有当循环正常结束时才会执行，如果是用break跳出循环的，这部分代码就不会运行，具体看一个求质数的例子:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;has factor&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;is prime&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再看一个对比的例子，没有使用else的情况:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;found&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;False&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;found&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matchx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]):&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Ni&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;found&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;True&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;found&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;not found&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用else后的情况:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])):&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Ni&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;not found&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;for&quot;&gt;for循环&lt;/h1&gt;

&lt;p&gt;for循环在Python中是一个通用的序列迭代器:可以遍历任何有序的序列对象内元素。for语句可以用于字符串、列表、元组、其他内置可迭代对象。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;一般格式&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此处的else的作用和while语句中的一样。另外需要注意的是，当Python运行for循环时，会逐个将序列对象中的元素赋值给目标，然后为每个元素执行循环体。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;编写循环的技巧&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;内置&lt;strong&gt;range&lt;/strong&gt;函数:返回一系列连续增加的整数，可作为for中的索引&lt;/li&gt;
  &lt;li&gt;内置&lt;strong&gt;zip&lt;/strong&gt;函数:返回并行元素的元组的列表，可用于在for中遍历数个数列&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;whilerange&quot;&gt;循环计数器:while和range&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;range&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当range函数只有一个参数时，会返回从零算起的整数列表，但其中不包括该参数的值。如果传进两个参数，那第一个参数是上边界，第二个参数是下边界。如果传进三个参数时，第三个参数表示步进值。&lt;/p&gt;

&lt;p&gt;range提供了一种简单的方法，重复特定次数的动作:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Pythons&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;相应的C++代码则是:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Python&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;zipmap&quot;&gt;并行遍历:zip和map&lt;/h2&gt;

&lt;p&gt;zip会取得一个或多个序列为参数，然后返回元组的列表，将这些序列中的并排的元素配成对。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;L1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;L2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码的执行结果是:[(1,5),(2,6),(3,7),(4,8)]&lt;/p&gt;

&lt;p&gt;当参数的长度不同时，zip会以最短序列的长度为准来截断所得到的元组。&lt;/p&gt;

&lt;p&gt;使用zip构造字典:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;spam&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;eggs&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;totast&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;enumerate&quot;&gt;产生偏移和元素:enumerate&lt;/h2&gt;

&lt;p&gt;enumerate函数一个比较新的内置函数，它能同时返回元素值和偏移值:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;spam&amp;#39;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;appears at offset&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——10.if测试和语法规则</title>
   <link href="http://username.github.com/Python/2013/02/03/Learning-Python10.html"/>
   <updated>2013-02-03T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/02/03/Learning-Python10</id>
   <content type="html">&lt;h1 id=&quot;if&quot;&gt;if语句&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;通用格式&lt;/h2&gt;

&lt;p&gt;if语句一般形式如下:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statements1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statements2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statements3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外需要注意的是，Python中是没有&lt;code&gt;switch/case&lt;/code&gt;语句的&lt;/p&gt;

&lt;h1 id=&quot;python&quot;&gt;Python语法规则&lt;/h1&gt;

&lt;p&gt;Python的语法特性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;语句是逐个运行的。&lt;/li&gt;
  &lt;li&gt;块和语句的边界会自动检测&lt;/li&gt;
  &lt;li&gt;复合语句=首行+&amp;rdquo;:&amp;rdquo;+缩进语句&lt;/li&gt;
  &lt;li&gt;空白行、空格以及注释通常都会忽略&lt;/li&gt;
  &lt;li&gt;文档字符串(docstring)会忽略，但会保存并由工具显示&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;代码分隔符&lt;/h2&gt;

&lt;p&gt;Python会自动以行缩进检测块的边界，也就是程序代码左侧的空白空间。缩进至右侧相同距离的所有语句属于同一块的代码，换句话说，块内的语句会垂直对齐，就好像在一栏之内。更深层的嵌套块就是比所在块进一步向右缩进&lt;/p&gt;

&lt;p&gt;缩进的时候，可以使用空格也可以使用制表符，Python不在乎你怎么缩进，只在乎缩进是否一致。
不过，最好的是使用空格进行缩进，因为一个制表符在不同的编辑器中呈现的效果是不同的，其次也最好不要使用制表符和空格符混合使用&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;语句的分隔符&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;如果使用语法括号对，语句就可以横跨数行&lt;/li&gt;
  &lt;li&gt;如果语句以反斜杠结尾，就可横跨数行&lt;/li&gt;
  &lt;li&gt;字符串常量有特殊规则&lt;/li&gt;
  &lt;li&gt;其他规则&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-3&quot;&gt;真值测试&lt;/h1&gt;

&lt;p&gt;在Python中:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任何非零数字或非空对象都为真&lt;/li&gt;
  &lt;li&gt;数字零、空对象以及特殊对象None都被认作是假&lt;/li&gt;
  &lt;li&gt;比较和相等测试会递归地应用在数据结构中&lt;/li&gt;
  &lt;li&gt;比较和相等测试会返回True或False(1和0的特殊版本)&lt;/li&gt;
  &lt;li&gt;布尔and和or运算会返回真或假的操作对象&lt;/li&gt;
  &lt;li&gt;Python中的and、or运算都是短路运算&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——9.赋值、表达式和打印</title>
   <link href="http://username.github.com/Python/2013/02/02/Learning-Python9.html"/>
   <updated>2013-02-02T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/02/02/Learning-Python9</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;赋值语句&lt;/h1&gt;

&lt;p&gt;赋值语句的特性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;赋值语句建立对象的引用&lt;/li&gt;
  &lt;li&gt;变量名在首次赋值时会被创建&lt;/li&gt;
  &lt;li&gt;变量名在引用前必须先赋值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python赋值语句形式:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;运算&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;spam = &amp;lsquo;Spam&amp;rsquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;基本形式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;spam,ham=&amp;rsquo;yum&amp;rsquo;,&amp;rsquo;YUM&amp;rsquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;元组赋值运算(位置性)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[spam,ham]=[&amp;lsquo;yum&amp;rsquo;,&amp;rsquo;YUM&amp;rsquo;]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;列表赋值运算(位置性)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;a,b,c,d=&amp;rsquo;spam&amp;rsquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;序列赋值运算，通用性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;a,*b =&amp;rsquo;spam&amp;rsquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;扩展的序列解包(Python3.0)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;spam=ham=&amp;rsquo;lunch&amp;rsquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;多目标赋值运算&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;spams += 42&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;增强赋值运算(相当于spams=spams+42)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中有几点需要说明:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第三行和第二行的赋值结果是一样的，spam绑定到&amp;rsquo;yum&amp;rsquo;,ham绑定到&amp;rsquo;YUM&amp;rsquo;,在Python中，这叫做分解赋值&lt;/li&gt;
  &lt;li&gt;第四行的赋值结果是:a赋值为&amp;rsquo;s&amp;rsquo;,b赋值为&amp;rsquo;p&amp;rsquo;,c赋值为&amp;rsquo;a&amp;rsquo;,d赋值为&amp;rsquo;m&amp;rsquo;&lt;/li&gt;
  &lt;li&gt;第五行，用右边的字符串的第一个字母来匹配a，用剩下的部分来匹配b:a赋值为&amp;rsquo;s&amp;rsquo;,b赋值为&amp;rsquo;pam&amp;rsquo;.这在Python称作扩展的解包。需要注意的是，带星号的变量总是返回的是一个列表，哪怕只有一个元素或没有元素&lt;/li&gt;
  &lt;li&gt;最后一行的用法和C/C++等其他语言中的语法和意义都是一样的，需要说明的是，在Python中，每个二元表达式运算符都有增强赋值语句&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;赋值语句执行时，Python会建立临时的元组，来存储右侧变量原始的值&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据上面最后一点的说明，在Python中可以实现不用第三个变量就能交换两个变量的值:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;多目标赋值语句&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;多目标赋值以及共享引用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当使用多目标赋值时，需要注意的是，这些变量都是指向同一个对象的。这对于不可变的类型来说，没什么问题，但是对于原处可变的类型来说，需要特别注意了。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的代码执行后，a和b都是[42]&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;增强赋值语句&lt;/h2&gt;

&lt;p&gt;Python支持一下的增强语句:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;X+=Y&lt;/td&gt;
      &lt;td&gt;X&amp;amp;=Y&lt;/td&gt;
      &lt;td&gt;X-=Y&lt;/td&gt;
      &lt;td&gt;X|=Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X*=Y&lt;/td&gt;
      &lt;td&gt;X^=Y&lt;/td&gt;
      &lt;td&gt;X/=Y&lt;/td&gt;
      &lt;td&gt;X&amp;raquo;=Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X%=Y&lt;/td&gt;
      &lt;td&gt;X&amp;laquo;=Y&lt;/td&gt;
      &lt;td&gt;X**=Y&lt;/td&gt;
      &lt;td&gt;X//=Y&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在Python中使用了优化技术，增强赋值语句会在底层实现时比较高效&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;另外需要注意的是，在使用增强赋值语句时，对于可变变量来说是原处修改的，需要特别注意！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;变量命名规则&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;语法:(下划线或字母)+(任意数目的字母、数字或下划线)&lt;/li&gt;
  &lt;li&gt;区分大小写&lt;/li&gt;
  &lt;li&gt;禁止使用保留字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python3.0中的保留字:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;class&lt;/td&gt;
      &lt;td&gt;finally&lt;/td&gt;
      &lt;td&gt;is&lt;/td&gt;
      &lt;td&gt;return&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;continue&lt;/td&gt;
      &lt;td&gt;for&lt;/td&gt;
      &lt;td&gt;lamdba&lt;/td&gt;
      &lt;td&gt;try&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;def&lt;/td&gt;
      &lt;td&gt;from&lt;/td&gt;
      &lt;td&gt;nonlocal&lt;/td&gt;
      &lt;td&gt;while&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;and&lt;/td&gt;
      &lt;td&gt;del&lt;/td&gt;
      &lt;td&gt;global&lt;/td&gt;
      &lt;td&gt;not&lt;/td&gt;
      &lt;td&gt;with&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;as&lt;/td&gt;
      &lt;td&gt;elif&lt;/td&gt;
      &lt;td&gt;if&lt;/td&gt;
      &lt;td&gt;or&lt;/td&gt;
      &lt;td&gt;yield&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;assert&lt;/td&gt;
      &lt;td&gt;else&lt;/td&gt;
      &lt;td&gt;import&lt;/td&gt;
      &lt;td&gt;pass&lt;/td&gt;
      &lt;td&gt;&amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;break&lt;/td&gt;
      &lt;td&gt;except&lt;/td&gt;
      &lt;td&gt;in&lt;/td&gt;
      &lt;td&gt;raise&lt;/td&gt;
      &lt;td&gt;&amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;命名惯例&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以单一下划线开头的变量名(_X)不会被from module import *语句导入&lt;/li&gt;
  &lt;li&gt;前后有下划线的变量名(&lt;em&gt;X&lt;/em&gt;)是系统定义的变量名，对解释器有特殊意义&lt;/li&gt;
  &lt;li&gt;以两下划线开头、但结尾没有两个下划线的变量名(__X)是类的本地(&amp;ldquo;压缩&amp;rdquo;)变量&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-4&quot;&gt;打印操作&lt;/h1&gt;

&lt;p&gt;在Python中，print语句可以实现打印:只是对程序员友好的标准输出流的接口而已
标准输出流、标准输入流、错误流是脚本启动时所创建的3中数据连接中的一种。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在Python3.X中，打印是一个内置函数，用关键字参数来表示特定模式&lt;/li&gt;
  &lt;li&gt;在Python2.X中，打印是语句，拥有自己的特定语法&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;python30print&quot;&gt;Python3.0中的print函数&lt;/h2&gt;

&lt;p&gt;print函数不会返回任何值，从技术上讲，它将返回None。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;调用格式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从语法上讲，Python3.0中的print函数有如下的形式。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在上述表达式中，方括号中的项是可选的，并且可能会在一个给定的调用中省略，并且=后面的值都给出了参数的默认值。这个内置的函数吧字符串sep所分割开的一个或多个对象的文本表示，后面跟着字符串and，都打印到流file中。&lt;/p&gt;

&lt;p&gt;这些参数是这样控制print操作的:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sep是在每个对象的文本之间插入的一个字符串，如果没有传递的话，它默认地是一个单个空格；传递一个空字符串将会抑制分隔符&lt;/li&gt;
  &lt;li&gt;end是添加在打印文本末尾的一个字符串，如果没有传递的话，它默认的是一个\n换行字符。传递一个空字符将会避免在打印的文本的末尾移动到下一个输入行——下一个print将会保持添加到当前输出行的末尾。&lt;/li&gt;
  &lt;li&gt;file指定了文本将要发送到的文件、标准流或者其他类似文件的对象；如果没有传递的话，默认的是sys.stdout。带有一个类似文件的write(string)的方法的任何对象都可以传递，但真正的文件应该已经为了输出而打开。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;打印流重定向&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python3&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;log.txt&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的代码就简单的标准输出流重定向到了文本文件中，而且是以追加的模式。其实，甚至可以将sys.stdout重设为非文件对象，只要该对象有预期的协议(write方法)。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——8.Python语句简介</title>
   <link href="http://username.github.com/Python/2013/02/01/Learning-Python8.html"/>
   <updated>2013-02-01T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/02/01/Learning-Python8</id>
   <content type="html">&lt;h1 id=&quot;python&quot;&gt;重访Python程序结构&lt;/h1&gt;

&lt;p&gt;概念层次:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;程序由模块构成&lt;/li&gt;
  &lt;li&gt;模块包含语句&lt;/li&gt;
  &lt;li&gt;语句包含表达式&lt;/li&gt;
  &lt;li&gt;表达式建立并处理对象&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;python-1&quot;&gt;Python的语句&lt;/h1&gt;

&lt;p&gt;Python语句&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;语句&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;角色&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;赋值&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;创建引用值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;调用&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;执行函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;打印调用&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;打印对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;if/elif/else&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;选择动作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;for/else&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;序列迭代&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;while/else&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;一般循环&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pass&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;空占位符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;break&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;循环推出&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;continue&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;循环继续&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;def&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;函数和方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;return&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;函数结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;yield&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;生成器函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;global&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;命名空间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;nonlocal&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;命名空间(Pyton3.0)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;import&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;模块访问&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;from&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;属性访问&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;class&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;创建对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;try/except/finally&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;捕捉异常&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;raise&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;触发异常&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;assert&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;调试检查&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;with/as&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;环境管理器(2.6)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;del&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;删除引用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;相关说明:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从技术上讲，print在Python3.0中不是一个保留字，也不是一条语句，而是一个内置函数调用，由于它几乎总是作为一条表达式语句运行，通常将其看做是一条语句类型。&lt;/li&gt;
  &lt;li&gt;yield实际上是一个表达式，而不是一条语句，也是一个保留字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意事项:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在Python2.6中，nonlocal不可用&lt;/li&gt;
  &lt;li&gt;在Python2.6中,print是一条语句，而不是一个内置函数调用&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——7.元组、文件及其他</title>
   <link href="http://username.github.com/Python/2013/01/31/Learning-Python7.html"/>
   <updated>2013-01-31T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/01/31/Learning-Python7</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;元组&lt;/h1&gt;

&lt;p&gt;元组由简单的对象构成。元组与列表非常类似，只不过元组不能再原处修改(它们是不可变的)，通常是写成圆括号(而不是方括号)中一系列项。它的属性有:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任意对象的有序集合&lt;/li&gt;
  &lt;li&gt;通过偏移存取&lt;/li&gt;
  &lt;li&gt;属于不可变序列类型&lt;/li&gt;
  &lt;li&gt;固定长度、异构、任意嵌套&lt;/li&gt;
  &lt;li&gt;对象引用的数组&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;实际应用中的元组&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;元组的特殊语法:逗号和圆括号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为圆括号也可以把表达式括起来，如果圆括号里的单一对象时元组对象而不是一个简单的表达式，需要对Python进行特别说明。如果确实想得到一个元组，只要在这一单个元素之后、关闭圆括号之前加上一个逗号就可以了。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码中，第一行的x是一个整数，第二行的y则是一个包含了一个元素40的元组。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;转换、方法以及不可变性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;元组的操作和字符串及列表是一致的，值得注意的区别在于&amp;rdquo;+&amp;rdquo;、&amp;rdquo;*&amp;ldquo;以及分片操作应用于元组时将返回新元组，并且元组不提供字符串、列表和字典中的方法。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;为什么有了列表还要元组&lt;/h2&gt;

&lt;p&gt;元组的不可变性提供了某种完整性，这样你可以确保元组在程序中不会被另一个引用修改，而列表就没有这样的保证了。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;文件&lt;/h1&gt;

&lt;p&gt;内置open函数后创建一个Python文件对象，可以作为计算机上的一个文件链接。在调用open之后，你可以通过调用返回的文件对象的方法来读写相关外部文件。&lt;/p&gt;

&lt;p&gt;常见文件运算&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;操作&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;output=open(r&amp;rsquo;C:\spam&amp;rsquo;,&amp;rsquo;w&amp;rsquo;)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;创建输出文件(&amp;lsquo;w&amp;rsquo;指写入)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;output=open(&amp;lsquo;data&amp;rsquo;,&amp;rsquo;r&amp;rsquo;)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;创建只读文件(&amp;lsquo;r&amp;rsquo;值只读)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;output=open(&amp;lsquo;data&amp;rsquo;)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;与上一行相同(&amp;lsquo;r&amp;rsquo;是默认值)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;aString=intput.read()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;把整个文件读进单一字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;aString=intput.read(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;读取之后的N个字节(一或多个)到一个字符串中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;aString=input.readline()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;读取下一行(包括行末标识符)到一个字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;aList=input.readlines()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;读取整个文件到字符串列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;output.write(aString)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;写入字节字符串到文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;output.writelines(alist)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;把列表内所有字符串写入文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;output.close()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;手动关闭(当文件收集完成时会替你关闭文件)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;output.flush()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;把输出缓冲区刷到硬盘中，但不关闭文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;anyFile.seek(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;修改文件位置到偏移量N处，以便进行下一个操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;for line in open(&amp;lsquo;data&amp;rsquo;):use line&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;文件迭代器一行一行地读取&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;open(&amp;lsquo;f.txt&amp;rsquo;,encoding=&amp;rsquo;latin-1&amp;rsquo;)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Python3.0 Unicode文本文件(str字符串)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;open(&amp;lsquo;f.bin&amp;rsquo;,&amp;rsquo;rb&amp;rsquo;)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Python3.0 二进制byte文件(bytes字符串)　　　&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-4&quot;&gt;打开文件&lt;/h2&gt;

&lt;p&gt;为了打开一个文件，程序会调用内置open函数，首先是外部文件名，接着是处理模式。模式使用字符串&amp;rsquo;r&amp;rsquo;代表以只读方式打开文件(默认值)，&amp;rsquo;w&amp;rsquo;代表以写的方式打开文件，&amp;rsquo;a&amp;rsquo;代表追加模式。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;使用文件&lt;/h2&gt;

&lt;p&gt;一旦存在一个文件对象，就可以调用其方法来读写相关的外部文件。不管在任何情况下，Python程序中的文本文件都采用字符串的形式，读取文件时会返回字符串形式的文本。&lt;/p&gt;

&lt;p&gt;上面表格中的方法是子常用的读写方法，如下是一些基础用法的提示:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;文件迭代器是最好的读取行的工具&lt;/li&gt;
  &lt;li&gt;内容是字符串，不是对象
当你把数据写入文件时，Python不会自动把对象转换为字符串，你必须传递一个已经格式化的字符串。&lt;/li&gt;
  &lt;li&gt;close是通常选项&lt;/li&gt;
  &lt;li&gt;文件是缓冲的并且是可查找的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;实际应用中的文件&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;用pickle存储Python的原生对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;pickle模块是能够让我们直接在文件中存储几乎任何Python对象的高级工具，也并不要求我们把字符串转换来转换去，它就像是超集通用的数据格式化和解析工具。&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;重访类型分类&lt;/h1&gt;

&lt;p&gt;关于对象类型，有以下的一些药店需要记住:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象根据分类共享操作；&lt;/li&gt;
  &lt;li&gt;只有可变对象(列表、字典和集合)可以原处修改，我们不能原处修改数字、字符串或元组&lt;/li&gt;
  &lt;li&gt;数字类型包括了:整数、浮点数、复数、小数和分数&lt;/li&gt;
  &lt;li&gt;集合类似于一个无值的字典的键，但是，它们不能映射为值，并且没有顺序；因此，集合不是一个映射类型或者一个序列类型，frozenset是集合的一个不可变的版本&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;对象类型&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;分类&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;是否可变&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数字&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数值&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;序列&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;列表&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;序列&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字典&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对应&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;元组&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;序列&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;文件&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;扩展&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;N/A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Sets&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;集合&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;frozenset&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;集合&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;bytearray(3.0)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;序列&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;vs-&quot;&gt;引用 VS 拷贝&lt;/h1&gt;

&lt;p&gt;引用的一大优点是:你可以在程序范围内任何地方传递大型对象而不必途中产生拷贝。&lt;/p&gt;

&lt;p&gt;如果确实需要拷贝，有如下的方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;没有限制条件的分片表达式(L[:])能够复制序列&lt;/li&gt;
  &lt;li&gt;字典copy方法(X.copy())能够复制字典&lt;/li&gt;
  &lt;li&gt;有些内置函数(例如:list)能够生成拷贝(list(L))&lt;/li&gt;
  &lt;li&gt;copy标准库模块能够生成完整拷贝&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于拷贝还需要注意的是:无条件值的分片以及字典copy方法只能做顶层复制。也就是说，不能够复制嵌套的数据结构。如果需要一个深层嵌套的数据结构的完整的、完全独立的拷贝，那么就要使用标准的copy模块，包括&lt;code&gt;import copy&lt;/code&gt;语句，并进行这样的拷贝:&lt;code&gt;x = copy.deepcopy(Y)&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;section-8&quot;&gt;比较、相等性和真值&lt;/h1&gt;

&lt;p&gt;所有的Python对象也可以支持比较操作，测试相等性、相对大小等.Python的比较总是检查复合对象的所有部分，直到可以得出结果为止。事实上，当嵌套对象存在时，Python能够自动遍历数据结构，并从左到右递归地应用比较，要多深就走多深。过程中首次发现的差值将决定比较的结果。
有两种方式可以测试相等性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&amp;rdquo;==&amp;rdquo;操作符测试值的相等性。Python运行相等测试&lt;/li&gt;
  &lt;li&gt;&amp;ldquo;is&amp;rdquo;表达式测试对象的一致性。Python测试二者是否是同一个对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，Python中不同的类型的比较方法如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数字通过相对大小进行比较&lt;/li&gt;
  &lt;li&gt;字符串按照字典顺序，一个字符接一个字符地对比进行比较(&amp;ldquo;abc&amp;rdquo;&amp;lt;&amp;rdquo;ac&amp;rdquo;)&lt;/li&gt;
  &lt;li&gt;列表和元组从左到右对每部分进行比较&lt;/li&gt;
  &lt;li&gt;字典通过排序之后的(键、值)列表进行比较。&lt;/li&gt;
  &lt;li&gt;数字混合类型比较在Python3.0中是错误的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;python&quot;&gt;Python中真和假的含义&lt;/h2&gt;

&lt;p&gt;在Python中，整数0代表假，整数1代表真。&lt;/p&gt;

&lt;p&gt;除此之外，Python也把任意的空数据结构视为假，把任何非空数据结构视为真。真和假的概念是Python中每个对象的固有属性:每个对象不是真就是假:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数字如果非零，则为真 &lt;/li&gt;
  &lt;li&gt;其他对象如果非空，则为真&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;None对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python还有一个特殊的对象:None，总被认为是假，一般都是起到一个空的占位作用&lt;/p&gt;

&lt;h2 id=&quot;type&quot;&gt;Type对象&lt;/h2&gt;

&lt;p&gt;事实上，即使是类型本身在Python中也是对象类型&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——6.列表与字典</title>
   <link href="http://username.github.com/Python/2013/01/30/Learning-Python6.html"/>
   <updated>2013-01-30T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/01/30/Learning-Python6</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;列表&lt;/h1&gt;

&lt;p&gt;列表是Python中最具灵活性的有序集合对象类型。与字符串不同的是，列表可以包含任何类型的对象:数字、字符串甚至其他列表。列表是可变对象，它支持原地修改的操作。&lt;/p&gt;

&lt;p&gt;Python的列表是:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任意对象的有序集合&lt;/li&gt;
  &lt;li&gt;通过偏移读取&lt;/li&gt;
  &lt;li&gt;可变长度、异构以及任意嵌套&lt;/li&gt;
  &lt;li&gt;属于可变序列的分类&lt;/li&gt;
  &lt;li&gt;对象引用数组(列表中的存储的是对象的引用，而不是对象的拷贝)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-1&quot;&gt;实际应用中的列表&lt;/h1&gt;

&lt;h2 id=&quot;section-2&quot;&gt;基本列表操作&lt;/h2&gt;

&lt;p&gt;由于列表是序列，它支持很多与字符串相同的操作。列表对&amp;rdquo;+&amp;rdquo;和&amp;rdquo;*&amp;ldquo;操作的响应与字符串很相似，两个操作的意思也是合并和重复，只不过是一个新的列表，而不是一个字符串。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;索引、分片和矩阵&lt;/h2&gt;

&lt;p&gt;对于列表而言，索引和分片操作与字符串中的操作基本相同。然而对列表进行索引的结果就是你指定的偏移处的对象(不管是什么类型)，而对列表分片时往往返回一个新的列表。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码定义了一个3*3的二维矩阵。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;原处修改列表&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;索引与分片的赋值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当使用列表的时候，可以将它赋值给一个特定项(偏移)或整个片段(分片)来改变它的内容，索引和分片的赋值都是原地修改，它们对列表进行直接修改，而不是生成一个新的列表作为结果.Python中的索引赋值与C及大多数其他语言极为相似——Python用一个新值取代指定偏移的对象引用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;列表方法的调用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最常用的列表方法是append，它能够简单地将一个单项(对象引用)加至列表末端。与合并不同的是，append允许传入单一对象而不是列表。L.append(X)与L+[X]的结果类似，不同的是，前者会原地修改L，而后者会生成新的列表。
另一个比较常用的方法就是sort，它原地对列表进行排序。sort是使用Python标准的比较检验作为默认值(在这里指字符串比较)，而且以递增的顺序进行排序。另外，我们可以通过传入一个关键字参数来修改排序行为——这是指定按名称传递的函数调用中特殊的&amp;rdquo;name=value&amp;rdquo;语言。&lt;/p&gt;

&lt;p&gt;需要注意的是:要当心append和sort是原地修改列表对象的，方法的返回结果并没有返回列表(从技术上讲，两者的返回值都是None)。如果编写类似&lt;code&gt;L=L.append(X)&lt;/code&gt;的语句，将不会得到修改后的值(实际上，会失去整个列表的引用)。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;reverse:原地反转列表&lt;/li&gt;
  &lt;li&gt;extend:在末端插入多个元素&lt;/li&gt;
  &lt;li&gt;pop:删除最后一个元素，同时返回被删除的值&lt;/li&gt;
  &lt;li&gt;remove:通过值删除某个元素&lt;/li&gt;
  &lt;li&gt;insert:在偏移处插入某个元素&lt;/li&gt;
  &lt;li&gt;index:查找某元素的偏移&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-5&quot;&gt;字典&lt;/h1&gt;

&lt;p&gt;如果把列表看做是有序的对象集合，那么就可以把字典当成是无序的集合，它们主要的差别就在于:字典当中的元素师通过键来存取的，而不是通过偏移存取。
Python字典的主要属性如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过键而不是偏移来读取&lt;/li&gt;
  &lt;li&gt;任意对象的无序集合&lt;/li&gt;
  &lt;li&gt;可变长、异构、任意嵌套&lt;/li&gt;
  &lt;li&gt;属于可变映射类型&lt;/li&gt;
  &lt;li&gt;对象引用表(散列表)(字典中的存储的是对象的引用，而不是对象的拷贝)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-6&quot;&gt;实际应用中的字典&lt;/h1&gt;

&lt;h2 id=&quot;section-7&quot;&gt;原处修改字典&lt;/h2&gt;

&lt;p&gt;与列表相同，向字典中已存在的索引值赋值会改变与索引相关联的值。然而，与列表不同的是，每当对新字典键进行赋值(之前没有被赋值的键)，就会在字典内生成一个新的元素。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;其他字典的方法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;keys:返回字典的键列表&lt;/li&gt;
  &lt;li&gt;values:返回字典的值列表&lt;/li&gt;
  &lt;li&gt;items:返回字典的(key,value)对元组&lt;/li&gt;
  &lt;li&gt;update:合并&lt;/li&gt;
  &lt;li&gt;pop:从字典中删除一个键并返回它的值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-9&quot;&gt;字典用法注意事项&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;序列运算无效&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;对新索引赋值会添加项&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;键不一定总是字符串&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-10&quot;&gt;创建字典的其他方法&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;#Method1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;mel&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;age&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#Method2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;mel&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;age&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#Method3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;mel&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#Method4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;mel&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;age&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上四种形式都会建立相同的字典。&lt;/p&gt;

&lt;h2 id=&quot;python30&quot;&gt;Python3.0中的字典变化&lt;/h2&gt;

&lt;p&gt;字典的功能在Python3.0中已经有所变化了，具体来说，Python3.0中的字典:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;支持一种新的字典解析表达式，这是列表和集合解析的&amp;rdquo;近亲&amp;rdquo;&lt;/li&gt;
  &lt;li&gt;对于D.key,D.values和D.items方法，返回可迭代的视图，而不是列表&lt;/li&gt;
  &lt;li&gt;由于前面一点，需要新的编码方式通过排序键来遍历&lt;/li&gt;
  &lt;li&gt;不再直接支持相对大小比较——取而代之的是手动比较&lt;/li&gt;
  &lt;li&gt;不再有D.has_key方法——相反，使用in成员关系测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;字典视图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Python3.0中，字典的keys、values和items都返回视图对象，而在Python2.6中，它们返回实际的结果列表。Python3.0中的字典视图并非创建后不能改变，它们可以动态地反映在视图对象创建之后对字典做出点修改:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;del&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码中，最后一行的结果是[&amp;lsquo;a&amp;rsquo;,&amp;rsquo;c&amp;rsquo;]。&lt;/p&gt;

&lt;p&gt;keys方法所返回的对象类似于集合，并且支持交集和并集等常见的操作；values视图不是这样，因为它们不是唯一的；但items结果是的，如果(key,value)对是唯一的并且可散列的话。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——5.字符串</title>
   <link href="http://username.github.com/Python/2013/01/29/Learning-Python5.html"/>
   <updated>2013-01-29T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/01/29/Learning-Python5</id>
   <content type="html">&lt;p&gt;Python字符串——一个有序的字符的集合。
Python的字符串被划分为不可变序列，意味着它们不可以在原处修改。
常见的字符串常量和表达式。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;操作&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s=&amp;rsquo;&amp;rsquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;空字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s=&amp;rdquo;spam&amp;rsquo;s&amp;rdquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;双引号和单引号相同&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s=&amp;rsquo;s\np\ta\x00m&amp;rsquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;转义序列&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s=&amp;rdquo;&amp;rdquo;&amp;rdquo;&amp;hellip;&amp;rdquo;&amp;rdquo;&amp;rdquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;三重引号字符串块&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s=r&amp;rsquo;\temp\spam&amp;rsquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Raw字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s=b&amp;rsquo;spam&amp;rsquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Python3.0中的字节字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s=u&amp;rsquo;spam&amp;rsquo;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;仅在Python2.6中使用的Unicode字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s1+s2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;合并&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s * 3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;重复&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s[i]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;索引&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s[i:j]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;分片&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;len(s)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;长度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;ldquo;a %s parrot&amp;rdquo; % kind&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串格式化表达式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;ldquo;a {0} parrot&amp;rdquo;.format(kind)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Python2.6和Python3.0中的字符串格式化方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s.find(&amp;lsquo;pa&amp;rsquo;)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串方法调用:搜索&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s.rstrip()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;移除空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s.replace(&amp;lsquo;pa&amp;rsquo;,&amp;rsquo;xx&amp;rsquo;)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;替换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s.split(&amp;lsquo;,&amp;rsquo;)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用展位符分隔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s.isdigit()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;内容测试&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s.lower()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;短信息转换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s.endswidth()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;结束测试&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;lsquo;spam&amp;rsquo;.join(strlist)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;插入分隔符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s.encode(&amp;lsquo;latin-1&amp;rsquo;)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Unicode编码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;for x in S:print(x)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;迭代&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;lsquo;spam&amp;rsquo; in X&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[c * 2 for c in S]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;map(ord,S)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;section&quot;&gt;字符串常量&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;单双引号字符串是一样的&lt;/h2&gt;

&lt;p&gt;在Python中，单引号和双引号字符是可以互换的
此外，Python自动在任意的表达式中合并相邻的字符串常量，尽管可以简单地在它们之间增加+操作符来明确地表示这是一个合并操作。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;用转义序列代表特殊字节&lt;/h2&gt;

&lt;p&gt;反斜杠用来引入特殊的字节编码——转义序列。
转义序列让我们能够在字符串中嵌入不容易通过键盘输入的字节。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;转义&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;意义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\newline&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;忽视(连续)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;反斜杠(保留)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;'&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;单引号(保留&amp;rsquo;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&quot;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;双引号(保留&amp;rdquo;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\a&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;响铃&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\b&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;倒退&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\f&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;换页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\n&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;新行(换行)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\r&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;返回&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\t&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;水平制表符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\v&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;垂直制表符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\N{id}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Unicode数据库ID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\uhhhh&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Unicode16位的十六进制值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\UHHHHHHHH&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Unicode32位的十六进制值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\xhh&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;十六进制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\ooo&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;八进制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Null(不是字符串结尾)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\other&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不转义(保留)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;raw&quot;&gt;raw字符串抑制转义&lt;/h2&gt;

&lt;p&gt;如果字母r(大写或小写)出现在字符串的第一引号的前面，它将会关闭转移机制。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;三重引号编写多行字符串块&lt;/h2&gt;

&lt;p&gt;Python还有一种三重引号的字符串常量格式，有时称作块字符串。这个形式以三重引号开始(单引号双引号都可以)，并紧跟任意行数的文本，并且以开始时同样的三重引号结尾。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;实际应用中的字符串&lt;/h1&gt;

&lt;h2 id=&quot;section-5&quot;&gt;索引和分片&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;索引(S[i])获取特定偏移的元素:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一个元素的偏移为0&lt;/li&gt;
  &lt;li&gt;负偏移索引意味着从最后或右边反向进行计数&lt;/li&gt;
  &lt;li&gt;S[0]获取了第一个元素&lt;/li&gt;
  &lt;li&gt;S[-2]获取了倒数第二个元素&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;分片(S[i:j])提取对应的部分作为一个序列:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上边界并不包含在内&lt;/li&gt;
  &lt;li&gt;如果没有给出的话，分片的边界默认为0和序列的长度&lt;/li&gt;
  &lt;li&gt;S[1:3]获取了从偏移为1的元素，直到但不包括偏移为3的元素&lt;/li&gt;
  &lt;li&gt;S[1:]获取了从偏移为1直到末尾(偏移为序列长度)之间的元素&lt;/li&gt;
  &lt;li&gt;S[:3]获取了从偏移为0直到但是不包括偏移为3之间的元素&lt;/li&gt;
  &lt;li&gt;S[:-1]获取了从偏移为0直到但不包括最后一个元素之间的元素&lt;/li&gt;
  &lt;li&gt;S[:]获取了从偏移0到末位之间的所有元素，这有效地实现了顶层S拷贝&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分片表达式，还可以有第三个索引参数，用作步长，完整形式的分片变成了:X[I:J:K],这表示:&lt;strong&gt;索引X对象中的元素，从偏移为I直到偏移为J-1，每隔K元素索引一次&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;字符串转换工具&lt;/h2&gt;

&lt;p&gt;int():将字符串转换为数字
str():将数字转换为字符串表达形式
float():将字符串转换为浮点数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符串代码转换&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ord():将单个字符转换为对应的ASCII码
chr():获取ASCII码并将其转化为对应的字符&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;字符串方法&lt;/h1&gt;

&lt;p&gt;除了表达式运算符之外，字符串还提供了一系列的方法去实现更复杂的文本处理任务。方法就是与特定的对象相关联在一起的函数。从技术角度来讲，它们附属于对象的属性，而这些属性不过是些可调用的函数罢了。&lt;/p&gt;

&lt;p&gt;字符串是不可变的，所以不能在远处直接对其进行修改。为了在已存在字符串中创建新的文本值，我们可以通过分片和合并这样的操作来建立新的字符串。&lt;/p&gt;

&lt;h1 id=&quot;section-8&quot;&gt;字符串格式化表达式&lt;/h1&gt;

&lt;p&gt;如今的Python中的字符串格式化可以以两种形式实现:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符串格式化表达式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是从Python诞生的时候就有的最初的技术；这是基于C语言的&amp;rdquo;printf&amp;rdquo;模型，并且在大多数现有的代码中使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符串格式化方法调用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是Python2.6和Python3.0新增加的技术，这是Python独有的方法，并且和字符串格式化表达式的功能有很大重叠。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;That is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; bird!&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;dead&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码的结果就是:That is 1 dead bird!&lt;/p&gt;

&lt;p&gt;从技术上讲，字符串的格式化表达式往往是可选的——通常你可以使用多次的多字符串的合并和转换达到类似的目的。然后格式化允许我们将多个步骤合并为一个简单的操作，这一功能相当强大。&lt;/p&gt;

&lt;p&gt;需要注意的是:格式化总是会返回新的字符串作为结果，而不是对左侧的字符串进行修改。&lt;/p&gt;

&lt;p&gt;字符串格式化代码&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;代码&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;意义　　　　　　　　　　　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;s&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串(或任何对象)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;r&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s,但使用repr，而不是str&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;c&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;十进制(整数)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;i&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;整数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;u&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无号(整数)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;o&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;八进制数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;十六进制数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;x，但打印大写&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;e&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;浮点指数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;E&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;e,但打印大写&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;f&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;浮点十进制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;浮点十进制&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;g&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;浮点e或f&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;G&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;浮点E或f&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;%&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;常量%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事实上，在格式化字符串中，表达式左侧的转换目标支持多种转换操作，这些操作自由一套相当严谨的语法，转换目标的通用结构看上去是这样的:
&lt;code&gt;%[(name)][flags][width][.precision]typecode&lt;/code&gt;
有关格式化目标的语法在Python的标准手册中都有完整的介绍。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;基于字典的字符串格式化&lt;/h2&gt;

&lt;p&gt;字符串的格式化同时也允许左边的转换目标来引用右边字典中的键来提取对应的值。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%(n)d&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%(x)s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;n&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;spam&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上代码的结果是:&amp;rsquo;1 spam&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&quot;section-10&quot;&gt;字符串格式化调用方法&lt;/h1&gt;

&lt;h2 id=&quot;section-11&quot;&gt;基础知识&lt;/h2&gt;

&lt;p&gt;简而言之，Python2.6和Python3.0(及其以后的版本)中的新的字符串对象的format方法使用主体字符串作为模板，并且接受任意多个表示将要根据模板替换的值的参数。在主体字符串中，花括号通过为止或关键字指出替换目标及将要插入的参数。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;{0},{1} and {2}&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;spam&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;ham&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;eggs&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码的结果是&amp;rsquo;spam,ham and eggs&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;添加键、属性和偏移量&lt;/h2&gt;

&lt;p&gt;格式化字符串可以指定对象属性和字典键，方括号指定字典键，而点表示位置或关键字所引用的一项对象属性。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;#39;My {1[spam] runs {0.platform}&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;spam&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;laptop&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码运行的结果是:&amp;rsquo;My laptop runs win32&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;添加具体格式化&lt;/h2&gt;

&lt;p&gt;格式化的语法:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fieldname&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conversionflag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;formatspec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;fieldname是指定参数的一个数字或关键字，后面跟着可选的&amp;rdquo;.name&amp;rdquo;或[index]成分引用&lt;/li&gt;
  &lt;li&gt;conversionflag可以是r,s后者a分别是在该值上对repr、str或ascii内置函数的一次调用&lt;/li&gt;
  &lt;li&gt;formatspec指定了如何表示该值，包括字段宽度、对齐方式、补零、小数点精度等细节，并且以一个可选的数据类型编码结束&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多细节可以查看Python的库手册。&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;为什么要新的格式化方法&lt;/h2&gt;

&lt;p&gt;格式化方法相对于原来的字符串格式化表达式有以下几个特点:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拥有%表达式所没有的一些额外功能&lt;/li&gt;
  &lt;li&gt;可以更加明确地进行替代值引用&lt;/li&gt;
  &lt;li&gt;考虑到操作符会有一个更容易记忆的方法名&lt;/li&gt;
  &lt;li&gt;不支持用于单个和多个替代之大小写的不同语法&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-15&quot;&gt;通常意义下的类型分类&lt;/h1&gt;

&lt;h2 id=&quot;section-16&quot;&gt;同样分类的类型共享其操作集合&lt;/h2&gt;

&lt;p&gt;在Python中有三个主要类型(以及操作)的分类:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数字(整数、浮点数、二进制、分数等)
支持加法和乘法&lt;/li&gt;
  &lt;li&gt;序列(字符串、列表、元组)
支持索引、分片和合并等&lt;/li&gt;
  &lt;li&gt;映射(字典)
支持通过键的索引等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;索引、分片以及其他的序列操作对于所有的序列来说都是同样有效的，对象的类型将会告诉Python去执行什么样的任务。&lt;/p&gt;

&lt;h2 id=&quot;section-17&quot;&gt;可变类型能够在原处修改&lt;/h2&gt;

&lt;p&gt;Python中的主要核心类型划分为如下两类:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不可变类型(数字、字符串、元组、不可变集合)
不可变的分类中没有哪个对象类型支持原处修改，尽管我们总是可以运行表达式来创建新的对象并将其结果分配给变量&lt;/li&gt;
  &lt;li&gt;可变类型(列表、字典、可变集合)
相反，可变的类型总是可以通过操作原处修改，而不用创建新的对象&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——4.动态类型简介</title>
   <link href="http://username.github.com/Python/2013/01/28/Learning-Python4.html"/>
   <updated>2013-01-28T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/01/28/Learning-Python4</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;缺少类型声明语句的情况&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;变量、对象和引用&lt;/h2&gt;
&lt;p&gt;在Python中，变量有如下的几个相关概念:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量创建
一个变量(也就是变量名)，就像a，当代吗第一次给它赋值时就创建了它。之后的赋值将会改变已创建的变量名的值。&lt;/li&gt;
  &lt;li&gt;变量类型
变量永远不会有任何的和它关联的类型信息或约束。类型的概念是存在于对象中而不是变量名中。变量原本就是通用的，它只是在一个特定的时间点，简单地引用了一个特定的对象而已。&lt;/li&gt;
  &lt;li&gt;变量使用
当变量出现在表达式中时，它会马上被当前引用的对象所代替，无论这个对象是什么类型。此外，所有的变量必须在其使用前明确地赋值，使用未赋值的变量会产生错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当执行到:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样的代码时，从概念上说，Python将会执行三个不同的步骤去完成这个请求。这些步骤反映了Python语言中所有赋值的操作:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个对象来代表值3&lt;/li&gt;
  &lt;li&gt;创建一个变量a，如果它还没有创建的话&lt;/li&gt;
  &lt;li&gt;将变量与新的对象3相连接&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从上面的三个步骤可以看出，变量和对象保存在内存中的不同部分，并通过连接相关联。变量总是连接到对象，并且绝不会连接到其他变量上，但是更大的对象可能连接到其他的对象。
在Python中从变量到对象的连接称作引用，也就是说，引用是一种关系，以内存中的指针的形式实现。一旦变量被使用，Python自动跟随这个变量到对象的连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类型属于对象，而不是变量名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用具体的术语来讲:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量是一个系统表的元素，拥有指向对象的连接的空间&lt;/li&gt;
  &lt;li&gt;对象是分配的一块内存，有足够的空间去表示它们所代表的值&lt;/li&gt;
  &lt;li&gt;引用是自动形成的从变量到对象的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从技术上讲，一个对象是具有更复杂的结构的，每一个对象都有两个标准的头部信息:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个类型标识符去标识这个对象的类型&lt;/li&gt;
  &lt;li&gt;一个引用的计数器，用来决定是不是可以回收这个对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;对象的垃圾收集&lt;/h2&gt;

&lt;p&gt;在Python中，每当一个变量名被赋予一个新的对象，之前那个对象占用的空间就会被回收(如果它没有被其他的变量名或对象所引用的话)。这种自动回收对象空间的计数就做垃圾收集。
在Python内部，Python是这样实现这个功能的:它在每个对象中保持了一个计数器，计数器记录了当前指向该对象的引用的数目。一旦(并精确在同一时间)这个计数器被设置为0，这个对象的内存空间就会自动回收。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;共享引用&lt;/h1&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码的实际效果就是变量a和变量b都引用了相同的对象(也就是说，指向了相同的内存)。这在Python中叫做共享引用——多个变量名引用了同一个对象。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码的最终结果就是，a指向数据为5的内存空间，b指向数据为3的内存空间。事实上，是没有办法修改对象3的值的，之前就提到过，整数是不可变的，因此没有办法在远处修改。在Python中，变量总是一个指向对象的指针，而不是可改变的内存区域的标签:给一个变量赋一个新的值，并不是替换了原始的对象，而是让这个变量去引用完全不同的一个对象。实际的效果就是对一个变量赋值，仅仅会影响那个被赋值的变量。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;共享引用和在原处修改&lt;/h2&gt;

&lt;p&gt;但是事实上有一些对象和操作确实会在原处改变对象(例如列表)。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;L1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;L2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;L1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码的结果是，L1指向一个值为24的对象，L2仍是引用最初的列表。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;L1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;L2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;L1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码的结果是，L1和L2同时引用了值为[24,3,4]的列表。
必须注意上两段代码的不同之处。&lt;/p&gt;

&lt;p&gt;如果不想发生以上的情况，那就需要Python拷贝对象，而不是创建引用。
有很多方法可以拷贝一个列表，最常用的方法就是从头到尾的分片。
但是，分片这种方法是不能应用在其他的可变的核心类型上(字典和集合，因为它们不是序列)，复制一个字典或集合应该使用X.copy()方法调用。在标准库中的copy模块有一个通用的复制任意对象类型的调用:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;copy&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deepcopy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在Python中，可变的对象包括了列表、字典以及一些通过class语句定义的对象。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;共享引用和相等&lt;/h2&gt;

&lt;p&gt;通常来说，考虑到效率的问题，Python会缓存并复用了小的整数和小的字符串，例如如下的代码:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;shrubbery&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里的对象42也许并没有被马上回收，而是仍被存在一个系统表中，等待下一次你的代码生成另一个42来重复引用。尽管有这种机制，但是大部分对象都会在不再引用时马上回收。&lt;/p&gt;

&lt;p&gt;在Python中有两种&amp;rdquo;相等&amp;rdquo;:
==操作符:测试两个被引用的对象是否有相同的值
is操作符:检查对象的同一性，就是检查两个变量名是否是指向同一个对象&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——3.数字</title>
   <link href="http://username.github.com/Python/2013/01/27/Learning-Python3.html"/>
   <updated>2013-01-27T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/01/27/Learning-Python3</id>
   <content type="html">&lt;h1 id=&quot;python&quot;&gt;Python的数字类型&lt;/h1&gt;

&lt;p&gt;Python数字类型的完整工具包括:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;整数和浮点数&lt;/li&gt;
  &lt;li&gt;复数&lt;/li&gt;
  &lt;li&gt;固定精度的十进制数&lt;/li&gt;
  &lt;li&gt;有理分数&lt;/li&gt;
  &lt;li&gt;集合&lt;/li&gt;
  &lt;li&gt;布尔类型&lt;/li&gt;
  &lt;li&gt;无穷的整数精度&lt;/li&gt;
  &lt;li&gt;各种数字内置函数和模块&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;数字常量&lt;/h2&gt;

&lt;p&gt;基本数字常量:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;数字&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;常量&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1234,-24,0,99999999999&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;整数(无穷大小)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1.23,1.,3.14e-10,4E210,4.0e+210&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;浮点数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0177,0x9ff,0b101010&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Python2.6中的八进制、十六进制、二进制常量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0o177,0x9ff,0b101010&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Python3.0中的八进制、十六进制、二进制常量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3+4j,3.0+4.0j,3j&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;复数常量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;内置数学工具和扩展&lt;/h2&gt;

&lt;p&gt;除了上述表格中的内置数字常量之外，Python还提供了一系列处理数字对象的工具:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;表达式操作符&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;+,-,*,/,&amp;raquo;,**,&amp;amp;等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内置数学函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;pow,abs,round,int,hex,bin等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;公用模块&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;random,math等&lt;/p&gt;

&lt;h2 id=&quot;python-1&quot;&gt;Python表达式操作符&lt;/h2&gt;

&lt;p&gt;Python表达式操作符及程序&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;操作符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;yield x&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;生成器函数发送协议&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;lamdba args:expression&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;生成匿名函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x if y else z&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;三元选择表达式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x or y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑或(只有x为假，才会计算y)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x and y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑与(只有x为真,才会计算y)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;not x&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑非&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x in y,x not in y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;成员关系(可迭代对象、集合)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x is y,x is not y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对象实体测试&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x&amp;lt;y,x&amp;lt;=y,x&amp;gt;y,x&amp;gt;=y,x==y,x!=y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;大小比较，集合子集和超集相等性操作符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x | y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;位或,集合并集&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x ^ y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;位异或，集合对称差&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x &amp;amp; y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;位与,集合交集&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x &amp;laquo;&amp;nbsp;y,x&amp;nbsp;&amp;raquo; y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;左移或右移y位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x + y,x -y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;加法/合并,减法,集合差集&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x * y,x % y,x / y,x // y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;乘法/重复,余数/格式化,除法:整除法或floor除法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-x,+x&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;一元减法，识别&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;~x&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;按位求补(取反)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x ** y&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;幂运算&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x[i]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;索引(序列、映射及其他)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x[i:j:k]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;分片&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x(&amp;hellip;)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;调用(函数、方法、类及其他可调用的)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x.attr&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;属性引用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;(&amp;hellip;)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;元组，表达式，生成器表达式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[&amp;hellip;]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;列表，列表解析&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{&amp;hellip;}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字典、集合、集合和字典解析&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;混合操作所遵循的操作优先级&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在上表中，表中的操作符越是靠后的优先级越高，因此在混合表达式中要更加小心&lt;/li&gt;
  &lt;li&gt;表中位于同一行的表达式在组合的时候通常从左到右组合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;括号分组的子表达式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果用括号将表达式各部分进行分组的话，就可以完全忽略优先级的事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;混合类型的自动升级&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在混合类型的表达式中，Python首先将被操作的对象转换成其中最复杂的操作对象的类型，然后再对相同类型的的操作对象进行数学运算。
Python是这样划分数字类型的复杂度的:整数比浮点数简单，浮点数比复数简单。
另外需要注意的是，这些混合类型转换仅仅在将数字类型混合到一个表达式中的时候才使用。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;在实际应用中的数字&lt;/h1&gt;

&lt;h2 id=&quot;section-3&quot;&gt;比较:一般的和连续的&lt;/h2&gt;

&lt;p&gt;Python允许把多个比较连续起来执行范围测试，例如:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;#相当于 X &amp;lt; Y and Y &amp;lt; Z&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;floor&quot;&gt;除法:传统除法、Floor除法和真除法&lt;/h2&gt;

&lt;p&gt;X / Y:&lt;/p&gt;

&lt;p&gt;传统除法和真除法。在Python2.x中，这个操作对于整数会省去小数部分，对于浮点数会保持小数部分。在Python3.0中变成了真除法(无论任何类型都会保持小数部分)。&lt;/p&gt;

&lt;p&gt;X // Y:&lt;/p&gt;

&lt;p&gt;Floor除法。这个操作不考虑操作对象的类型，总会省略结果的小数部分，剩下最小的能整除的整数部分.针对整数返回一个整数，如果有任何一个操作数是浮点数，则返回一个浮点数。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;十六进制、八进制和二进制计数&lt;/h2&gt;

&lt;p&gt;Python提供了很多内置函数进行进制的转换:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;oct():将十进制数转换为八进制数&lt;/li&gt;
  &lt;li&gt;hex():将十进制数转换为十六进制数&lt;/li&gt;
  &lt;li&gt;bin():将十进制数转换为二进制数&lt;/li&gt;
  &lt;li&gt;int():将一个数字的字符串变换为一个整数，并且可以通过定义的第二个参数来确定按照哪个进制进行转换&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o37&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;#八进制数&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xFF&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;#十六进制&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b11111111&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;#二进制数&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-5&quot;&gt;位操作&lt;/h2&gt;

&lt;p&gt;Python支持像C语言中那样的位操作。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;其他的内置数学工具&lt;/h2&gt;

&lt;p&gt;除了核心对象类型外，Python还支持用于数字处理的内置函数和内置模块。例如内置函数pow和abs，分别计算幂和绝对值。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;math&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;144&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在Python中有3中方法可以计算平方根:使用一个模块函数、一个表达式或一个内置函数。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;math&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;144&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;#函数模块&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;144&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;	 &lt;span class=&quot;c&quot;&gt;#表达式&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;144&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;#内置函数&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外需要注意的是random模块，可以用来产生一个0和1之间的随机数。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Life of Brian&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Holy Grail&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Meaning of Life&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-7&quot;&gt;其他数字类型&lt;/h1&gt;

&lt;h2 id=&quot;section-8&quot;&gt;小数数字&lt;/h2&gt;

&lt;p&gt;Python2.4开始引进了一个新的核心数据对象:小数对象。它比其他数据类型要复杂一些，小数是通过一个导入的模块调用函数后创建的，而不是通过运行常量表达式创建的。从功能上来说，小数对象就像浮点数，只不过它们有固定的位数和小数点，因此小数是有固定的精度的浮点值。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;decimal&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Decimal&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Decimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;0.1&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Decimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;0.1&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Decimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;0.1&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Decimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;0.3&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在上面的代码中，第一和第二行的结果都是5.5511151231257827e-17，因为与硬件相关的浮点数运算在精度方面有内在的缺陷,不过使用小数对象时，就能改正，最后一行的结果是Decimal(&amp;lsquo;0.0&amp;rsquo;)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;设置全局精度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;decimal模块中的其他工具可以用来设置所有小数数值的精度、设置错误处理等。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;decimal&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getcontext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Decimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decimal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Decimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上代码返回的结果是Decimal(&amp;lsquo;0.1429&amp;rsquo;)。
这对于处理货币应用程序非常有用。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;分数类型&lt;/h2&gt;

&lt;p&gt;Python3.0引入了一个新的数字类型——分数，它实现了一个有理数对象。它明确地保留一个分子和一个分母，从而避免了浮点数学的某些不精确性和局限性。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;frations&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fraction&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fraction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fraction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-10&quot;&gt;集合&lt;/h2&gt;
&lt;p&gt;这是一些唯一的、不可变的对象的一个无序集合(collection),这些操作支持与数学集合理论相对应的操作。可以把集合看成一个没有键的字典。
可以使用如下的方式创建一个集合。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;abcde&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是要创建一个空的字典，必须使用内置函数set,因为{}代表的是一个空的字典。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不可变限制和冻结集合&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很大程度上由于其实现，集合只能包含不可变的对象类型。因此，列表和字典不能嵌入到集合中去。但是，如果需要存储复合值的话，元组是可以嵌入的。
集合本身也是不可变的，所以不能直接嵌入到其他集合中，如果需要在另一个集合中存储一个集合，可以像调用set一样来调用frozenset，但是，它创建一个不可变的集合，该集合不可修改并且可以嵌套到其他集合中。&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;布尔型&lt;/h2&gt;

&lt;p&gt;True&amp;mdash;&amp;mdash;&amp;mdash;1
False&amp;mdash;&amp;mdash;&amp;mdash;0&lt;/p&gt;

&lt;h1 id=&quot;section-12&quot;&gt;数字扩展&lt;/h1&gt;

&lt;p&gt;尽管Python的核心数字类型提供的功能对于大多数应用程序已经够用了，还是有大量的第三方开源扩展可以用来解决更加专门的需求。
比如有一个叫做NumPy(Numeric Python)的Python扩展提供了高级的数字编工具，例如矩阵数据类型、向量处理和高级的计算库。像Los Alamos和NASA这样的核心科学编程组织，使用带有NumPy的Python来实现此前用C++、FORTRAN、Matlab编写的任务。Python和NumPy的组合往往可以比作是一款免费的、更加灵活的的Matlab。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——2.介绍Python对象类型</title>
   <link href="http://username.github.com/Python/2013/01/26/Learning-Python2.html"/>
   <updated>2013-01-26T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/01/26/Learning-Python2</id>
   <content type="html">&lt;p&gt;Python程序可以分解成模块、语句、表达式以及对象:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;程序又模块构成&lt;/li&gt;
  &lt;li&gt;模块包含语句&lt;/li&gt;
  &lt;li&gt;语句包含表达式&lt;/li&gt;
  &lt;li&gt;表达式建立并处理对象&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;section&quot;&gt;为什么使用内置类型&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;内置对象使程序更容易编写&lt;/li&gt;
  &lt;li&gt;内置对象时扩展的组件&lt;/li&gt;
  &lt;li&gt;内置对象往往比定制的数据结构更有效率&lt;/li&gt;
  &lt;li&gt;内置对象是语言标准的一部分&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;python&quot;&gt;Python的核心数据类型&lt;/h2&gt;

&lt;p&gt;在Python程序中处理的每一样东西都是一种对象，内置对象如下表所示:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;对象类型&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;例子 常量/创建&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数字&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1234,3.1415,3+4j,Deciaml,Fraction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符串&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;lsquo;spam&amp;rsquo;,&amp;rdquo;guido&amp;rsquo;s&amp;rdquo;,b&amp;rsquo;a\xolc&amp;rsquo;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;列表&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[1,[2,&amp;rsquo;three&amp;rsquo;],4]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字典&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{&amp;lsquo;food&amp;rsquo;:&amp;rsquo;spam&amp;rsquo;,&amp;rsquo;taste&amp;rsquo;:&amp;rsquo;yum&amp;rsquo;}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;元组&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;(1,&amp;rsquo;spam&amp;rsquo;,4,&amp;rsquo;U&amp;rsquo;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;文件&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;myfile = open(&amp;lsquo;egg&amp;rsquo;,&amp;rsquo;r&amp;rsquo;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;集合&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;set(&amp;lsquo;abc&amp;rsquo;),{&amp;lsquo;a&amp;rsquo;,&amp;rsquo;b&amp;rsquo;,&amp;rsquo;c&amp;rsquo;}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;其他类型&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;类型、None、布尔型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;编程单元类型&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;函数、模块、类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;与实现相关的类型&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;编译的代码堆栈跟踪&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;像函数、模块和类这样的编程单元在Python中也是对象，它们由def、class、import和lamdba这样的语句和表达式创建，并且可以在脚本间自由地传递，存储在其他对象中。&lt;/p&gt;

&lt;p&gt;Python中没有类型声明，运行的表达式的语法决定了创建和使用的对象的类型。一旦创建了一个对象，它就和操作集合绑定了，例如只能对字符串进行字符串相关的操作。&lt;/p&gt;

&lt;p&gt;Python是动态类型的(&lt;strong&gt;它自动跟踪你的类型而不是要求声明代码&lt;/strong&gt;)，但是他也是强类型语言。(&lt;strong&gt;你只能对一个对象进行适合该类型的有效操作&lt;/strong&gt;)&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;数字&lt;/h1&gt;

&lt;p&gt;Python中的数字支持一般的数学运算，包括加法(+),乘法(*),除法(/),整除(//),取模(%),乘方(**)。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;字符串&lt;/h1&gt;

&lt;p&gt;从严格意义上说，字符串是单个字符的字符串的序列，其他类型的序列还包括列表和元组。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;序列的操作&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作为序列，字符串支持针对各个元素位置顺序的操作。在Python中，索引是从0开始的，但是我们也可以反向索引，从最后一个开始，-1代表最后一个元素，-2代表倒数第二个元素，以此类推。比较好的记忆方法是:负的索引号简单地与字符串长度相加，就得到了正向的索引号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分片&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除了简单的从位置进行索引，序列也支持一种分片(slice)操作，这是一种一步就能够提取整个分片(slice)的方法:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;Spam&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;它们的一般形式为X[I:J],表示&amp;rdquo;取出在X中从偏移量为I，直到但不包括偏移量为J的内容&amp;rdquo;，结果就是返回一个新的对象。
在一个分片中，左边界默认为0，并且右边界默认为分片序列的长度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;合并&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作为一个序列，字符串也支持使用加号进行合并(将两个字符串合并成为一个新的字符串)。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;不可变性&lt;/h2&gt;

&lt;p&gt;字符串在Python具有不可变性，&lt;strong&gt;也就是说在创建后不能就地改变&lt;/strong&gt;，但是你总是可以通过建立一个新的字符串并以同一个变量名对其进行赋值，因为Python在运行过程中会清理旧对象。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;Spam&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;z&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在Python中，每一个对象都可以分为不可变性或可变性，在核心类型中，数字、字符串和元组是不可变的，列表和字典是可变的。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;类型特定的方法&lt;/h2&gt;

&lt;p&gt;到目前为止讲到的操作都是Python中序列对象共有的，包括列表和元组。字符串也有一些自己特殊的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;find&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;字符串的find方法是一个基本的子字符串查找的操作。(它将返回一个传入子字符串的偏移量，或者没有找到的情况下返回-1)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;replace&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;replace方法将会对全局进行搜索和替换。&lt;/p&gt;

&lt;p&gt;这些字符串的方法都不会改变原来的字符串，只是会生成一个新的字符串对象作为返回对象。&lt;/p&gt;

&lt;p&gt;注意:尽管序列操作是通用的，但方法不通用(虽然某些类型共享某些方法名)。一条简明的法则是这样的:&lt;strong&gt;可作用于多种类型的通用型操作都是以内置函数或表达式的形式出现的[例如,len(X),X[0]]，但是类型特定的操作是以方法调用的形式出现的。[例如,aString.find(&amp;lsquo;x&amp;rsquo;)]&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;寻求帮助&lt;/h2&gt;

&lt;p&gt;想要查看对象详细的方法，可以调用内置的&lt;code&gt;dir&lt;/code&gt;函数，它将返回一个列表，其中包含了对象的所有属性。(对象属性包括方法)
&lt;code&gt;dir&lt;/code&gt;函数简单地给出了方法的名称，要查询它们是做什么的，你可以将其传递给&lt;code&gt;help&lt;/code&gt;函数。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;Spam&amp;#39;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;编写字符串的其他方法&lt;/h2&gt;

&lt;p&gt;在Python中，反斜线转义序列表示特殊的字符，Python允许字符串包括在单引号或双引号中。(它们代表着相同的东西)
Python也支持原始(raw)字符串常量，即去掉反斜线转义机制。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;模式匹配&lt;/h2&gt;

&lt;p&gt;Python的字符串对象能够支持基于模式的文本处理，详细的内容后面介绍。&lt;/p&gt;

&lt;h1 id=&quot;section-9&quot;&gt;列表&lt;/h1&gt;

&lt;p&gt;Python的列表对象是这个语言提供的最通用的序列。列表是一个任意类型的对象的位置相关的有序集合，它没有固定的大小。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;序列操作&lt;/h2&gt;

&lt;p&gt;由于列表是序列的一种，列表支持之前提到的所有序列操作,包括索引、切片等操作。&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;类型特定的操作&lt;/h2&gt;

&lt;p&gt;Python的列表与其他语言中的数组有些类似，但要强大得多。其中一个方面就是，列表没有固定类型的约束，一个列表中的元素可以是各种不同的类型，其次列表是没有固定大小的，它能够按照需要自己增加或减少列表大小。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;append:扩充列表的大小并在列表的尾部插入一项&lt;/li&gt;
  &lt;li&gt;pop:移除给定偏移量的一项，从而让列表减小&lt;/li&gt;
  &lt;li&gt;insert:在任意位置插入元素&lt;/li&gt;
  &lt;li&gt;remove:按照值移除元素&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，大多数列表的方法都会就地改变列表对象，而不是创建一个新的列表。&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;边界检查&lt;/h2&gt;

&lt;p&gt;尽管列表没有固定的大小，Python仍不允许引用不存在的元素，超出列表末尾之外的索引总是会导致错误。&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;嵌套&lt;/h2&gt;

&lt;p&gt;Python核心数据类型的一个优秀的特性就是它们支持任意的嵌套，能够以任意的组合对其进行嵌套，并可以多个层次进行嵌套。&lt;/p&gt;

&lt;h1 id=&quot;section-14&quot;&gt;字典&lt;/h1&gt;

&lt;p&gt;Python中的字典是完全不同的东西:它们不是序列，而是一种映射(mapping)。映射是一个其他对象的集合，但是它们是通过键而不是相对位置来存储的。实际上，映射并没有任何可靠的从左至右的顺序。它们简单地讲键映射到值。字典是Python核心对象集合中的唯一的一种映射类型，也具有可变性——可以就地改变，并可以随需求增大或减少，就像列表那样。&lt;/p&gt;

&lt;h2 id=&quot;section-15&quot;&gt;映射操作&lt;/h2&gt;

&lt;p&gt;作为常量编写时，字典编写在大括号中，并包含一系列的&amp;rdquo;键:值&amp;rdquo;对。通过键索引一个字典往往是Python中编写搜索的最快方法。
字典的索引操作使用的是和序列相同的语法，但是在方括号中的元素是键，而不是相对位置。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;job&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;dev&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;age&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-16&quot;&gt;重访嵌套&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;first&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;last&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Smith&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
			 &lt;span class=&quot;s&quot;&gt;&amp;#39;job&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;dev&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;mgr&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
			 &lt;span class=&quot;s&quot;&gt;&amp;#39;age&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;40.5&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上面代码所示，Python的核心数据类型是非常灵活的，可以轻松的建立复杂的信息结构。&lt;/p&gt;

&lt;h2 id=&quot;for&quot;&gt;键的排序:for循环&lt;/h2&gt;

&lt;p&gt;之前说过，字典中是没有顺序的，全部都是以键来进行索引的，但是，如果确实需要强调顺序的时候，可以这样做:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;=&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;sorted是内置函数，sorted调用返回结果并对各种对象类型进行排序。&lt;/p&gt;

&lt;h2 id=&quot;if&quot;&gt;不存在的键:if测试&lt;/h2&gt;

&lt;p&gt;尽管我们能够通过给新的键赋值来扩展字典，但是获取一个不存在的键仍然是一个错误.可以利用in和if进行判断:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;f&amp;#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;missing&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-17&quot;&gt;元组&lt;/h1&gt;

&lt;p&gt;元组基本上就像一个不可以改变的列表，就像列表一样，元组是序列，但是它具有不可变性，和字符串类似。从语法上讲，它们编写在圆括号中而不是方括号中，他们支持任意类型、任意嵌套以及常见的序列操作。&lt;/p&gt;

&lt;p&gt;元组还有两个专有的可调用方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;index:返回元素的偏移值&lt;/li&gt;
  &lt;li&gt;count:返回元素在元组中出现的次数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-18&quot;&gt;为什么要用元组&lt;/h2&gt;

&lt;p&gt;元组在实际应用并不如列表那么常用，但是它的关键在于不可变性。如果在程序中以列表的形式传递一个对象的集合，它可能在任何地方改变，如果使用元组的话，就不能。也就是说，元组提供了一种完整性约束，这对于我们这里所编写的更大型的程序来说是方便的。&lt;/p&gt;

&lt;h1 id=&quot;section-19&quot;&gt;文件&lt;/h1&gt;

&lt;p&gt;文件对象是Python代码对计算机上外部文件的主要接口。虽然文件时核心类型，但是它有些特殊:没有特定的常量语法来创建文件。要创建一个文件对象，需要调用内置的open函数以字符串的形式传递给它一个外部的文件名以及一个处理模式的字符串。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;data.txt&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Hello&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;World&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-20&quot;&gt;总结&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Python中的核心对象有:数字、字符串、列表、字典、元组、文件和集合。&lt;/li&gt;
  &lt;li&gt;其中，数字、字符串和元组具有不可变性。&lt;/li&gt;
  &lt;li&gt;字符串、元组、列表是属于序列的，是有顺序的。&lt;/li&gt;
  &lt;li&gt;字典不属于序列，它是没有顺序的。&lt;/li&gt;
  &lt;li&gt;Python中的关键思想之一:&lt;strong&gt;不要把代码限制在特定的类型上，使代码自动适用于多种类型&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>《Learning Python》学习笔记——1.Python如何运行程序</title>
   <link href="http://username.github.com/Python/2013/01/25/Learning-Python1.html"/>
   <updated>2013-01-25T00:00:00+08:00</updated>
   <id>http://username.github.com/Python/2013/01/25/Learning-Python1</id>
   <content type="html">&lt;h1 id=&quot;python&quot;&gt;Python解释器简介&lt;/h1&gt;

&lt;p&gt;Python不仅是一门编程语言，也是一个名为解释器的软件包。解释器是一种让其他程序运行起来的程序。实际上，解释器是代码与机器的计算机硬件之间的软件逻辑层。在UNIX/Linux上，Python通常是安装在/usr目录下的。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;程序执行&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;程序员的视角&lt;/h2&gt;

&lt;p&gt;Python程序的源代码通常是以.py来命名的，当你将代码保存为一个文本文件之后，你必须告诉Python解释器去执行这个文件。&lt;/p&gt;

&lt;h2 id=&quot;python-1&quot;&gt;Python的视角&lt;/h2&gt;

&lt;p&gt;当Python运行脚本时，在代码开始进行处理之前，Python还会执行一些步骤。确切地说，第一步是编译成所谓的&amp;rdquo;字节码&amp;rdquo;,之后将其转发到所谓的&amp;rdquo;虚拟机&amp;rdquo;中.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字节码编译&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编译是一个简单的翻译步骤，而且字节码是源代码底层的、与平台无关的表现形式。概括地说，Python通过把每一条源语句分解为单一步骤来将这些源语句翻译成一组字节码指令，这些字节码可以提高执行速度。
编译好的字节码文件将会被Python自动保存为.pyc文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python虚拟机(PVM)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一旦程序编译成字节码，之后的字节码发送到通常称为Python虚拟机(Python Virtual Machine,PVM)上来执行，实际上它不是一个独立的程序，不需要安装。事实上，PVM就是迭代运行字节码指令的一个大循环，一个接一个地完成操作。PVM是Python的运行引擎，它时常表现为Python系统的一部分，并且它是实际运行脚本的组件。从技术上讲，它才是所谓&amp;rdquo;Python解释器&amp;rdquo;的最后一步。&lt;/p&gt;

&lt;h1 id=&quot;python-2&quot;&gt;Python实现的替代者&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CPython&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;原始的标准的Python实现方式，它运行的速度最快、最完整而且也是最健全的。它可以脚本化C和C++组件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JPython&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;JPython是一种Python语言的替代实现方式，其目的是为了与Java编程语言集成。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IronPython&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Python的第三种实现方式是IronPython(比CPython和JPython都要新)，其设计目的是让Python程序可以与Windows平台上的.NET框架以及与之对应的Linux上开源的Mono编写的应用相集成&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Vim自定义语法高亮</title>
   <link href="http://username.github.com/Vim/2012/12/03/Vim-Develop-Syntax.html"/>
   <updated>2012-12-03T00:00:00+08:00</updated>
   <id>http://username.github.com/Vim/2012/12/03/Vim-Develop-Syntax</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;基本的语法命令&lt;/h1&gt;
&lt;p&gt;在定义一种新的语法规则之前，首先要做的就是清楚已经定义的旧规则:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; clear
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这对于最终的语法文件来说并不是必须的，但在实验这些功能时还是十分有用的。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;列出已定义的语法项&lt;/h2&gt;
&lt;p&gt;查看当前已经定义的语法项：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;大小些敏感&lt;/h2&gt;
&lt;p&gt;下面的命令决定了语法规则的匹配是否是大小写敏感的:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; case mathch 
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; case ignore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;match&lt;/code&gt;表示大小写敏感,&lt;code&gt;ignore&lt;/code&gt;表示不敏感&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:syntax case&lt;/code&gt;命令可以出现在一个语法文件的任意位置并影响该位置以后的语法定义。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;关键字&lt;/h1&gt;
&lt;p&gt;下面的命令定义一个关键字:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; keyword {group} {keyword} ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;{group}&lt;/code&gt;是语法组的名字。使用&lt;code&gt;:highlight&lt;/code&gt;命令你可以将一组颜色方案应用到该&lt;code&gt;{group}&lt;/code&gt;上。&lt;code&gt;{keyword}&lt;/code&gt;参数指定了实际的关键字，下面是一个例子:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; keyword xType int long char
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; keyword xStatement &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; then &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据约定，每个组名都前缀以该语言的filetype,本例中定义了x语言，所以前缀是x。为了方便其他人比较好的理解，在实际编写语法文件的时候，最好还是遵守这个约定。&lt;/p&gt;

&lt;p&gt;现在可以把定义好的x组名于标准的Vim组名联系起来。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;highlight&lt;/span&gt; link xType Type
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;highlight&lt;/span&gt; link xStatement Statement
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;生僻的关键字&lt;/h2&gt;
&lt;p&gt;定义的关键字必须是&lt;code&gt;iskeyword&lt;/code&gt;选项的定义。如果你用到了额外的字符，该关键字将不会被匹配到。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;iskeyword&lt;/code&gt;是vim中一个选项，vim会把这个选项中的字符做为单词的组成字符。也就是说，一个单词由&lt;code&gt;iskeyword&lt;/code&gt;选项中定义的字符构成，它前面、后面的字符不在&lt;code&gt;iskeyword&lt;/code&gt;选项定义的字符中。简单的说，&lt;code&gt;iskeyword&lt;/code&gt;是用来确定单词的分界的。可以通过&lt;code&gt;:help iskeyword&lt;/code&gt;来进行查看，vim的默认值是&amp;rdquo;a-z,A-Z,48-57,_,.,-,&amp;gt;&amp;rdquo;，其中的48-57表示的是ASCII码中的数字0-9。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;若x语言要再关键字中使用&lt;code&gt;-&lt;/code&gt;字符，可以这样做：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;setlocal&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;iskeyword&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+=-&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; keyword xStatement when&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;not
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:关键字只适用于一个完整的词,所以像nextone这样的是不会被匹配到的。&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;匹配&lt;/h1&gt;
&lt;p&gt;如果要定义一个复杂的语法项，比如匹配一个标示符，那就需要用到match语法：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xIdenifier &lt;span class=&quot;sr&quot;&gt;/\&amp;lt;\l\+&amp;gt;/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意:关键字会凌驾于任何其他语法项定义，所以&lt;code&gt;if&lt;/code&gt;,&lt;code&gt;then&lt;/code&gt;将被认为是关键字，而不是标示符。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面的命令中的最后一部分是一个模式，&lt;code&gt;//&lt;/code&gt;用于界定一个模式，也可以用&lt;code&gt;/&lt;/code&gt;之外的字符，如&lt;code&gt;+&lt;/code&gt;或&lt;code&gt;&quot;&lt;/code&gt;号。&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;区域&lt;/h1&gt;
&lt;p&gt;如果在x语言中，字符串定义为由两个双引号包围起来的字符序列。要高亮一个字符串需要定义一个区域。该区域以双引号结尾。定义如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; region xString &lt;span class=&quot;k&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/&amp;quot;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/&amp;quot;/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;start&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;分别定义了该区域的开始和结尾。&lt;/p&gt;

&lt;p&gt;如果需要Vim跳过以&quot;形式表达的脱字符，这要在命令中用到&lt;code&gt;skip&lt;/code&gt;关键字:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; region xString &lt;span class=&quot;k&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/&amp;quot;/&lt;/span&gt; skip&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/\\&amp;quot;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/&amp;quot;/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;两个&lt;code&gt;\\&lt;/code&gt;匹配到一个真正的反斜杠&lt;code&gt;\&lt;/code&gt;字符，因为反斜杠&lt;code&gt;\&lt;/code&gt;在模式中是一个特殊字符。&lt;/p&gt;

&lt;h2 id=&quot;regionmatch&quot;&gt;&lt;code&gt;region&lt;/code&gt;和&lt;code&gt;match&lt;/code&gt;的区别&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;match&lt;/code&gt;:是一个完整的模式，一次匹配一整个字符序列。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;region&lt;/code&gt;:是一个区域以&lt;code&gt;start&lt;/code&gt;指定的模式为开始，以&lt;code&gt;end&lt;/code&gt;指定的模式为结束。区域中的&lt;code&gt;end&lt;/code&gt;模式可能被匹配到也可能不被匹配。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-7&quot;&gt;嵌套&lt;/h1&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;%Get input TODO: Skip white space
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在假设要让&lt;code&gt;TODO&lt;/code&gt;以黄色来高亮显示，尽管它已经在一个定义为蓝色高亮的注释中。要让Vim识别这种情况，可以定义下面的语法组:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; keyword xTodo contained
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xComment &lt;span class=&quot;sr&quot;&gt;/%.*/&lt;/span&gt; contains&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xTodo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;contained&lt;/code&gt;参数告诉Vim该关键字只能存在于另一个语法项中。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;contains=xTodo&lt;/code&gt;则说明允许一个组名xTodo的语法元素嵌套在其中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;递归嵌套&lt;/h2&gt;
&lt;p&gt;x语言定义了以花括号&lt;code&gt;{}&lt;/code&gt;括起来的部分分为一个代码块。当然一个代码可以包含另一个代码块。这样需要下面的定义：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; region xBlock &lt;span class=&quot;k&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/{/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/}/&lt;/span&gt; contains&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xBlock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;section-9&quot;&gt;保留行尾&lt;/h2&gt;
&lt;p&gt;为了避免一个被包含语法项吃掉行尾，要在命令中加一个额外的&lt;code&gt;keepend&lt;/code&gt;参数。这个参数可以使Vim正确处理需要匹配到行尾两次的语法项。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; region xComment &lt;span class=&quot;k&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/%/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/$/&lt;/span&gt; contained
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; region xPreProc &lt;span class=&quot;k&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/#/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/$/&lt;/span&gt; contains&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xComment keepend
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-10&quot;&gt;后续组&lt;/h1&gt;
&lt;p&gt;如果有如下的语句:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是你希望这三个部分用不同的规则来高亮，你可以这样做:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xif &lt;span class=&quot;sr&quot;&gt;/if/&lt;/span&gt; nextgroup&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xIfCondition skipwhite
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xIfCondition &lt;span class=&quot;sr&quot;&gt;/([^)]*)/&lt;/span&gt; contained nextgroup&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xThen skipwhite
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xThen &lt;span class=&quot;sr&quot;&gt;/then/&lt;/span&gt; contained
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;nextgroup&lt;/code&gt;参数指定哪些组可以跟在该组后面，这个参数并不是必须的。如果由它指定的任何一个组都不符合匹配，Vim什么也不做。
- &lt;code&gt;skipwhite&lt;/code&gt;参数告诉vim空白字符(空格和跳格键)可以出现在语法项之间。
- &lt;code&gt;skipnl&lt;/code&gt;允许语法项之间出现断行。
- &lt;code&gt;skipempty&lt;/code&gt;允许出现空行&lt;/p&gt;

&lt;p&gt;需要注意的是:&lt;code&gt;skipnl&lt;/code&gt;并不会跳过任何空行，它要求断行之后必须有东西被匹配到才行。&lt;/p&gt;

&lt;h1 id=&quot;section-11&quot;&gt;其他参数&lt;/h1&gt;

&lt;h2 id=&quot;section-12&quot;&gt;匹配一个区域&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;matchgroup&lt;/code&gt;参数可以以另外一种高亮组来处理区域的首尾部分。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; region xInside matchgroup&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xParen &lt;span class=&quot;k&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/(/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/)/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码告诉vim，上述区域的首尾都是用xParen组来高亮，而且中间其他部分用xInside来高亮。&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;偏移&lt;/h2&gt;
&lt;p&gt;如果想要定义一个区域匹配&amp;rdquo;if&amp;rdquo;之后的&amp;rdquo;()&amp;rdquo;之间的内容。但是却不包含&amp;rdquo;if&amp;rdquo;和&amp;rdquo;(&amp;ldquo;、&amp;rdquo;)&amp;rdquo;本身，这可以通过匹配模式中的偏移来实现。例如:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; region xCond &lt;span class=&quot;k&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/if\s*(/&lt;/span&gt;ms&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/)/&lt;/span&gt;me&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;-1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;起始模式的偏移是&amp;rdquo;ms=e+1&amp;rdquo;,&amp;rdquo;ms&amp;rdquo;代表&amp;rdquo;Match Start&amp;rdquo;。它定义了一个自目标字符串起始位置的偏移。通常匹配的起始位置就是模式目标的起始位置。&amp;rdquo;e+1&amp;rdquo;则告诉vim匹配的起始位置始自模式目标的结束处再向前偏移一个字符。结束模式的偏移是&amp;rdquo;me=s-1&amp;rdquo;,&amp;rdquo;me&amp;rdquo;是指&amp;rdquo;Match End&amp;rdquo;,&amp;rdquo;s-1&amp;rdquo;意为模式目标的起始处的上一个字符。&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;单行&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;online&amp;rdquo;参数告诉vim要匹配的区域不能跨越多行。&lt;/p&gt;

&lt;h2 id=&quot;section-15&quot;&gt;后续行&lt;/h2&gt;
&lt;p&gt;如果需要定义一个预处理语法。预处理行第一列的#开始，直到该行结束。同时可以以\结束的行又指示到下一行将延续未竟的预处理定义。要应付这种情况就需要在语法项中包含一个指向后续行的模式。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; region xPreProc &lt;span class=&quot;k&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/^#/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/$/&lt;/span&gt; contains&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xLineContinue
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xLineContinue &lt;span class=&quot;s2&quot;&gt;&amp;quot;\\$&amp;quot;&lt;/span&gt; contained
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-16&quot;&gt;聚簇&lt;/h1&gt;
&lt;p&gt;如果一些语句中包含了一些共同的语法元素:数字和标示符，我们可以这样定义:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xFor &lt;span class=&quot;sr&quot;&gt;/^for.*/&lt;/span&gt; contains&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xNumber&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;xIdent
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xIf &lt;span class=&quot;sr&quot;&gt;/^if.*/&lt;/span&gt; contains&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xNumber&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;xIdent
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xWhile &lt;span class=&quot;sr&quot;&gt;/^while.*/&lt;/span&gt; contains&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xNumber&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;xIdent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是每一个语法项都要重复&amp;rdquo;contains&amp;rdquo;的内容，比较麻烦，而且修改起来更加麻烦。vim提供了一个叫做语法簇的工具，来避免上述的问题:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; cluster xState contains&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;xNumber&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;xIndent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;簇被用在其他以syntax语法定义语句中。就像语法组一样，它们的名字以@开始。你可以这样简化上述的例子:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xFor &lt;span class=&quot;sr&quot;&gt;/^for.*/&lt;/span&gt; contains&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;@xState
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xIf &lt;span class=&quot;sr&quot;&gt;/^if.*/&lt;/span&gt; contains&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;@xState
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; xWhile &lt;span class=&quot;sr&quot;&gt;/^while.*/&lt;/span&gt; contains&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;#xState
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-17&quot;&gt;包含另一个语法文件&lt;/h1&gt;
&lt;p&gt;在很多情况，我们可能需要引用另外一个语法文件，例如C++的语法就是C语法的一个超集，在这种情况下，vim提供了在一个语法中读取另一个语法文件的功能:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;runtime&lt;span class=&quot;p&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;k&quot;&gt;vim&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;:runtime!&lt;/code&gt;会在由&amp;rdquo;runtimepath&amp;rdquo;指定的目录中寻找&amp;rdquo;syntax/c.vim&amp;rdquo;文件。&lt;/p&gt;

&lt;h1 id=&quot;section-18&quot;&gt;同步&lt;/h1&gt;
&lt;p&gt;vim对文本进行语法高亮，需要能够&amp;rdquo;断章取义&amp;rdquo;，程序写到哪里，它就要跟到哪里，并且能正确的进行语法高亮。vim提供了&lt;code&gt;:syntax sync&lt;/code&gt;命令，它告诉vim如何确定当前的境况。比如，下面的命令告诉Vim回溯查找c风格的注释，并从注释的起始处开始对该语法进行着色:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sync&lt;/span&gt; ccomment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此外，还有可以以一些参数调整该命令的处理细节。&lt;code&gt;minlines&lt;/code&gt;参数告诉Vim最少要往回查找多少行，&lt;code&gt;maxlines&lt;/code&gt;告诉编辑器最多检查多少行。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sync&lt;/span&gt; ccomment minlines&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt; maxlines&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;500&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id=&quot;section-19&quot;&gt;安装一个语法文件&lt;/h1&gt;
&lt;p&gt;当你有一个新的语法文件的时候，把它放在&lt;code&gt;runtimepath&lt;/code&gt;指定的路径下名为&amp;rdquo;syntax&amp;rdquo;的目录。语法文件的名字必需与文件类型名一致，以&amp;rdquo;.vim&amp;rdquo;为扩展名。&lt;/p&gt;

&lt;h1 id=&quot;section-20&quot;&gt;可移植语法文件的布局要求&lt;/h1&gt;
&lt;p&gt;文件开头的样板注释:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;vim&quot;&gt;&lt;span class=&quot;c&quot;&gt;&amp;quot;Vim syntax file&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;quot;Language: C&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;quot;Maintainer: Bram Moolenaar&amp;lt;Bram@vim.org&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;quot;Last Change: 2001 Jun 18&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;quot;Remark: Included by the C++ syntax&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</content>
 </entry>
 
 
</feed>
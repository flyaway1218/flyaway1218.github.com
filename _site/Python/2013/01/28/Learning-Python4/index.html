
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>《Learning Python》学习笔记——4.动态类型简介</title>
    
    <meta name="author" content="Flyaway">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/wiki/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/wiki/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/wiki/css/syntax.css?body=1" rel="stylesheet" type="text/css" media="all">
    <script type="text/javascript" src="/assets/themes/wiki/js/jquery-1.9.0.min.js"></script>
    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>
    <div class="header row">
	<ul >
	  <li><a href="/">Home</a></li>
	  <li><a href="#">About</a></li>
	  <li><a href="http://zhouyichu.com">Blog</a></li>
	</ul>
    </div>

<div class="title row ">
 
《Learning Python》学习笔记——4.动态类型简介

</div>


      <div class="content">
        

<h1 id="section">缺少类型声明语句的情况</h1>

<h2 id="section-1">变量、对象和引用</h2>
<p>在Python中，变量有如下的几个相关概念:</p>

<ul>
  <li>变量创建
一个变量(也就是变量名)，就像a，当代吗第一次给它赋值时就创建了它。之后的赋值将会改变已创建的变量名的值。</li>
  <li>变量类型
变量永远不会有任何的和它关联的类型信息或约束。类型的概念是存在于对象中而不是变量名中。变量原本就是通用的，它只是在一个特定的时间点，简单地引用了一个特定的对象而已。</li>
  <li>变量使用
当变量出现在表达式中时，它会马上被当前引用的对象所代替，无论这个对象是什么类型。此外，所有的变量必须在其使用前明确地赋值，使用未赋值的变量会产生错误。</li>
</ul>

<p>当执行到:</p>

<div class="highlight"><pre><code class="python"><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div>

<p>这样的代码时，从概念上说，Python将会执行三个不同的步骤去完成这个请求。这些步骤反映了Python语言中所有赋值的操作:</p>

<ol>
  <li>创建一个对象来代表值3</li>
  <li>创建一个变量a，如果它还没有创建的话</li>
  <li>将变量与新的对象3相连接</li>
</ol>

<p>从上面的三个步骤可以看出，变量和对象保存在内存中的不同部分，并通过连接相关联。变量总是连接到对象，并且绝不会连接到其他变量上，但是更大的对象可能连接到其他的对象。
在Python中从变量到对象的连接称作引用，也就是说，引用是一种关系，以内存中的指针的形式实现。一旦变量被使用，Python自动跟随这个变量到对象的连接。</p>

<p><strong>类型属于对象，而不是变量名</strong></p>

<p>用具体的术语来讲:</p>

<ul>
  <li>变量是一个系统表的元素，拥有指向对象的连接的空间</li>
  <li>对象是分配的一块内存，有足够的空间去表示它们所代表的值</li>
  <li>引用是自动形成的从变量到对象的指针</li>
</ul>

<p>从技术上讲，一个对象是具有更复杂的结构的，每一个对象都有两个标准的头部信息:</p>

<ul>
  <li>一个类型标识符去标识这个对象的类型</li>
  <li>一个引用的计数器，用来决定是不是可以回收这个对象</li>
</ul>

<h2 id="section-2">对象的垃圾收集</h2>

<p>在Python中，每当一个变量名被赋予一个新的对象，之前那个对象占用的空间就会被回收(如果它没有被其他的变量名或对象所引用的话)。这种自动回收对象空间的计数就做垃圾收集。
在Python内部，Python是这样实现这个功能的:它在每个对象中保持了一个计数器，计数器记录了当前指向该对象的引用的数目。一旦(并精确在同一时间)这个计数器被设置为0，这个对象的内存空间就会自动回收。</p>

<h1 id="section-3">共享引用</h1>

<div class="highlight"><pre><code class="python"><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
</code></pre></div>

<p>上面代码的实际效果就是变量a和变量b都引用了相同的对象(也就是说，指向了相同的内存)。这在Python中叫做共享引用——多个变量名引用了同一个对象。</p>

<div class="highlight"><pre><code class="python"><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="mi">2</span>
</code></pre></div>

<p>上面代码的最终结果就是，a指向数据为5的内存空间，b指向数据为3的内存空间。事实上，是没有办法修改对象3的值的，之前就提到过，整数是不可变的，因此没有办法在远处修改。在Python中，变量总是一个指向对象的指针，而不是可改变的内存区域的标签:给一个变量赋一个新的值，并不是替换了原始的对象，而是让这个变量去引用完全不同的一个对象。实际的效果就是对一个变量赋值，仅仅会影响那个被赋值的变量。</p>

<h2 id="section-4">共享引用和在原处修改</h2>

<p>但是事实上有一些对象和操作确实会在原处改变对象(例如列表)。</p>

<div class="highlight"><pre><code class="python"><span class="n">L1</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">L2</span><span class="o">=</span><span class="n">L1</span>
<span class="n">L1</span><span class="o">=</span><span class="mi">24</span>
</code></pre></div>

<p>上面代码的结果是，L1指向一个值为24的对象，L2仍是引用最初的列表。</p>

<div class="highlight"><pre><code class="python"><span class="n">L1</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">L2</span><span class="o">=</span><span class="n">L1</span>
<span class="n">L1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">24</span>
</code></pre></div>

<p>上面代码的结果是，L1和L2同时引用了值为[24,3,4]的列表。
必须注意上两段代码的不同之处。</p>

<p>如果不想发生以上的情况，那就需要Python拷贝对象，而不是创建引用。
有很多方法可以拷贝一个列表，最常用的方法就是从头到尾的分片。
但是，分片这种方法是不能应用在其他的可变的核心类型上(字典和集合，因为它们不是序列)，复制一个字典或集合应该使用X.copy()方法调用。在标准库中的copy模块有一个通用的复制任意对象类型的调用:</p>

<div class="highlight"><pre><code class="python"><span class="kn">import</span> <span class="nn">copy</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</code></pre></div>

<p>在Python中，可变的对象包括了列表、字典以及一些通过class语句定义的对象。</p>

<h2 id="section-5">共享引用和相等</h2>

<p>通常来说，考虑到效率的问题，Python会缓存并复用了小的整数和小的字符串，例如如下的代码:</p>

<div class="highlight"><pre><code class="python"><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">x</span> <span class="o">=</span> <span class="s">&#39;shrubbery&#39;</span>
</code></pre></div>

<p>这里的对象42也许并没有被马上回收，而是仍被存在一个系统表中，等待下一次你的代码生成另一个42来重复引用。尽管有这种机制，但是大部分对象都会在不再引用时马上回收。</p>

<p>在Python中有两种&rdquo;相等&rdquo;:
==操作符:测试两个被引用的对象是否有相同的值
is操作符:检查对象的同一性，就是检查两个变量名是否是指向同一个对象</p>



<script type="text/javascript" src="/assets/themes/wiki/js/wikiscript.js"></script>


      </div>

      <footer >
        <p>&copy; Flyaway 2012 
		 Powered By <a href="http://www.vim.org">Vim</a> and <a href="http://jekyllrb.com">Jekyll</a> </p> </footer> 
  </body>
<script type="text/javascript">
$(document).ready(function(){
	$("a[href^='http://']").each(function(){
		this.target="_blank";
	});
	$('h2').prepend('>>')
	$(function(){
		$(".span12 h1").bind("click",function(){
			var $content=$(this).next();
			$content.slideToggle("slow");	
		})
	})




})
</script>
</html>

